// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: merchant.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMerchantTag = `-- name: AddMerchantTag :exec

INSERT INTO merchant_tags (
  merchant_id,
  tag_id
) VALUES (
  $1, $2
)
`

type AddMerchantTagParams struct {
	MerchantID int64 `json:"merchant_id"`
	TagID      int64 `json:"tag_id"`
}

// ==================== 商户标签关联 ====================
func (q *Queries) AddMerchantTag(ctx context.Context, arg AddMerchantTagParams) error {
	_, err := q.db.Exec(ctx, addMerchantTag, arg.MerchantID, arg.TagID)
	return err
}

const autoCloseMerchants = `-- name: AutoCloseMerchants :many
UPDATE merchants
SET
  is_open = false,
  auto_close_at = NULL,
  updated_at = now()
WHERE is_open = true
  AND auto_close_at IS NOT NULL
  AND auto_close_at <= now()
RETURNING id
`

// 自动打烊（用于定时任务）
func (q *Queries) AutoCloseMerchants(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, autoCloseMerchants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const clearMerchantBossBindCode = `-- name: ClearMerchantBossBindCode :exec
UPDATE merchants
SET boss_bind_code = NULL, boss_bind_code_expires_at = NULL, updated_at = now()
WHERE id = $1
`

// 清除 Boss 认领码
func (q *Queries) ClearMerchantBossBindCode(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, clearMerchantBossBindCode, id)
	return err
}

const clearMerchantTags = `-- name: ClearMerchantTags :exec
DELETE FROM merchant_tags
WHERE merchant_id = $1
`

func (q *Queries) ClearMerchantTags(ctx context.Context, merchantID int64) error {
	_, err := q.db.Exec(ctx, clearMerchantTags, merchantID)
	return err
}

const countMerchantsByRegion = `-- name: CountMerchantsByRegion :one
SELECT COUNT(*) FROM merchants
WHERE region_id = $1
  AND deleted_at IS NULL
`

// 统计区域内商户数量
func (q *Queries) CountMerchantsByRegion(ctx context.Context, regionID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantsByRegion, regionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMerchantsByRegionWithStatus = `-- name: CountMerchantsByRegionWithStatus :one
SELECT COUNT(*) FROM merchants
WHERE region_id = $1
  AND ($2::varchar IS NULL OR status = $2)
  AND deleted_at IS NULL
`

type CountMerchantsByRegionWithStatusParams struct {
	RegionID int64  `json:"region_id"`
	Column2  string `json:"column_2"`
}

// 统计区域内指定状态的商户数量
func (q *Queries) CountMerchantsByRegionWithStatus(ctx context.Context, arg CountMerchantsByRegionWithStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantsByRegionWithStatus, arg.RegionID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchMerchants = `-- name: CountSearchMerchants :one
SELECT COUNT(*) FROM merchants
WHERE status = 'active'
  AND deleted_at IS NULL
  AND name ILIKE '%' || $1 || '%'
`

func (q *Queries) CountSearchMerchants(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchMerchants, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBusinessHour = `-- name: CreateBusinessHour :one

INSERT INTO merchant_business_hours (
  merchant_id,
  day_of_week,
  open_time,
  close_time,
  is_closed,
  special_date
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at
`

type CreateBusinessHourParams struct {
	MerchantID  int64       `json:"merchant_id"`
	DayOfWeek   int32       `json:"day_of_week"`
	OpenTime    pgtype.Time `json:"open_time"`
	CloseTime   pgtype.Time `json:"close_time"`
	IsClosed    bool        `json:"is_closed"`
	SpecialDate pgtype.Date `json:"special_date"`
}

// ==================== 商户营业时间 ====================
func (q *Queries) CreateBusinessHour(ctx context.Context, arg CreateBusinessHourParams) (MerchantBusinessHour, error) {
	row := q.db.QueryRow(ctx, createBusinessHour,
		arg.MerchantID,
		arg.DayOfWeek,
		arg.OpenTime,
		arg.CloseTime,
		arg.IsClosed,
		arg.SpecialDate,
	)
	var i MerchantBusinessHour
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsClosed,
		&i.SpecialDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMerchant = `-- name: CreateMerchant :one

INSERT INTO merchants (
  owner_user_id,
  name,
  description,
  logo_url,
  phone,
  address,
  latitude,
  longitude,
  status,
  application_data,
  region_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at
`

type CreateMerchantParams struct {
	OwnerUserID     int64          `json:"owner_user_id"`
	Name            string         `json:"name"`
	Description     pgtype.Text    `json:"description"`
	LogoUrl         pgtype.Text    `json:"logo_url"`
	Phone           string         `json:"phone"`
	Address         string         `json:"address"`
	Latitude        pgtype.Numeric `json:"latitude"`
	Longitude       pgtype.Numeric `json:"longitude"`
	Status          string         `json:"status"`
	ApplicationData []byte         `json:"application_data"`
	RegionID        int64          `json:"region_id"`
}

// ==================== 商户管理 ====================
func (q *Queries) CreateMerchant(ctx context.Context, arg CreateMerchantParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, createMerchant,
		arg.OwnerUserID,
		arg.Name,
		arg.Description,
		arg.LogoUrl,
		arg.Phone,
		arg.Address,
		arg.Latitude,
		arg.Longitude,
		arg.Status,
		arg.ApplicationData,
		arg.RegionID,
	)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const createMerchantApplication = `-- name: CreateMerchantApplication :one

INSERT INTO merchant_applications (
  user_id,
  merchant_name,
  business_license_number,
  business_license_image_url,
  legal_person_name,
  legal_person_id_number,
  legal_person_id_front_url,
  legal_person_id_back_url,
  contact_phone,
  business_address,
  business_scope,
  longitude,
  latitude,
  region_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images
`

type CreateMerchantApplicationParams struct {
	UserID                  int64          `json:"user_id"`
	MerchantName            string         `json:"merchant_name"`
	BusinessLicenseNumber   string         `json:"business_license_number"`
	BusinessLicenseImageUrl string         `json:"business_license_image_url"`
	LegalPersonName         string         `json:"legal_person_name"`
	LegalPersonIDNumber     string         `json:"legal_person_id_number"`
	LegalPersonIDFrontUrl   string         `json:"legal_person_id_front_url"`
	LegalPersonIDBackUrl    string         `json:"legal_person_id_back_url"`
	ContactPhone            string         `json:"contact_phone"`
	BusinessAddress         string         `json:"business_address"`
	BusinessScope           pgtype.Text    `json:"business_scope"`
	Longitude               pgtype.Numeric `json:"longitude"`
	Latitude                pgtype.Numeric `json:"latitude"`
	RegionID                pgtype.Int8    `json:"region_id"`
}

// ==================== 商户入驻申请 ====================
func (q *Queries) CreateMerchantApplication(ctx context.Context, arg CreateMerchantApplicationParams) (MerchantApplication, error) {
	row := q.db.QueryRow(ctx, createMerchantApplication,
		arg.UserID,
		arg.MerchantName,
		arg.BusinessLicenseNumber,
		arg.BusinessLicenseImageUrl,
		arg.LegalPersonName,
		arg.LegalPersonIDNumber,
		arg.LegalPersonIDFrontUrl,
		arg.LegalPersonIDBackUrl,
		arg.ContactPhone,
		arg.BusinessAddress,
		arg.BusinessScope,
		arg.Longitude,
		arg.Latitude,
		arg.RegionID,
	)
	var i MerchantApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantName,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseImageUrl,
		&i.LegalPersonName,
		&i.LegalPersonIDNumber,
		&i.LegalPersonIDFrontUrl,
		&i.LegalPersonIDBackUrl,
		&i.ContactPhone,
		&i.BusinessAddress,
		&i.BusinessScope,
		&i.Status,
		&i.RejectReason,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.RegionID,
		&i.FoodPermitUrl,
		&i.FoodPermitOcr,
		&i.BusinessLicenseOcr,
		&i.IDCardFrontOcr,
		&i.IDCardBackOcr,
		&i.StorefrontImages,
		&i.EnvironmentImages,
	)
	return i, err
}

const deleteBusinessHour = `-- name: DeleteBusinessHour :exec
DELETE FROM merchant_business_hours
WHERE id = $1
`

func (q *Queries) DeleteBusinessHour(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteBusinessHour, id)
	return err
}

const deleteMerchant = `-- name: DeleteMerchant :exec
UPDATE merchants SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

// 软删除商户
func (q *Queries) DeleteMerchant(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteMerchant, id)
	return err
}

const deleteMerchantBusinessHours = `-- name: DeleteMerchantBusinessHours :exec
DELETE FROM merchant_business_hours
WHERE merchant_id = $1
`

func (q *Queries) DeleteMerchantBusinessHours(ctx context.Context, merchantID int64) error {
	_, err := q.db.Exec(ctx, deleteMerchantBusinessHours, merchantID)
	return err
}

const getBusinessHour = `-- name: GetBusinessHour :one
SELECT id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at FROM merchant_business_hours
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBusinessHour(ctx context.Context, id int64) (MerchantBusinessHour, error) {
	row := q.db.QueryRow(ctx, getBusinessHour, id)
	var i MerchantBusinessHour
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsClosed,
		&i.SpecialDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBusinessHourByDate = `-- name: GetBusinessHourByDate :one
SELECT id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at FROM merchant_business_hours
WHERE merchant_id = $1
  AND special_date = $2
LIMIT 1
`

type GetBusinessHourByDateParams struct {
	MerchantID  int64       `json:"merchant_id"`
	SpecialDate pgtype.Date `json:"special_date"`
}

func (q *Queries) GetBusinessHourByDate(ctx context.Context, arg GetBusinessHourByDateParams) (MerchantBusinessHour, error) {
	row := q.db.QueryRow(ctx, getBusinessHourByDate, arg.MerchantID, arg.SpecialDate)
	var i MerchantBusinessHour
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsClosed,
		&i.SpecialDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBusinessHourByDayOfWeek = `-- name: GetBusinessHourByDayOfWeek :one
SELECT id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at FROM merchant_business_hours
WHERE merchant_id = $1
  AND day_of_week = $2
  AND special_date IS NULL
LIMIT 1
`

type GetBusinessHourByDayOfWeekParams struct {
	MerchantID int64 `json:"merchant_id"`
	DayOfWeek  int32 `json:"day_of_week"`
}

func (q *Queries) GetBusinessHourByDayOfWeek(ctx context.Context, arg GetBusinessHourByDayOfWeekParams) (MerchantBusinessHour, error) {
	row := q.db.QueryRow(ctx, getBusinessHourByDayOfWeek, arg.MerchantID, arg.DayOfWeek)
	var i MerchantBusinessHour
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsClosed,
		&i.SpecialDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMerchant = `-- name: GetMerchant :one
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetMerchant(ctx context.Context, id int64) (Merchant, error) {
	row := q.db.QueryRow(ctx, getMerchant, id)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const getMerchantApplication = `-- name: GetMerchantApplication :one
SELECT id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images FROM merchant_applications
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMerchantApplication(ctx context.Context, id int64) (MerchantApplication, error) {
	row := q.db.QueryRow(ctx, getMerchantApplication, id)
	var i MerchantApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantName,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseImageUrl,
		&i.LegalPersonName,
		&i.LegalPersonIDNumber,
		&i.LegalPersonIDFrontUrl,
		&i.LegalPersonIDBackUrl,
		&i.ContactPhone,
		&i.BusinessAddress,
		&i.BusinessScope,
		&i.Status,
		&i.RejectReason,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.RegionID,
		&i.FoodPermitUrl,
		&i.FoodPermitOcr,
		&i.BusinessLicenseOcr,
		&i.IDCardFrontOcr,
		&i.IDCardBackOcr,
		&i.StorefrontImages,
		&i.EnvironmentImages,
	)
	return i, err
}

const getMerchantApplicationByLicenseNumber = `-- name: GetMerchantApplicationByLicenseNumber :one
SELECT id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images FROM merchant_applications
WHERE business_license_number = $1
LIMIT 1
`

func (q *Queries) GetMerchantApplicationByLicenseNumber(ctx context.Context, businessLicenseNumber string) (MerchantApplication, error) {
	row := q.db.QueryRow(ctx, getMerchantApplicationByLicenseNumber, businessLicenseNumber)
	var i MerchantApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantName,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseImageUrl,
		&i.LegalPersonName,
		&i.LegalPersonIDNumber,
		&i.LegalPersonIDFrontUrl,
		&i.LegalPersonIDBackUrl,
		&i.ContactPhone,
		&i.BusinessAddress,
		&i.BusinessScope,
		&i.Status,
		&i.RejectReason,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.RegionID,
		&i.FoodPermitUrl,
		&i.FoodPermitOcr,
		&i.BusinessLicenseOcr,
		&i.IDCardFrontOcr,
		&i.IDCardBackOcr,
		&i.StorefrontImages,
		&i.EnvironmentImages,
	)
	return i, err
}

const getMerchantByBindCode = `-- name: GetMerchantByBindCode :one
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE bind_code = $1 AND deleted_at IS NULL
LIMIT 1
`

// 通过邀请码获取商户
func (q *Queries) GetMerchantByBindCode(ctx context.Context, bindCode pgtype.Text) (Merchant, error) {
	row := q.db.QueryRow(ctx, getMerchantByBindCode, bindCode)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const getMerchantByBossBindCode = `-- name: GetMerchantByBossBindCode :one
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE boss_bind_code = $1 AND deleted_at IS NULL
LIMIT 1
`

// 通过 Boss 认领码获取商户
func (q *Queries) GetMerchantByBossBindCode(ctx context.Context, bossBindCode pgtype.Text) (Merchant, error) {
	row := q.db.QueryRow(ctx, getMerchantByBossBindCode, bossBindCode)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const getMerchantByOwner = `-- name: GetMerchantByOwner :one
SELECT m.id, m.owner_user_id, m.name, m.description, m.logo_url, m.phone, m.address, m.latitude, m.longitude, m.status, m.application_data, m.created_at, m.updated_at, m.version, m.region_id, m.is_open, m.auto_close_at, m.deleted_at, m.pending_owner_bind, m.bind_code, m.bind_code_expires_at, m.boss_bind_code, m.boss_bind_code_expires_at FROM merchants m
LEFT JOIN merchant_staff ms ON m.id = ms.merchant_id AND ms.status = 'active'
WHERE (m.owner_user_id = $1 OR ms.user_id = $1) AND m.deleted_at IS NULL
ORDER BY CASE WHEN m.owner_user_id = $1 THEN 0 ELSE 1 END
LIMIT 1
`

// 获取用户关联的商户（支持店主和员工）
// 优先返回 owner_user_id 匹配的商户，其次返回 merchant_staff 关联的商户
func (q *Queries) GetMerchantByOwner(ctx context.Context, ownerUserID int64) (Merchant, error) {
	row := q.db.QueryRow(ctx, getMerchantByOwner, ownerUserID)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const getMerchantIsOpen = `-- name: GetMerchantIsOpen :one
SELECT id, is_open, auto_close_at FROM merchants
WHERE id = $1
`

type GetMerchantIsOpenRow struct {
	ID          int64              `json:"id"`
	IsOpen      bool               `json:"is_open"`
	AutoCloseAt pgtype.Timestamptz `json:"auto_close_at"`
}

// 获取商户营业状态
func (q *Queries) GetMerchantIsOpen(ctx context.Context, id int64) (GetMerchantIsOpenRow, error) {
	row := q.db.QueryRow(ctx, getMerchantIsOpen, id)
	var i GetMerchantIsOpenRow
	err := row.Scan(&i.ID, &i.IsOpen, &i.AutoCloseAt)
	return i, err
}

const getMerchantWithTags = `-- name: GetMerchantWithTags :one

SELECT 
  merchants.id, merchants.owner_user_id, merchants.name, merchants.description, merchants.logo_url, merchants.phone, merchants.address, merchants.latitude, merchants.longitude, merchants.status, merchants.application_data, merchants.created_at, merchants.updated_at, merchants.version, merchants.region_id, merchants.is_open, merchants.auto_close_at, merchants.deleted_at, merchants.pending_owner_bind, merchants.bind_code, merchants.bind_code_expires_at, merchants.boss_bind_code, merchants.boss_bind_code_expires_at,
  COALESCE(
    (
      SELECT json_agg(tags.*)
      FROM tags
      INNER JOIN merchant_tags ON tags.id = merchant_tags.tag_id
      WHERE merchant_tags.merchant_id = merchants.id
    ),
    '[]'::json
  )::json AS tags
FROM merchants
WHERE merchants.id = $1
LIMIT 1
`

type GetMerchantWithTagsRow struct {
	Merchant Merchant `json:"merchant"`
	Tags     []byte   `json:"tags"`
}

// ==================== 高级查询（使用JOIN和聚合）====================
func (q *Queries) GetMerchantWithTags(ctx context.Context, id int64) (GetMerchantWithTagsRow, error) {
	row := q.db.QueryRow(ctx, getMerchantWithTags, id)
	var i GetMerchantWithTagsRow
	err := row.Scan(
		&i.Merchant.ID,
		&i.Merchant.OwnerUserID,
		&i.Merchant.Name,
		&i.Merchant.Description,
		&i.Merchant.LogoUrl,
		&i.Merchant.Phone,
		&i.Merchant.Address,
		&i.Merchant.Latitude,
		&i.Merchant.Longitude,
		&i.Merchant.Status,
		&i.Merchant.ApplicationData,
		&i.Merchant.CreatedAt,
		&i.Merchant.UpdatedAt,
		&i.Merchant.Version,
		&i.Merchant.RegionID,
		&i.Merchant.IsOpen,
		&i.Merchant.AutoCloseAt,
		&i.Merchant.DeletedAt,
		&i.Merchant.PendingOwnerBind,
		&i.Merchant.BindCode,
		&i.Merchant.BindCodeExpiresAt,
		&i.Merchant.BossBindCode,
		&i.Merchant.BossBindCodeExpiresAt,
		&i.Tags,
	)
	return i, err
}

const getMerchantsByIDs = `-- name: GetMerchantsByIDs :many
SELECT 
    id,
    name,
    description,
    logo_url,
    address,
    latitude,
    longitude,
    status
FROM merchants
WHERE id = ANY($1::bigint[])
  AND status = 'active'
`

type GetMerchantsByIDsRow struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	Description pgtype.Text    `json:"description"`
	LogoUrl     pgtype.Text    `json:"logo_url"`
	Address     string         `json:"address"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	Status      string         `json:"status"`
}

// 批量获取商户详情
func (q *Queries) GetMerchantsByIDs(ctx context.Context, dollar_1 []int64) ([]GetMerchantsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantsByIDsRow{}
	for rows.Next() {
		var i GetMerchantsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantsWithStatsByIDs = `-- name: GetMerchantsWithStatsByIDs :many
SELECT 
    m.id,
    m.name,
    m.description,
    m.logo_url,
    m.address,
    m.latitude,
    m.longitude,
    m.region_id,
    m.status,
    m.is_open,
    COALESCE(mp.trust_score, 500) AS trust_score,
    COALESCE(
        (SELECT COUNT(*)
         FROM orders o 
         WHERE o.merchant_id = m.id 
           AND o.status IN ('completed')
           AND o.created_at >= NOW() - INTERVAL '30 days'
        ), 0
    )::int AS monthly_orders
FROM merchants m
LEFT JOIN merchant_profiles mp ON mp.merchant_id = m.id
WHERE m.id = ANY($1::bigint[])
  AND m.status = 'active'
`

type GetMerchantsWithStatsByIDsRow struct {
	ID            int64          `json:"id"`
	Name          string         `json:"name"`
	Description   pgtype.Text    `json:"description"`
	LogoUrl       pgtype.Text    `json:"logo_url"`
	Address       string         `json:"address"`
	Latitude      pgtype.Numeric `json:"latitude"`
	Longitude     pgtype.Numeric `json:"longitude"`
	RegionID      int64          `json:"region_id"`
	Status        string         `json:"status"`
	IsOpen        bool           `json:"is_open"`
	TrustScore    int16          `json:"trust_score"`
	MonthlyOrders int32          `json:"monthly_orders"`
}

// 批量获取商户详情及统计数据（用于推荐流展示）
func (q *Queries) GetMerchantsWithStatsByIDs(ctx context.Context, dollar_1 []int64) ([]GetMerchantsWithStatsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantsWithStatsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantsWithStatsByIDsRow{}
	for rows.Next() {
		var i GetMerchantsWithStatsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.RegionID,
			&i.Status,
			&i.IsOpen,
			&i.TrustScore,
			&i.MonthlyOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularMerchants = `-- name: GetPopularMerchants :many

SELECT 
    m.id,
    m.name,
    m.description,
    m.logo_url,
    m.address,
    m.latitude,
    m.longitude,
    COALESCE(COUNT(o.id), 0)::int AS total_orders,
  0::numeric(3,2) AS avg_rating
FROM merchants m
LEFT JOIN orders o ON m.id = o.merchant_id 
  AND o.status IN ('completed')  -- 以已完成订单作为销量口径
WHERE m.status = 'active'
  AND m.is_open = true
GROUP BY m.id
ORDER BY 
    m.is_open DESC,
    total_orders DESC,  -- 销量优先：回头客多的商户排前面
    avg_rating DESC,     -- 评分次之
    earth_distance(ll_to_earth(m.latitude, m.longitude), ll_to_earth($2::float8, $3::float8)) ASC
LIMIT $1
`

type GetPopularMerchantsParams struct {
	Limit   int32   `json:"limit"`
	Column2 float64 `json:"column_2"`
	Column3 float64 `json:"column_3"`
}

type GetPopularMerchantsRow struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	Description pgtype.Text    `json:"description"`
	LogoUrl     pgtype.Text    `json:"logo_url"`
	Address     string         `json:"address"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	TotalOrders int32          `json:"total_orders"`
	AvgRating   pgtype.Numeric `json:"avg_rating"`
}

// ============================================
// 商户推荐查询
// ============================================
// 获取热门商户（基于整体销量和评分）
// 销量 = 外卖 + 堂食 + 预定，高销量意味着回头客多，是最重要的排序因子
func (q *Queries) GetPopularMerchants(ctx context.Context, arg GetPopularMerchantsParams) ([]GetPopularMerchantsRow, error) {
	rows, err := q.db.Query(ctx, getPopularMerchants, arg.Limit, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularMerchantsRow{}
	for rows.Next() {
		var i GetPopularMerchantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.TotalOrders,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMerchantApplication = `-- name: GetUserMerchantApplication :one
SELECT id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images FROM merchant_applications
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserMerchantApplication(ctx context.Context, userID int64) (MerchantApplication, error) {
	row := q.db.QueryRow(ctx, getUserMerchantApplication, userID)
	var i MerchantApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantName,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseImageUrl,
		&i.LegalPersonName,
		&i.LegalPersonIDNumber,
		&i.LegalPersonIDFrontUrl,
		&i.LegalPersonIDBackUrl,
		&i.ContactPhone,
		&i.BusinessAddress,
		&i.BusinessScope,
		&i.Status,
		&i.RejectReason,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.RegionID,
		&i.FoodPermitUrl,
		&i.FoodPermitOcr,
		&i.BusinessLicenseOcr,
		&i.IDCardFrontOcr,
		&i.IDCardBackOcr,
		&i.StorefrontImages,
		&i.EnvironmentImages,
	)
	return i, err
}

const listAllMerchantApplications = `-- name: ListAllMerchantApplications :many
SELECT id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images FROM merchant_applications
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllMerchantApplicationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllMerchantApplications(ctx context.Context, arg ListAllMerchantApplicationsParams) ([]MerchantApplication, error) {
	rows, err := q.db.Query(ctx, listAllMerchantApplications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MerchantApplication{}
	for rows.Next() {
		var i MerchantApplication
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantName,
			&i.BusinessLicenseNumber,
			&i.BusinessLicenseImageUrl,
			&i.LegalPersonName,
			&i.LegalPersonIDNumber,
			&i.LegalPersonIDFrontUrl,
			&i.LegalPersonIDBackUrl,
			&i.ContactPhone,
			&i.BusinessAddress,
			&i.BusinessScope,
			&i.Status,
			&i.RejectReason,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Longitude,
			&i.Latitude,
			&i.RegionID,
			&i.FoodPermitUrl,
			&i.FoodPermitOcr,
			&i.BusinessLicenseOcr,
			&i.IDCardFrontOcr,
			&i.IDCardBackOcr,
			&i.StorefrontImages,
			&i.EnvironmentImages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllMerchants = `-- name: ListAllMerchants :many
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllMerchantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllMerchants(ctx context.Context, arg ListAllMerchantsParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listAllMerchants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantApplications = `-- name: ListMerchantApplications :many
SELECT id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images FROM merchant_applications
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantApplicationsParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListMerchantApplications(ctx context.Context, arg ListMerchantApplicationsParams) ([]MerchantApplication, error) {
	rows, err := q.db.Query(ctx, listMerchantApplications, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MerchantApplication{}
	for rows.Next() {
		var i MerchantApplication
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantName,
			&i.BusinessLicenseNumber,
			&i.BusinessLicenseImageUrl,
			&i.LegalPersonName,
			&i.LegalPersonIDNumber,
			&i.LegalPersonIDFrontUrl,
			&i.LegalPersonIDBackUrl,
			&i.ContactPhone,
			&i.BusinessAddress,
			&i.BusinessScope,
			&i.Status,
			&i.RejectReason,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Longitude,
			&i.Latitude,
			&i.RegionID,
			&i.FoodPermitUrl,
			&i.FoodPermitOcr,
			&i.BusinessLicenseOcr,
			&i.IDCardFrontOcr,
			&i.IDCardBackOcr,
			&i.StorefrontImages,
			&i.EnvironmentImages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantBusinessHours = `-- name: ListMerchantBusinessHours :many
SELECT id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at FROM merchant_business_hours
WHERE merchant_id = $1
  AND special_date IS NULL
ORDER BY day_of_week
`

func (q *Queries) ListMerchantBusinessHours(ctx context.Context, merchantID int64) ([]MerchantBusinessHour, error) {
	rows, err := q.db.Query(ctx, listMerchantBusinessHours, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MerchantBusinessHour{}
	for rows.Next() {
		var i MerchantBusinessHour
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.DayOfWeek,
			&i.OpenTime,
			&i.CloseTime,
			&i.IsClosed,
			&i.SpecialDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantSpecialHours = `-- name: ListMerchantSpecialHours :many
SELECT id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at FROM merchant_business_hours
WHERE merchant_id = $1
  AND special_date IS NOT NULL
ORDER BY special_date
`

func (q *Queries) ListMerchantSpecialHours(ctx context.Context, merchantID int64) ([]MerchantBusinessHour, error) {
	rows, err := q.db.Query(ctx, listMerchantSpecialHours, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MerchantBusinessHour{}
	for rows.Next() {
		var i MerchantBusinessHour
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.DayOfWeek,
			&i.OpenTime,
			&i.CloseTime,
			&i.IsClosed,
			&i.SpecialDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantTags = `-- name: ListMerchantTags :many
SELECT t.id, t.name, t.type, t.sort_order, t.status, t.created_at FROM tags t
INNER JOIN merchant_tags mt ON t.id = mt.tag_id
WHERE mt.merchant_id = $1
ORDER BY t.name
`

func (q *Queries) ListMerchantTags(ctx context.Context, merchantID int64) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listMerchantTags, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.SortOrder,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchants = `-- name: ListMerchants :many
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE status = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantsParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListMerchants(ctx context.Context, arg ListMerchantsParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listMerchants, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantsByOwner = `-- name: ListMerchantsByOwner :many
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE owner_user_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

// 获取用户拥有的所有商户（用于多店铺切换）
func (q *Queries) ListMerchantsByOwner(ctx context.Context, ownerUserID int64) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listMerchantsByOwner, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantsByRegion = `-- name: ListMerchantsByRegion :many

SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE region_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantsByRegionParams struct {
	RegionID int64 `json:"region_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

// ==================== 运营商管理商户 ====================
// 按区域列出商户（供运营商管理使用）
func (q *Queries) ListMerchantsByRegion(ctx context.Context, arg ListMerchantsByRegionParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listMerchantsByRegion, arg.RegionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantsByRegionWithStatus = `-- name: ListMerchantsByRegionWithStatus :many
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE region_id = $1
  AND ($2::varchar IS NULL OR status = $2)
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListMerchantsByRegionWithStatusParams struct {
	RegionID int64  `json:"region_id"`
	Column2  string `json:"column_2"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

// 按区域和状态列出商户
func (q *Queries) ListMerchantsByRegionWithStatus(ctx context.Context, arg ListMerchantsByRegionWithStatusParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listMerchantsByRegionWithStatus,
		arg.RegionID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantsByTag = `-- name: ListMerchantsByTag :many
SELECT m.id, m.owner_user_id, m.name, m.description, m.logo_url, m.phone, m.address, m.latitude, m.longitude, m.status, m.application_data, m.created_at, m.updated_at, m.version, m.region_id, m.is_open, m.auto_close_at, m.deleted_at, m.pending_owner_bind, m.bind_code, m.bind_code_expires_at, m.boss_bind_code, m.boss_bind_code_expires_at FROM merchants m
INNER JOIN merchant_tags mt ON m.id = mt.merchant_id
WHERE mt.tag_id = $1
  AND m.status = 'active'
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantsByTagParams struct {
	TagID  int64 `json:"tag_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMerchantsByTag(ctx context.Context, arg ListMerchantsByTagParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listMerchantsByTag, arg.TagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantsWithTagCount = `-- name: ListMerchantsWithTagCount :many
SELECT 
  m.id, m.owner_user_id, m.name, m.description, m.logo_url, m.phone, m.address, m.latitude, m.longitude, m.status, m.application_data, m.created_at, m.updated_at, m.version, m.region_id, m.is_open, m.auto_close_at, m.deleted_at, m.pending_owner_bind, m.bind_code, m.bind_code_expires_at, m.boss_bind_code, m.boss_bind_code_expires_at,
  COUNT(mt.tag_id) as tag_count
FROM merchants m
LEFT JOIN merchant_tags mt ON m.id = mt.merchant_id
WHERE m.status = $1
GROUP BY m.id
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantsWithTagCountParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListMerchantsWithTagCountRow struct {
	ID                    int64              `json:"id"`
	OwnerUserID           int64              `json:"owner_user_id"`
	Name                  string             `json:"name"`
	Description           pgtype.Text        `json:"description"`
	LogoUrl               pgtype.Text        `json:"logo_url"`
	Phone                 string             `json:"phone"`
	Address               string             `json:"address"`
	Latitude              pgtype.Numeric     `json:"latitude"`
	Longitude             pgtype.Numeric     `json:"longitude"`
	Status                string             `json:"status"`
	ApplicationData       []byte             `json:"application_data"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	Version               int32              `json:"version"`
	RegionID              int64              `json:"region_id"`
	IsOpen                bool               `json:"is_open"`
	AutoCloseAt           pgtype.Timestamptz `json:"auto_close_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	PendingOwnerBind      pgtype.Bool        `json:"pending_owner_bind"`
	BindCode              pgtype.Text        `json:"bind_code"`
	BindCodeExpiresAt     pgtype.Timestamptz `json:"bind_code_expires_at"`
	BossBindCode          pgtype.Text        `json:"boss_bind_code"`
	BossBindCodeExpiresAt pgtype.Timestamptz `json:"boss_bind_code_expires_at"`
	TagCount              int64              `json:"tag_count"`
}

func (q *Queries) ListMerchantsWithTagCount(ctx context.Context, arg ListMerchantsWithTagCountParams) ([]ListMerchantsWithTagCountRow, error) {
	rows, err := q.db.Query(ctx, listMerchantsWithTagCount, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantsWithTagCountRow{}
	for rows.Next() {
		var i ListMerchantsWithTagCountRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
			&i.TagCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenMerchants = `-- name: ListOpenMerchants :many
SELECT id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at FROM merchants
WHERE status = 'active'
  AND is_open = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOpenMerchantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// 获取营业中的商户列表
func (q *Queries) ListOpenMerchants(ctx context.Context, arg ListOpenMerchantsParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listOpenMerchants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Merchant{}
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMerchantTag = `-- name: RemoveMerchantTag :exec
DELETE FROM merchant_tags
WHERE merchant_id = $1 AND tag_id = $2
`

type RemoveMerchantTagParams struct {
	MerchantID int64 `json:"merchant_id"`
	TagID      int64 `json:"tag_id"`
}

func (q *Queries) RemoveMerchantTag(ctx context.Context, arg RemoveMerchantTagParams) error {
	_, err := q.db.Exec(ctx, removeMerchantTag, arg.MerchantID, arg.TagID)
	return err
}

const searchMerchants = `-- name: SearchMerchants :many
SELECT m.id, m.owner_user_id, m.name, m.description, m.logo_url, m.phone, m.address, m.latitude, m.longitude, m.status, m.application_data, m.created_at, m.updated_at, m.version, m.region_id, m.is_open, m.auto_close_at, m.deleted_at, m.pending_owner_bind, m.bind_code, m.bind_code_expires_at, m.boss_bind_code, m.boss_bind_code_expires_at, COALESCE(mp.total_orders, 0)::int AS total_orders FROM merchants m
  LEFT JOIN merchant_profiles mp ON m.id = mp.merchant_id
WHERE m.status = 'active'
  AND m.deleted_at IS NULL
  AND (
    $3::text IS NULL
    OR m.name ILIKE '%' || $3 || '%'
  )
ORDER BY
    m.is_open DESC,
    COALESCE(mp.total_orders, 0) DESC,
    earth_distance(ll_to_earth(m.latitude::float8, m.longitude::float8), ll_to_earth($4::float8, $5::float8)) ASC
LIMIT $2
OFFSET $1
`

type SearchMerchantsParams struct {
	Offset  int32   `json:"offset"`
	Limit   int32   `json:"limit"`
	Column3 string  `json:"column_3"`
	Column4 float64 `json:"column_4"`
	Column5 float64 `json:"column_5"`
}

type SearchMerchantsRow struct {
	ID                    int64              `json:"id"`
	OwnerUserID           int64              `json:"owner_user_id"`
	Name                  string             `json:"name"`
	Description           pgtype.Text        `json:"description"`
	LogoUrl               pgtype.Text        `json:"logo_url"`
	Phone                 string             `json:"phone"`
	Address               string             `json:"address"`
	Latitude              pgtype.Numeric     `json:"latitude"`
	Longitude             pgtype.Numeric     `json:"longitude"`
	Status                string             `json:"status"`
	ApplicationData       []byte             `json:"application_data"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	Version               int32              `json:"version"`
	RegionID              int64              `json:"region_id"`
	IsOpen                bool               `json:"is_open"`
	AutoCloseAt           pgtype.Timestamptz `json:"auto_close_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	PendingOwnerBind      pgtype.Bool        `json:"pending_owner_bind"`
	BindCode              pgtype.Text        `json:"bind_code"`
	BindCodeExpiresAt     pgtype.Timestamptz `json:"bind_code_expires_at"`
	BossBindCode          pgtype.Text        `json:"boss_bind_code"`
	BossBindCodeExpiresAt pgtype.Timestamptz `json:"boss_bind_code_expires_at"`
	TotalOrders           int32              `json:"total_orders"`
}

func (q *Queries) SearchMerchants(ctx context.Context, arg SearchMerchantsParams) ([]SearchMerchantsRow, error) {
	rows, err := q.db.Query(ctx, searchMerchants,
		arg.Offset,
		arg.Limit,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMerchantsRow{}
	for rows.Next() {
		var i SearchMerchantsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Phone,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.ApplicationData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.RegionID,
			&i.IsOpen,
			&i.AutoCloseAt,
			&i.DeletedAt,
			&i.PendingOwnerBind,
			&i.BindCode,
			&i.BindCodeExpiresAt,
			&i.BossBindCode,
			&i.BossBindCodeExpiresAt,
			&i.TotalOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBusinessHour = `-- name: UpdateBusinessHour :one
UPDATE merchant_business_hours
SET
  open_time = $2,
  close_time = $3,
  is_closed = $4,
  updated_at = now()
WHERE id = $1
RETURNING id, merchant_id, day_of_week, open_time, close_time, is_closed, special_date, created_at, updated_at
`

type UpdateBusinessHourParams struct {
	ID        int64       `json:"id"`
	OpenTime  pgtype.Time `json:"open_time"`
	CloseTime pgtype.Time `json:"close_time"`
	IsClosed  bool        `json:"is_closed"`
}

func (q *Queries) UpdateBusinessHour(ctx context.Context, arg UpdateBusinessHourParams) (MerchantBusinessHour, error) {
	row := q.db.QueryRow(ctx, updateBusinessHour,
		arg.ID,
		arg.OpenTime,
		arg.CloseTime,
		arg.IsClosed,
	)
	var i MerchantBusinessHour
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsClosed,
		&i.SpecialDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMerchant = `-- name: UpdateMerchant :one
UPDATE merchants
SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  logo_url = COALESCE($3, logo_url),
  phone = COALESCE($4, phone),
  address = COALESCE($5, address),
  latitude = COALESCE($6, latitude),
  longitude = COALESCE($7, longitude),
  region_id = COALESCE($8, region_id),
  version = version + 1,
  updated_at = now()
WHERE id = $9
  AND version = $10
  AND deleted_at IS NULL
RETURNING id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at
`

type UpdateMerchantParams struct {
	Name        pgtype.Text    `json:"name"`
	Description pgtype.Text    `json:"description"`
	LogoUrl     pgtype.Text    `json:"logo_url"`
	Phone       pgtype.Text    `json:"phone"`
	Address     pgtype.Text    `json:"address"`
	Latitude    pgtype.Numeric `json:"latitude"`
	Longitude   pgtype.Numeric `json:"longitude"`
	RegionID    pgtype.Int8    `json:"region_id"`
	ID          int64          `json:"id"`
	Version     int32          `json:"version"`
}

// ✅ P1-2: 使用乐观锁(version)防止并发更新丢失
func (q *Queries) UpdateMerchant(ctx context.Context, arg UpdateMerchantParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, updateMerchant,
		arg.Name,
		arg.Description,
		arg.LogoUrl,
		arg.Phone,
		arg.Address,
		arg.Latitude,
		arg.Longitude,
		arg.RegionID,
		arg.ID,
		arg.Version,
	)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const updateMerchantApplicationStatus = `-- name: UpdateMerchantApplicationStatus :one
UPDATE merchant_applications
SET
  status = $2,
  reject_reason = $3,
  reviewed_by = $4,
  reviewed_at = $5,
  updated_at = now()
WHERE id = $1
RETURNING id, user_id, merchant_name, business_license_number, business_license_image_url, legal_person_name, legal_person_id_number, legal_person_id_front_url, legal_person_id_back_url, contact_phone, business_address, business_scope, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, longitude, latitude, region_id, food_permit_url, food_permit_ocr, business_license_ocr, id_card_front_ocr, id_card_back_ocr, storefront_images, environment_images
`

type UpdateMerchantApplicationStatusParams struct {
	ID           int64              `json:"id"`
	Status       string             `json:"status"`
	RejectReason pgtype.Text        `json:"reject_reason"`
	ReviewedBy   pgtype.Int8        `json:"reviewed_by"`
	ReviewedAt   pgtype.Timestamptz `json:"reviewed_at"`
}

func (q *Queries) UpdateMerchantApplicationStatus(ctx context.Context, arg UpdateMerchantApplicationStatusParams) (MerchantApplication, error) {
	row := q.db.QueryRow(ctx, updateMerchantApplicationStatus,
		arg.ID,
		arg.Status,
		arg.RejectReason,
		arg.ReviewedBy,
		arg.ReviewedAt,
	)
	var i MerchantApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantName,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseImageUrl,
		&i.LegalPersonName,
		&i.LegalPersonIDNumber,
		&i.LegalPersonIDFrontUrl,
		&i.LegalPersonIDBackUrl,
		&i.ContactPhone,
		&i.BusinessAddress,
		&i.BusinessScope,
		&i.Status,
		&i.RejectReason,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.RegionID,
		&i.FoodPermitUrl,
		&i.FoodPermitOcr,
		&i.BusinessLicenseOcr,
		&i.IDCardFrontOcr,
		&i.IDCardBackOcr,
		&i.StorefrontImages,
		&i.EnvironmentImages,
	)
	return i, err
}

const updateMerchantBindCode = `-- name: UpdateMerchantBindCode :one
UPDATE merchants
SET
  bind_code = $2,
  bind_code_expires_at = $3,
  updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at
`

type UpdateMerchantBindCodeParams struct {
	ID                int64              `json:"id"`
	BindCode          pgtype.Text        `json:"bind_code"`
	BindCodeExpiresAt pgtype.Timestamptz `json:"bind_code_expires_at"`
}

// 更新商户邀请码
func (q *Queries) UpdateMerchantBindCode(ctx context.Context, arg UpdateMerchantBindCodeParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, updateMerchantBindCode, arg.ID, arg.BindCode, arg.BindCodeExpiresAt)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const updateMerchantBossBindCode = `-- name: UpdateMerchantBossBindCode :one
UPDATE merchants
SET boss_bind_code = $2, boss_bind_code_expires_at = $3, updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at
`

type UpdateMerchantBossBindCodeParams struct {
	ID                    int64              `json:"id"`
	BossBindCode          pgtype.Text        `json:"boss_bind_code"`
	BossBindCodeExpiresAt pgtype.Timestamptz `json:"boss_bind_code_expires_at"`
}

// 更新 Boss 认领码
func (q *Queries) UpdateMerchantBossBindCode(ctx context.Context, arg UpdateMerchantBossBindCodeParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, updateMerchantBossBindCode, arg.ID, arg.BossBindCode, arg.BossBindCodeExpiresAt)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const updateMerchantIsOpen = `-- name: UpdateMerchantIsOpen :one

UPDATE merchants
SET
  is_open = $2,
  auto_close_at = $3,
  updated_at = now()
WHERE id = $1
RETURNING id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at
`

type UpdateMerchantIsOpenParams struct {
	ID          int64              `json:"id"`
	IsOpen      bool               `json:"is_open"`
	AutoCloseAt pgtype.Timestamptz `json:"auto_close_at"`
}

// ==================== 商户营业状态管理 ====================
// 更新商户营业状态（手动开店/打烊）
func (q *Queries) UpdateMerchantIsOpen(ctx context.Context, arg UpdateMerchantIsOpenParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, updateMerchantIsOpen, arg.ID, arg.IsOpen, arg.AutoCloseAt)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}

const updateMerchantStatus = `-- name: UpdateMerchantStatus :one
UPDATE merchants
SET
  status = $2,
  updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, owner_user_id, name, description, logo_url, phone, address, latitude, longitude, status, application_data, created_at, updated_at, version, region_id, is_open, auto_close_at, deleted_at, pending_owner_bind, bind_code, bind_code_expires_at, boss_bind_code, boss_bind_code_expires_at
`

type UpdateMerchantStatusParams struct {
	ID     int64  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateMerchantStatus(ctx context.Context, arg UpdateMerchantStatusParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, updateMerchantStatus, arg.ID, arg.Status)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Description,
		&i.LogoUrl,
		&i.Phone,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.ApplicationData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.RegionID,
		&i.IsOpen,
		&i.AutoCloseAt,
		&i.DeletedAt,
		&i.PendingOwnerBind,
		&i.BindCode,
		&i.BindCodeExpiresAt,
		&i.BossBindCode,
		&i.BossBindCodeExpiresAt,
	)
	return i, err
}
