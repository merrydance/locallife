// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: combined_payment.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCombinedPaymentSubOrders = `-- name: CountCombinedPaymentSubOrders :one
SELECT COUNT(*)::int FROM combined_payment_sub_orders
WHERE combined_payment_id = $1
`

func (q *Queries) CountCombinedPaymentSubOrders(ctx context.Context, combinedPaymentID int64) (int32, error) {
	row := q.db.QueryRow(ctx, countCombinedPaymentSubOrders, combinedPaymentID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createCombinedPaymentOrder = `-- name: CreateCombinedPaymentOrder :one

INSERT INTO combined_payment_orders (
    user_id,
    combine_out_trade_no,
    total_amount,
    status,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at
`

type CreateCombinedPaymentOrderParams struct {
	UserID            int64              `json:"user_id"`
	CombineOutTradeNo string             `json:"combine_out_trade_no"`
	TotalAmount       int64              `json:"total_amount"`
	Status            string             `json:"status"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
}

// ==================== 合单支付主表查询 ====================
func (q *Queries) CreateCombinedPaymentOrder(ctx context.Context, arg CreateCombinedPaymentOrderParams) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, createCombinedPaymentOrder,
		arg.UserID,
		arg.CombineOutTradeNo,
		arg.TotalAmount,
		arg.Status,
		arg.ExpiresAt,
	)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createCombinedPaymentSubOrder = `-- name: CreateCombinedPaymentSubOrder :one

INSERT INTO combined_payment_sub_orders (
    combined_payment_id,
    order_id,
    merchant_id,
    sub_mchid,
    amount,
    out_trade_no,
    description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, combined_payment_id, order_id, merchant_id, sub_mchid, amount, out_trade_no, description, profit_sharing_status, created_at
`

type CreateCombinedPaymentSubOrderParams struct {
	CombinedPaymentID int64  `json:"combined_payment_id"`
	OrderID           int64  `json:"order_id"`
	MerchantID        int64  `json:"merchant_id"`
	SubMchid          string `json:"sub_mchid"`
	Amount            int64  `json:"amount"`
	OutTradeNo        string `json:"out_trade_no"`
	Description       string `json:"description"`
}

// ==================== 合单支付子订单查询 ====================
func (q *Queries) CreateCombinedPaymentSubOrder(ctx context.Context, arg CreateCombinedPaymentSubOrderParams) (CombinedPaymentSubOrder, error) {
	row := q.db.QueryRow(ctx, createCombinedPaymentSubOrder,
		arg.CombinedPaymentID,
		arg.OrderID,
		arg.MerchantID,
		arg.SubMchid,
		arg.Amount,
		arg.OutTradeNo,
		arg.Description,
	)
	var i CombinedPaymentSubOrder
	err := row.Scan(
		&i.ID,
		&i.CombinedPaymentID,
		&i.OrderID,
		&i.MerchantID,
		&i.SubMchid,
		&i.Amount,
		&i.OutTradeNo,
		&i.Description,
		&i.ProfitSharingStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getCombinedPaymentOrder = `-- name: GetCombinedPaymentOrder :one
SELECT id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at FROM combined_payment_orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCombinedPaymentOrder(ctx context.Context, id int64) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, getCombinedPaymentOrder, id)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getCombinedPaymentOrderByOutTradeNo = `-- name: GetCombinedPaymentOrderByOutTradeNo :one
SELECT id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at FROM combined_payment_orders
WHERE combine_out_trade_no = $1 LIMIT 1
`

func (q *Queries) GetCombinedPaymentOrderByOutTradeNo(ctx context.Context, combineOutTradeNo string) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, getCombinedPaymentOrderByOutTradeNo, combineOutTradeNo)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getCombinedPaymentOrderForUpdate = `-- name: GetCombinedPaymentOrderForUpdate :one
SELECT id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at FROM combined_payment_orders
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetCombinedPaymentOrderForUpdate(ctx context.Context, id int64) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, getCombinedPaymentOrderForUpdate, id)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getCombinedPaymentOrderWithSubOrders = `-- name: GetCombinedPaymentOrderWithSubOrders :one

SELECT 
    c.id, c.user_id, c.combine_out_trade_no, c.total_amount, c.prepay_id, c.transaction_id, c.status, c.paid_at, c.created_at, c.expires_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', s.id,
                'order_id', s.order_id,
                'merchant_id', s.merchant_id,
                'sub_mchid', s.sub_mchid,
                'amount', s.amount,
                'out_trade_no', s.out_trade_no,
                'description', s.description,
                'profit_sharing_status', s.profit_sharing_status,
                'merchant_name', m.name,
                'merchant_logo', m.logo_url,
                'order_no', o.order_no
            ) ORDER BY s.created_at
        ) FILTER (WHERE s.id IS NOT NULL), '[]'
    )::json AS sub_orders
FROM combined_payment_orders c
LEFT JOIN combined_payment_sub_orders s ON s.combined_payment_id = c.id
LEFT JOIN merchants m ON m.id = s.merchant_id
LEFT JOIN orders o ON o.id = s.order_id
WHERE c.id = $1
GROUP BY c.id
`

type GetCombinedPaymentOrderWithSubOrdersRow struct {
	ID                int64              `json:"id"`
	UserID            int64              `json:"user_id"`
	CombineOutTradeNo string             `json:"combine_out_trade_no"`
	TotalAmount       int64              `json:"total_amount"`
	PrepayID          pgtype.Text        `json:"prepay_id"`
	TransactionID     pgtype.Text        `json:"transaction_id"`
	Status            string             `json:"status"`
	PaidAt            pgtype.Timestamptz `json:"paid_at"`
	CreatedAt         time.Time          `json:"created_at"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	SubOrders         []byte             `json:"sub_orders"`
}

// ==================== 合单支付完整信息查询 ====================
// 获取合单支付完整信息（主单+所有子单）
func (q *Queries) GetCombinedPaymentOrderWithSubOrders(ctx context.Context, id int64) (GetCombinedPaymentOrderWithSubOrdersRow, error) {
	row := q.db.QueryRow(ctx, getCombinedPaymentOrderWithSubOrders, id)
	var i GetCombinedPaymentOrderWithSubOrdersRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.SubOrders,
	)
	return i, err
}

const getCombinedPaymentSubOrder = `-- name: GetCombinedPaymentSubOrder :one
SELECT id, combined_payment_id, order_id, merchant_id, sub_mchid, amount, out_trade_no, description, profit_sharing_status, created_at FROM combined_payment_sub_orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCombinedPaymentSubOrder(ctx context.Context, id int64) (CombinedPaymentSubOrder, error) {
	row := q.db.QueryRow(ctx, getCombinedPaymentSubOrder, id)
	var i CombinedPaymentSubOrder
	err := row.Scan(
		&i.ID,
		&i.CombinedPaymentID,
		&i.OrderID,
		&i.MerchantID,
		&i.SubMchid,
		&i.Amount,
		&i.OutTradeNo,
		&i.Description,
		&i.ProfitSharingStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getCombinedPaymentSubOrderByOutTradeNo = `-- name: GetCombinedPaymentSubOrderByOutTradeNo :one
SELECT id, combined_payment_id, order_id, merchant_id, sub_mchid, amount, out_trade_no, description, profit_sharing_status, created_at FROM combined_payment_sub_orders
WHERE out_trade_no = $1 LIMIT 1
`

func (q *Queries) GetCombinedPaymentSubOrderByOutTradeNo(ctx context.Context, outTradeNo string) (CombinedPaymentSubOrder, error) {
	row := q.db.QueryRow(ctx, getCombinedPaymentSubOrderByOutTradeNo, outTradeNo)
	var i CombinedPaymentSubOrder
	err := row.Scan(
		&i.ID,
		&i.CombinedPaymentID,
		&i.OrderID,
		&i.MerchantID,
		&i.SubMchid,
		&i.Amount,
		&i.OutTradeNo,
		&i.Description,
		&i.ProfitSharingStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getCombinedPaymentSubOrdersByOrder = `-- name: GetCombinedPaymentSubOrdersByOrder :many
SELECT id, combined_payment_id, order_id, merchant_id, sub_mchid, amount, out_trade_no, description, profit_sharing_status, created_at FROM combined_payment_sub_orders
WHERE order_id = $1
ORDER BY created_at DESC
`

// 根据订单ID查询其所有合单子单（一个订单可能参与多次合单支付尝试）
func (q *Queries) GetCombinedPaymentSubOrdersByOrder(ctx context.Context, orderID int64) ([]CombinedPaymentSubOrder, error) {
	rows, err := q.db.Query(ctx, getCombinedPaymentSubOrdersByOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CombinedPaymentSubOrder{}
	for rows.Next() {
		var i CombinedPaymentSubOrder
		if err := rows.Scan(
			&i.ID,
			&i.CombinedPaymentID,
			&i.OrderID,
			&i.MerchantID,
			&i.SubMchid,
			&i.Amount,
			&i.OutTradeNo,
			&i.Description,
			&i.ProfitSharingStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCombinedPaymentSubOrders = `-- name: ListCombinedPaymentSubOrders :many
SELECT id, combined_payment_id, order_id, merchant_id, sub_mchid, amount, out_trade_no, description, profit_sharing_status, created_at FROM combined_payment_sub_orders
WHERE combined_payment_id = $1
ORDER BY created_at
`

func (q *Queries) ListCombinedPaymentSubOrders(ctx context.Context, combinedPaymentID int64) ([]CombinedPaymentSubOrder, error) {
	rows, err := q.db.Query(ctx, listCombinedPaymentSubOrders, combinedPaymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CombinedPaymentSubOrder{}
	for rows.Next() {
		var i CombinedPaymentSubOrder
		if err := rows.Scan(
			&i.ID,
			&i.CombinedPaymentID,
			&i.OrderID,
			&i.MerchantID,
			&i.SubMchid,
			&i.Amount,
			&i.OutTradeNo,
			&i.Description,
			&i.ProfitSharingStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCombinedPaymentSubOrdersWithMerchant = `-- name: ListCombinedPaymentSubOrdersWithMerchant :many
SELECT 
    s.id, s.combined_payment_id, s.order_id, s.merchant_id, s.sub_mchid, s.amount, s.out_trade_no, s.description, s.profit_sharing_status, s.created_at,
    m.name as merchant_name,
    m.logo_url as merchant_logo,
    o.order_no
FROM combined_payment_sub_orders s
JOIN merchants m ON m.id = s.merchant_id
JOIN orders o ON o.id = s.order_id
WHERE s.combined_payment_id = $1
ORDER BY s.created_at
`

type ListCombinedPaymentSubOrdersWithMerchantRow struct {
	ID                  int64       `json:"id"`
	CombinedPaymentID   int64       `json:"combined_payment_id"`
	OrderID             int64       `json:"order_id"`
	MerchantID          int64       `json:"merchant_id"`
	SubMchid            string      `json:"sub_mchid"`
	Amount              int64       `json:"amount"`
	OutTradeNo          string      `json:"out_trade_no"`
	Description         string      `json:"description"`
	ProfitSharingStatus string      `json:"profit_sharing_status"`
	CreatedAt           time.Time   `json:"created_at"`
	MerchantName        string      `json:"merchant_name"`
	MerchantLogo        pgtype.Text `json:"merchant_logo"`
	OrderNo             string      `json:"order_no"`
}

func (q *Queries) ListCombinedPaymentSubOrdersWithMerchant(ctx context.Context, combinedPaymentID int64) ([]ListCombinedPaymentSubOrdersWithMerchantRow, error) {
	rows, err := q.db.Query(ctx, listCombinedPaymentSubOrdersWithMerchant, combinedPaymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCombinedPaymentSubOrdersWithMerchantRow{}
	for rows.Next() {
		var i ListCombinedPaymentSubOrdersWithMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.CombinedPaymentID,
			&i.OrderID,
			&i.MerchantID,
			&i.SubMchid,
			&i.Amount,
			&i.OutTradeNo,
			&i.Description,
			&i.ProfitSharingStatus,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.OrderNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingCombinedPaymentOrders = `-- name: ListPendingCombinedPaymentOrders :many
SELECT id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at FROM combined_payment_orders
WHERE status = 'pending'
  AND expires_at < now()
ORDER BY created_at
LIMIT $1
`

// 查询待支付且已过期的合单（用于定时关闭）
func (q *Queries) ListPendingCombinedPaymentOrders(ctx context.Context, limit int32) ([]CombinedPaymentOrder, error) {
	rows, err := q.db.Query(ctx, listPendingCombinedPaymentOrders, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CombinedPaymentOrder{}
	for rows.Next() {
		var i CombinedPaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CombineOutTradeNo,
			&i.TotalAmount,
			&i.PrepayID,
			&i.TransactionID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCombinedPaymentOrders = `-- name: ListUserCombinedPaymentOrders :many
SELECT id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at FROM combined_payment_orders
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserCombinedPaymentOrdersParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserCombinedPaymentOrders(ctx context.Context, arg ListUserCombinedPaymentOrdersParams) ([]CombinedPaymentOrder, error) {
	rows, err := q.db.Query(ctx, listUserCombinedPaymentOrders, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CombinedPaymentOrder{}
	for rows.Next() {
		var i CombinedPaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CombineOutTradeNo,
			&i.TotalAmount,
			&i.PrepayID,
			&i.TransactionID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCombinedPaymentOrderPrepay = `-- name: UpdateCombinedPaymentOrderPrepay :one
UPDATE combined_payment_orders
SET prepay_id = $2
WHERE id = $1
RETURNING id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at
`

type UpdateCombinedPaymentOrderPrepayParams struct {
	ID       int64       `json:"id"`
	PrepayID pgtype.Text `json:"prepay_id"`
}

func (q *Queries) UpdateCombinedPaymentOrderPrepay(ctx context.Context, arg UpdateCombinedPaymentOrderPrepayParams) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, updateCombinedPaymentOrderPrepay, arg.ID, arg.PrepayID)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateCombinedPaymentOrderToClosed = `-- name: UpdateCombinedPaymentOrderToClosed :one
UPDATE combined_payment_orders
SET status = 'closed'
WHERE id = $1 AND status = 'pending'
RETURNING id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at
`

func (q *Queries) UpdateCombinedPaymentOrderToClosed(ctx context.Context, id int64) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, updateCombinedPaymentOrderToClosed, id)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateCombinedPaymentOrderToFailed = `-- name: UpdateCombinedPaymentOrderToFailed :one
UPDATE combined_payment_orders
SET status = 'failed'
WHERE id = $1 AND status = 'pending'
RETURNING id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at
`

func (q *Queries) UpdateCombinedPaymentOrderToFailed(ctx context.Context, id int64) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, updateCombinedPaymentOrderToFailed, id)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateCombinedPaymentOrderToPaid = `-- name: UpdateCombinedPaymentOrderToPaid :one
UPDATE combined_payment_orders
SET 
    status = 'paid',
    transaction_id = $2,
    paid_at = now()
WHERE id = $1 AND status = 'pending'
RETURNING id, user_id, combine_out_trade_no, total_amount, prepay_id, transaction_id, status, paid_at, created_at, expires_at
`

type UpdateCombinedPaymentOrderToPaidParams struct {
	ID            int64       `json:"id"`
	TransactionID pgtype.Text `json:"transaction_id"`
}

func (q *Queries) UpdateCombinedPaymentOrderToPaid(ctx context.Context, arg UpdateCombinedPaymentOrderToPaidParams) (CombinedPaymentOrder, error) {
	row := q.db.QueryRow(ctx, updateCombinedPaymentOrderToPaid, arg.ID, arg.TransactionID)
	var i CombinedPaymentOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CombineOutTradeNo,
		&i.TotalAmount,
		&i.PrepayID,
		&i.TransactionID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateSubOrderProfitSharingStatus = `-- name: UpdateSubOrderProfitSharingStatus :one
UPDATE combined_payment_sub_orders
SET profit_sharing_status = $2
WHERE id = $1
RETURNING id, combined_payment_id, order_id, merchant_id, sub_mchid, amount, out_trade_no, description, profit_sharing_status, created_at
`

type UpdateSubOrderProfitSharingStatusParams struct {
	ID                  int64  `json:"id"`
	ProfitSharingStatus string `json:"profit_sharing_status"`
}

func (q *Queries) UpdateSubOrderProfitSharingStatus(ctx context.Context, arg UpdateSubOrderProfitSharingStatusParams) (CombinedPaymentSubOrder, error) {
	row := q.db.QueryRow(ctx, updateSubOrderProfitSharingStatus, arg.ID, arg.ProfitSharingStatus)
	var i CombinedPaymentSubOrder
	err := row.Scan(
		&i.ID,
		&i.CombinedPaymentID,
		&i.OrderID,
		&i.MerchantID,
		&i.SubMchid,
		&i.Amount,
		&i.OutTradeNo,
		&i.Description,
		&i.ProfitSharingStatus,
		&i.CreatedAt,
	)
	return i, err
}
