// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reservation_item.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countReservationItems = `-- name: CountReservationItems :one
SELECT COUNT(*) FROM reservation_items
WHERE reservation_id = $1
`

func (q *Queries) CountReservationItems(ctx context.Context, reservationID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationItems, reservationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReservationItem = `-- name: CreateReservationItem :one
INSERT INTO reservation_items (
    reservation_id,
    dish_id,
    combo_id,
    quantity,
    unit_price,
    total_price
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, reservation_id, dish_id, combo_id, quantity, unit_price, total_price, created_at
`

type CreateReservationItemParams struct {
	ReservationID int64       `json:"reservation_id"`
	DishID        pgtype.Int8 `json:"dish_id"`
	ComboID       pgtype.Int8 `json:"combo_id"`
	Quantity      int16       `json:"quantity"`
	UnitPrice     int64       `json:"unit_price"`
	TotalPrice    int64       `json:"total_price"`
}

func (q *Queries) CreateReservationItem(ctx context.Context, arg CreateReservationItemParams) (ReservationItem, error) {
	row := q.db.QueryRow(ctx, createReservationItem,
		arg.ReservationID,
		arg.DishID,
		arg.ComboID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i ReservationItem
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.DishID,
		&i.ComboID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.CreatedAt,
	)
	return i, err
}

const deleteReservationItems = `-- name: DeleteReservationItems :exec
DELETE FROM reservation_items
WHERE reservation_id = $1
`

func (q *Queries) DeleteReservationItems(ctx context.Context, reservationID int64) error {
	_, err := q.db.Exec(ctx, deleteReservationItems, reservationID)
	return err
}

const getReservationItemsByReservation = `-- name: GetReservationItemsByReservation :many
SELECT id, reservation_id, dish_id, combo_id, quantity, unit_price, total_price, created_at FROM reservation_items
WHERE reservation_id = $1
ORDER BY id
`

func (q *Queries) GetReservationItemsByReservation(ctx context.Context, reservationID int64) ([]ReservationItem, error) {
	rows, err := q.db.Query(ctx, getReservationItemsByReservation, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReservationItem{}
	for rows.Next() {
		var i ReservationItem
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.DishID,
			&i.ComboID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationItems = `-- name: ListReservationItems :many
SELECT 
    ri.id, ri.reservation_id, ri.dish_id, ri.combo_id, ri.quantity, ri.unit_price, ri.total_price, ri.created_at,
    d.name as dish_name,
    d.image_url as dish_image_url,
    cs.name as combo_name,
    cs.image_url as combo_image_url
FROM reservation_items ri
LEFT JOIN dishes d ON ri.dish_id = d.id
LEFT JOIN combo_sets cs ON ri.combo_id = cs.id
WHERE ri.reservation_id = $1
ORDER BY ri.id
`

type ListReservationItemsRow struct {
	ID            int64       `json:"id"`
	ReservationID int64       `json:"reservation_id"`
	DishID        pgtype.Int8 `json:"dish_id"`
	ComboID       pgtype.Int8 `json:"combo_id"`
	Quantity      int16       `json:"quantity"`
	UnitPrice     int64       `json:"unit_price"`
	TotalPrice    int64       `json:"total_price"`
	CreatedAt     time.Time   `json:"created_at"`
	DishName      pgtype.Text `json:"dish_name"`
	DishImageUrl  pgtype.Text `json:"dish_image_url"`
	ComboName     pgtype.Text `json:"combo_name"`
	ComboImageUrl pgtype.Text `json:"combo_image_url"`
}

func (q *Queries) ListReservationItems(ctx context.Context, reservationID int64) ([]ListReservationItemsRow, error) {
	rows, err := q.db.Query(ctx, listReservationItems, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationItemsRow{}
	for rows.Next() {
		var i ListReservationItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.DishID,
			&i.ComboID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.DishName,
			&i.DishImageUrl,
			&i.ComboName,
			&i.ComboImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumReservationItemsTotal = `-- name: SumReservationItemsTotal :one
SELECT COALESCE(SUM(total_price), 0)::bigint as total
FROM reservation_items
WHERE reservation_id = $1
`

func (q *Queries) SumReservationItemsTotal(ctx context.Context, reservationID int64) (int64, error) {
	row := q.db.QueryRow(ctx, sumReservationItemsTotal, reservationID)
	var total int64
	err := row.Scan(&total)
	return total, err
}
