// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_order.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPaymentOrder = `-- name: CreatePaymentOrder :one
INSERT INTO payment_orders (
    order_id,
    reservation_id,
    user_id,
    payment_type,
    business_type,
    amount,
    out_trade_no,
    expires_at,
    attach
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id
`

type CreatePaymentOrderParams struct {
	OrderID       pgtype.Int8        `json:"order_id"`
	ReservationID pgtype.Int8        `json:"reservation_id"`
	UserID        int64              `json:"user_id"`
	PaymentType   string             `json:"payment_type"`
	BusinessType  string             `json:"business_type"`
	Amount        int64              `json:"amount"`
	OutTradeNo    string             `json:"out_trade_no"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
	Attach        pgtype.Text        `json:"attach"`
}

func (q *Queries) CreatePaymentOrder(ctx context.Context, arg CreatePaymentOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, createPaymentOrder,
		arg.OrderID,
		arg.ReservationID,
		arg.UserID,
		arg.PaymentType,
		arg.BusinessType,
		arg.Amount,
		arg.OutTradeNo,
		arg.ExpiresAt,
		arg.Attach,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getLatestPaymentOrderByOrder = `-- name: GetLatestPaymentOrderByOrder :one
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE order_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestPaymentOrderByOrder(ctx context.Context, orderID pgtype.Int8) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getLatestPaymentOrderByOrder, orderID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getLatestPaymentOrderByReservation = `-- name: GetLatestPaymentOrderByReservation :one
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE reservation_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestPaymentOrderByReservation(ctx context.Context, reservationID pgtype.Int8) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getLatestPaymentOrderByReservation, reservationID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getPaymentOrder = `-- name: GetPaymentOrder :one
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPaymentOrder(ctx context.Context, id int64) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getPaymentOrder, id)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getPaymentOrderByOutTradeNo = `-- name: GetPaymentOrderByOutTradeNo :one
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE out_trade_no = $1 LIMIT 1
`

func (q *Queries) GetPaymentOrderByOutTradeNo(ctx context.Context, outTradeNo string) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getPaymentOrderByOutTradeNo, outTradeNo)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getPaymentOrderByTransactionId = `-- name: GetPaymentOrderByTransactionId :one
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE transaction_id = $1 LIMIT 1
`

func (q *Queries) GetPaymentOrderByTransactionId(ctx context.Context, transactionID pgtype.Text) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getPaymentOrderByTransactionId, transactionID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getPaymentOrderForUpdate = `-- name: GetPaymentOrderForUpdate :one
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetPaymentOrderForUpdate(ctx context.Context, id int64) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getPaymentOrderForUpdate, id)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const getPaymentOrdersByOrder = `-- name: GetPaymentOrdersByOrder :many
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE order_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPaymentOrdersByOrder(ctx context.Context, orderID pgtype.Int8) ([]PaymentOrder, error) {
	rows, err := q.db.Query(ctx, getPaymentOrdersByOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrder{}
	for rows.Next() {
		var i PaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ReservationID,
			&i.UserID,
			&i.PaymentType,
			&i.BusinessType,
			&i.Amount,
			&i.OutTradeNo,
			&i.TransactionID,
			&i.PrepayID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attach,
			&i.CombinedPaymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentOrdersByReservation = `-- name: GetPaymentOrdersByReservation :many
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE reservation_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPaymentOrdersByReservation(ctx context.Context, reservationID pgtype.Int8) ([]PaymentOrder, error) {
	rows, err := q.db.Query(ctx, getPaymentOrdersByReservation, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrder{}
	for rows.Next() {
		var i PaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ReservationID,
			&i.UserID,
			&i.PaymentType,
			&i.BusinessType,
			&i.Amount,
			&i.OutTradeNo,
			&i.TransactionID,
			&i.PrepayID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attach,
			&i.CombinedPaymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiredPaymentOrders = `-- name: ListExpiredPaymentOrders :many
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE status = 'pending' AND expires_at < now()
ORDER BY created_at
LIMIT $1
`

func (q *Queries) ListExpiredPaymentOrders(ctx context.Context, limit int32) ([]PaymentOrder, error) {
	rows, err := q.db.Query(ctx, listExpiredPaymentOrders, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrder{}
	for rows.Next() {
		var i PaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ReservationID,
			&i.UserID,
			&i.PaymentType,
			&i.BusinessType,
			&i.Amount,
			&i.OutTradeNo,
			&i.TransactionID,
			&i.PrepayID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attach,
			&i.CombinedPaymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentOrdersByUser = `-- name: ListPaymentOrdersByUser :many
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentOrdersByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPaymentOrdersByUser(ctx context.Context, arg ListPaymentOrdersByUserParams) ([]PaymentOrder, error) {
	rows, err := q.db.Query(ctx, listPaymentOrdersByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrder{}
	for rows.Next() {
		var i PaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ReservationID,
			&i.UserID,
			&i.PaymentType,
			&i.BusinessType,
			&i.Amount,
			&i.OutTradeNo,
			&i.TransactionID,
			&i.PrepayID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attach,
			&i.CombinedPaymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentOrdersByUserAndStatus = `-- name: ListPaymentOrdersByUserAndStatus :many
SELECT id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id FROM payment_orders
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListPaymentOrdersByUserAndStatusParams struct {
	UserID int64  `json:"user_id"`
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListPaymentOrdersByUserAndStatus(ctx context.Context, arg ListPaymentOrdersByUserAndStatusParams) ([]PaymentOrder, error) {
	rows, err := q.db.Query(ctx, listPaymentOrdersByUserAndStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrder{}
	for rows.Next() {
		var i PaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ReservationID,
			&i.UserID,
			&i.PaymentType,
			&i.BusinessType,
			&i.Amount,
			&i.OutTradeNo,
			&i.TransactionID,
			&i.PrepayID,
			&i.Status,
			&i.PaidAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attach,
			&i.CombinedPaymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentOrderPrepayId = `-- name: UpdatePaymentOrderPrepayId :one
UPDATE payment_orders
SET
    prepay_id = $2
WHERE id = $1
RETURNING id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id
`

type UpdatePaymentOrderPrepayIdParams struct {
	ID       int64       `json:"id"`
	PrepayID pgtype.Text `json:"prepay_id"`
}

func (q *Queries) UpdatePaymentOrderPrepayId(ctx context.Context, arg UpdatePaymentOrderPrepayIdParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderPrepayId, arg.ID, arg.PrepayID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const updatePaymentOrderToClosed = `-- name: UpdatePaymentOrderToClosed :one
UPDATE payment_orders
SET
    status = 'closed'
WHERE id = $1 AND status = 'pending'
RETURNING id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id
`

func (q *Queries) UpdatePaymentOrderToClosed(ctx context.Context, id int64) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderToClosed, id)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const updatePaymentOrderToFailed = `-- name: UpdatePaymentOrderToFailed :one
UPDATE payment_orders
SET
    status = 'failed'
WHERE id = $1 AND status = 'pending'
RETURNING id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id
`

func (q *Queries) UpdatePaymentOrderToFailed(ctx context.Context, id int64) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderToFailed, id)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const updatePaymentOrderToPaid = `-- name: UpdatePaymentOrderToPaid :one
UPDATE payment_orders
SET
    status = 'paid',
    transaction_id = $2,
    paid_at = now()
WHERE id = $1 AND status = 'pending'
RETURNING id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id
`

type UpdatePaymentOrderToPaidParams struct {
	ID            int64       `json:"id"`
	TransactionID pgtype.Text `json:"transaction_id"`
}

func (q *Queries) UpdatePaymentOrderToPaid(ctx context.Context, arg UpdatePaymentOrderToPaidParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderToPaid, arg.ID, arg.TransactionID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}

const updatePaymentOrderToRefunded = `-- name: UpdatePaymentOrderToRefunded :one
UPDATE payment_orders
SET
    status = 'refunded'
WHERE id = $1
RETURNING id, order_id, reservation_id, user_id, payment_type, business_type, amount, out_trade_no, transaction_id, prepay_id, status, paid_at, created_at, expires_at, attach, combined_payment_id
`

func (q *Queries) UpdatePaymentOrderToRefunded(ctx context.Context, id int64) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderToRefunded, id)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ReservationID,
		&i.UserID,
		&i.PaymentType,
		&i.BusinessType,
		&i.Amount,
		&i.OutTradeNo,
		&i.TransactionID,
		&i.PrepayID,
		&i.Status,
		&i.PaidAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attach,
		&i.CombinedPaymentID,
	)
	return i, err
}
