// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refund_order.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefundOrder = `-- name: CreateRefundOrder :one
INSERT INTO refund_orders (
    payment_order_id,
    refund_type,
    refund_amount,
    refund_reason,
    out_refund_no,
    platform_refund,
    operator_refund,
    merchant_refund,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at
`

type CreateRefundOrderParams struct {
	PaymentOrderID int64       `json:"payment_order_id"`
	RefundType     string      `json:"refund_type"`
	RefundAmount   int64       `json:"refund_amount"`
	RefundReason   pgtype.Text `json:"refund_reason"`
	OutRefundNo    string      `json:"out_refund_no"`
	PlatformRefund pgtype.Int8 `json:"platform_refund"`
	OperatorRefund pgtype.Int8 `json:"operator_refund"`
	MerchantRefund pgtype.Int8 `json:"merchant_refund"`
	Status         string      `json:"status"`
}

func (q *Queries) CreateRefundOrder(ctx context.Context, arg CreateRefundOrderParams) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, createRefundOrder,
		arg.PaymentOrderID,
		arg.RefundType,
		arg.RefundAmount,
		arg.RefundReason,
		arg.OutRefundNo,
		arg.PlatformRefund,
		arg.OperatorRefund,
		arg.MerchantRefund,
		arg.Status,
	)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefundOrder = `-- name: GetRefundOrder :one
SELECT id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at FROM refund_orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRefundOrder(ctx context.Context, id int64) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, getRefundOrder, id)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefundOrderByOutRefundNo = `-- name: GetRefundOrderByOutRefundNo :one
SELECT id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at FROM refund_orders
WHERE out_refund_no = $1 LIMIT 1
`

func (q *Queries) GetRefundOrderByOutRefundNo(ctx context.Context, outRefundNo string) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, getRefundOrderByOutRefundNo, outRefundNo)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefundOrderByRefundId = `-- name: GetRefundOrderByRefundId :one
SELECT id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at FROM refund_orders
WHERE refund_id = $1 LIMIT 1
`

func (q *Queries) GetRefundOrderByRefundId(ctx context.Context, refundID pgtype.Text) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, getRefundOrderByRefundId, refundID)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefundOrderForUpdate = `-- name: GetRefundOrderForUpdate :one
SELECT id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at FROM refund_orders
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetRefundOrderForUpdate(ctx context.Context, id int64) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, getRefundOrderForUpdate, id)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTotalRefundedByPaymentOrder = `-- name: GetTotalRefundedByPaymentOrder :one
SELECT COALESCE(SUM(refund_amount), 0)::bigint as total_refunded
FROM refund_orders
WHERE payment_order_id = $1 AND status = 'success'
`

func (q *Queries) GetTotalRefundedByPaymentOrder(ctx context.Context, paymentOrderID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalRefundedByPaymentOrder, paymentOrderID)
	var total_refunded int64
	err := row.Scan(&total_refunded)
	return total_refunded, err
}

const listRefundOrdersByPaymentOrder = `-- name: ListRefundOrdersByPaymentOrder :many
SELECT id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at FROM refund_orders
WHERE payment_order_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListRefundOrdersByPaymentOrder(ctx context.Context, paymentOrderID int64) ([]RefundOrder, error) {
	rows, err := q.db.Query(ctx, listRefundOrdersByPaymentOrder, paymentOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefundOrder{}
	for rows.Next() {
		var i RefundOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.RefundType,
			&i.RefundAmount,
			&i.RefundReason,
			&i.OutRefundNo,
			&i.RefundID,
			&i.PlatformRefund,
			&i.OperatorRefund,
			&i.MerchantRefund,
			&i.Status,
			&i.RefundedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundOrdersByStatus = `-- name: ListRefundOrdersByStatus :many
SELECT id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at FROM refund_orders
WHERE status = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListRefundOrdersByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListRefundOrdersByStatus(ctx context.Context, arg ListRefundOrdersByStatusParams) ([]RefundOrder, error) {
	rows, err := q.db.Query(ctx, listRefundOrdersByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefundOrder{}
	for rows.Next() {
		var i RefundOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.RefundType,
			&i.RefundAmount,
			&i.RefundReason,
			&i.OutRefundNo,
			&i.RefundID,
			&i.PlatformRefund,
			&i.OperatorRefund,
			&i.MerchantRefund,
			&i.Status,
			&i.RefundedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefundOrderToClosed = `-- name: UpdateRefundOrderToClosed :one
UPDATE refund_orders
SET
    status = 'closed'
WHERE id = $1 AND status = 'pending'
RETURNING id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at
`

func (q *Queries) UpdateRefundOrderToClosed(ctx context.Context, id int64) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, updateRefundOrderToClosed, id)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateRefundOrderToFailed = `-- name: UpdateRefundOrderToFailed :one
UPDATE refund_orders
SET
    status = 'failed'
WHERE id = $1
RETURNING id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at
`

func (q *Queries) UpdateRefundOrderToFailed(ctx context.Context, id int64) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, updateRefundOrderToFailed, id)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateRefundOrderToProcessing = `-- name: UpdateRefundOrderToProcessing :one
UPDATE refund_orders
SET
    status = 'processing',
    refund_id = $2
WHERE id = $1 AND status = 'pending'
RETURNING id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at
`

type UpdateRefundOrderToProcessingParams struct {
	ID       int64       `json:"id"`
	RefundID pgtype.Text `json:"refund_id"`
}

func (q *Queries) UpdateRefundOrderToProcessing(ctx context.Context, arg UpdateRefundOrderToProcessingParams) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, updateRefundOrderToProcessing, arg.ID, arg.RefundID)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateRefundOrderToSuccess = `-- name: UpdateRefundOrderToSuccess :one
UPDATE refund_orders
SET
    status = 'success',
    refunded_at = now()
WHERE id = $1 AND status = 'processing'
RETURNING id, payment_order_id, refund_type, refund_amount, refund_reason, out_refund_no, refund_id, platform_refund, operator_refund, merchant_refund, status, refunded_at, created_at
`

func (q *Queries) UpdateRefundOrderToSuccess(ctx context.Context, id int64) (RefundOrder, error) {
	row := q.db.QueryRow(ctx, updateRefundOrderToSuccess, id)
	var i RefundOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.RefundType,
		&i.RefundAmount,
		&i.RefundReason,
		&i.OutRefundNo,
		&i.RefundID,
		&i.PlatformRefund,
		&i.OperatorRefund,
		&i.MerchantRefund,
		&i.Status,
		&i.RefundedAt,
		&i.CreatedAt,
	)
	return i, err
}
