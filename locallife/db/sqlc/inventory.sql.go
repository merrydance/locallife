// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateDailyInventoryParams struct {
	MerchantID    int64       `json:"merchant_id"`
	DishID        int64       `json:"dish_id"`
	Date          pgtype.Date `json:"date"`
	TotalQuantity int32       `json:"total_quantity"`
	SoldQuantity  int32       `json:"sold_quantity"`
}

const checkAndDecrementInventory = `-- name: CheckAndDecrementInventory :one
UPDATE daily_inventory
SET
  sold_quantity = sold_quantity + $4,
  updated_at = now()
WHERE merchant_id = $1
  AND dish_id = $2
  AND date = $3
  AND (total_quantity = -1 OR sold_quantity + $4 <= total_quantity)
RETURNING id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at
`

type CheckAndDecrementInventoryParams struct {
	MerchantID   int64       `json:"merchant_id"`
	DishID       int64       `json:"dish_id"`
	Date         pgtype.Date `json:"date"`
	SoldQuantity int32       `json:"sold_quantity"`
}

func (q *Queries) CheckAndDecrementInventory(ctx context.Context, arg CheckAndDecrementInventoryParams) (DailyInventory, error) {
	row := q.db.QueryRow(ctx, checkAndDecrementInventory,
		arg.MerchantID,
		arg.DishID,
		arg.Date,
		arg.SoldQuantity,
	)
	var i DailyInventory
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DishID,
		&i.Date,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDailyInventory = `-- name: CreateDailyInventory :one

INSERT INTO daily_inventory (
  merchant_id,
  dish_id,
  date,
  total_quantity,
  sold_quantity
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at
`

type CreateDailyInventoryParams struct {
	MerchantID    int64       `json:"merchant_id"`
	DishID        int64       `json:"dish_id"`
	Date          pgtype.Date `json:"date"`
	TotalQuantity int32       `json:"total_quantity"`
	SoldQuantity  int32       `json:"sold_quantity"`
}

// ============================================
// 库存管理查询 (Inventory Queries)
// ============================================
func (q *Queries) CreateDailyInventory(ctx context.Context, arg CreateDailyInventoryParams) (DailyInventory, error) {
	row := q.db.QueryRow(ctx, createDailyInventory,
		arg.MerchantID,
		arg.DishID,
		arg.Date,
		arg.TotalQuantity,
		arg.SoldQuantity,
	)
	var i DailyInventory
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DishID,
		&i.Date,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDailyInventory = `-- name: DeleteDailyInventory :exec
DELETE FROM daily_inventory
WHERE merchant_id = $1 AND dish_id = $2 AND date = $3
`

type DeleteDailyInventoryParams struct {
	MerchantID int64       `json:"merchant_id"`
	DishID     int64       `json:"dish_id"`
	Date       pgtype.Date `json:"date"`
}

func (q *Queries) DeleteDailyInventory(ctx context.Context, arg DeleteDailyInventoryParams) error {
	_, err := q.db.Exec(ctx, deleteDailyInventory, arg.MerchantID, arg.DishID, arg.Date)
	return err
}

const deleteOldInventory = `-- name: DeleteOldInventory :exec
DELETE FROM daily_inventory
WHERE date < $1
`

func (q *Queries) DeleteOldInventory(ctx context.Context, date pgtype.Date) error {
	_, err := q.db.Exec(ctx, deleteOldInventory, date)
	return err
}

const getDailyInventory = `-- name: GetDailyInventory :one
SELECT id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at FROM daily_inventory
WHERE merchant_id = $1 AND dish_id = $2 AND date = $3
LIMIT 1
`

type GetDailyInventoryParams struct {
	MerchantID int64       `json:"merchant_id"`
	DishID     int64       `json:"dish_id"`
	Date       pgtype.Date `json:"date"`
}

func (q *Queries) GetDailyInventory(ctx context.Context, arg GetDailyInventoryParams) (DailyInventory, error) {
	row := q.db.QueryRow(ctx, getDailyInventory, arg.MerchantID, arg.DishID, arg.Date)
	var i DailyInventory
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DishID,
		&i.Date,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDailyInventoryForUpdate = `-- name: GetDailyInventoryForUpdate :one
SELECT id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at FROM daily_inventory
WHERE merchant_id = $1 AND dish_id = $2 AND date = $3
LIMIT 1
FOR UPDATE
`

type GetDailyInventoryForUpdateParams struct {
	MerchantID int64       `json:"merchant_id"`
	DishID     int64       `json:"dish_id"`
	Date       pgtype.Date `json:"date"`
}

func (q *Queries) GetDailyInventoryForUpdate(ctx context.Context, arg GetDailyInventoryForUpdateParams) (DailyInventory, error) {
	row := q.db.QueryRow(ctx, getDailyInventoryForUpdate, arg.MerchantID, arg.DishID, arg.Date)
	var i DailyInventory
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DishID,
		&i.Date,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryStats = `-- name: GetInventoryStats :one
SELECT 
  COUNT(*) as total_dishes,
  COUNT(*) FILTER (WHERE total_quantity = -1) as unlimited_dishes,
  COUNT(*) FILTER (WHERE total_quantity > 0 AND sold_quantity >= total_quantity) as sold_out_dishes,
  COUNT(*) FILTER (WHERE total_quantity > 0 AND sold_quantity < total_quantity) as available_dishes
FROM daily_inventory
WHERE merchant_id = $1 AND date = $2
`

type GetInventoryStatsParams struct {
	MerchantID int64       `json:"merchant_id"`
	Date       pgtype.Date `json:"date"`
}

type GetInventoryStatsRow struct {
	TotalDishes     int64 `json:"total_dishes"`
	UnlimitedDishes int64 `json:"unlimited_dishes"`
	SoldOutDishes   int64 `json:"sold_out_dishes"`
	AvailableDishes int64 `json:"available_dishes"`
}

func (q *Queries) GetInventoryStats(ctx context.Context, arg GetInventoryStatsParams) (GetInventoryStatsRow, error) {
	row := q.db.QueryRow(ctx, getInventoryStats, arg.MerchantID, arg.Date)
	var i GetInventoryStatsRow
	err := row.Scan(
		&i.TotalDishes,
		&i.UnlimitedDishes,
		&i.SoldOutDishes,
		&i.AvailableDishes,
	)
	return i, err
}

const incrementSoldQuantity = `-- name: IncrementSoldQuantity :one
UPDATE daily_inventory
SET
  sold_quantity = sold_quantity + $4,
  updated_at = now()
WHERE merchant_id = $1
  AND dish_id = $2
  AND date = $3
RETURNING id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at
`

type IncrementSoldQuantityParams struct {
	MerchantID   int64       `json:"merchant_id"`
	DishID       int64       `json:"dish_id"`
	Date         pgtype.Date `json:"date"`
	SoldQuantity int32       `json:"sold_quantity"`
}

func (q *Queries) IncrementSoldQuantity(ctx context.Context, arg IncrementSoldQuantityParams) (DailyInventory, error) {
	row := q.db.QueryRow(ctx, incrementSoldQuantity,
		arg.MerchantID,
		arg.DishID,
		arg.Date,
		arg.SoldQuantity,
	)
	var i DailyInventory
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DishID,
		&i.Date,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDailyInventoryByDate = `-- name: ListDailyInventoryByDate :many
SELECT id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at FROM daily_inventory
WHERE date = $1
ORDER BY merchant_id ASC, dish_id ASC
`

func (q *Queries) ListDailyInventoryByDate(ctx context.Context, date pgtype.Date) ([]DailyInventory, error) {
	rows, err := q.db.Query(ctx, listDailyInventoryByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DailyInventory{}
	for rows.Next() {
		var i DailyInventory
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.DishID,
			&i.Date,
			&i.TotalQuantity,
			&i.SoldQuantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDailyInventoryByMerchant = `-- name: ListDailyInventoryByMerchant :many
SELECT 
  di.id, di.merchant_id, di.dish_id, di.date, di.total_quantity, di.sold_quantity, di.created_at, di.updated_at,
  d.name as dish_name,
  d.price as dish_price
FROM daily_inventory di
JOIN dishes d ON di.dish_id = d.id
WHERE 
  di.merchant_id = $1
  AND di.date = $2
ORDER BY d.name ASC
`

type ListDailyInventoryByMerchantParams struct {
	MerchantID int64       `json:"merchant_id"`
	Date       pgtype.Date `json:"date"`
}

type ListDailyInventoryByMerchantRow struct {
	ID            int64              `json:"id"`
	MerchantID    int64              `json:"merchant_id"`
	DishID        int64              `json:"dish_id"`
	Date          pgtype.Date        `json:"date"`
	TotalQuantity int32              `json:"total_quantity"`
	SoldQuantity  int32              `json:"sold_quantity"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DishName      string             `json:"dish_name"`
	DishPrice     int64              `json:"dish_price"`
}

func (q *Queries) ListDailyInventoryByMerchant(ctx context.Context, arg ListDailyInventoryByMerchantParams) ([]ListDailyInventoryByMerchantRow, error) {
	rows, err := q.db.Query(ctx, listDailyInventoryByMerchant, arg.MerchantID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDailyInventoryByMerchantRow{}
	for rows.Next() {
		var i ListDailyInventoryByMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.DishID,
			&i.Date,
			&i.TotalQuantity,
			&i.SoldQuantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DishName,
			&i.DishPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDailyInventory = `-- name: UpdateDailyInventory :one
UPDATE daily_inventory
SET
  total_quantity = COALESCE($1, total_quantity),
  sold_quantity = COALESCE($2, sold_quantity),
  updated_at = now()
WHERE merchant_id = $3
  AND dish_id = $4
  AND date = $5
RETURNING id, merchant_id, dish_id, date, total_quantity, sold_quantity, created_at, updated_at
`

type UpdateDailyInventoryParams struct {
	TotalQuantity pgtype.Int4 `json:"total_quantity"`
	SoldQuantity  pgtype.Int4 `json:"sold_quantity"`
	MerchantID    int64       `json:"merchant_id"`
	DishID        int64       `json:"dish_id"`
	Date          pgtype.Date `json:"date"`
}

func (q *Queries) UpdateDailyInventory(ctx context.Context, arg UpdateDailyInventoryParams) (DailyInventory, error) {
	row := q.db.QueryRow(ctx, updateDailyInventory,
		arg.TotalQuantity,
		arg.SoldQuantity,
		arg.MerchantID,
		arg.DishID,
		arg.Date,
	)
	var i DailyInventory
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.DishID,
		&i.Date,
		&i.TotalQuantity,
		&i.SoldQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
