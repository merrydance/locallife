// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order_status_log.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrderStatusLog = `-- name: CreateOrderStatusLog :one
INSERT INTO order_status_logs (
    order_id,
    from_status,
    to_status,
    operator_id,
    operator_type,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, order_id, from_status, to_status, operator_id, operator_type, notes, created_at
`

type CreateOrderStatusLogParams struct {
	OrderID      int64       `json:"order_id"`
	FromStatus   pgtype.Text `json:"from_status"`
	ToStatus     string      `json:"to_status"`
	OperatorID   pgtype.Int8 `json:"operator_id"`
	OperatorType pgtype.Text `json:"operator_type"`
	Notes        pgtype.Text `json:"notes"`
}

func (q *Queries) CreateOrderStatusLog(ctx context.Context, arg CreateOrderStatusLogParams) (OrderStatusLog, error) {
	row := q.db.QueryRow(ctx, createOrderStatusLog,
		arg.OrderID,
		arg.FromStatus,
		arg.ToStatus,
		arg.OperatorID,
		arg.OperatorType,
		arg.Notes,
	)
	var i OrderStatusLog
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.FromStatus,
		&i.ToStatus,
		&i.OperatorID,
		&i.OperatorType,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const listOrderStatusLogs = `-- name: ListOrderStatusLogs :many
SELECT id, order_id, from_status, to_status, operator_id, operator_type, notes, created_at FROM order_status_logs
WHERE order_id = $1
ORDER BY created_at
`

func (q *Queries) ListOrderStatusLogs(ctx context.Context, orderID int64) ([]OrderStatusLog, error) {
	rows, err := q.db.Query(ctx, listOrderStatusLogs, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderStatusLog{}
	for rows.Next() {
		var i OrderStatusLog
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.FromStatus,
			&i.ToStatus,
			&i.OperatorID,
			&i.OperatorType,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderStatusLogsWithOperator = `-- name: ListOrderStatusLogsWithOperator :many
SELECT 
    osl.id, osl.order_id, osl.from_status, osl.to_status, osl.operator_id, osl.operator_type, osl.notes, osl.created_at,
    u.full_name as operator_name
FROM order_status_logs osl
LEFT JOIN users u ON osl.operator_id = u.id
WHERE osl.order_id = $1
ORDER BY osl.created_at
`

type ListOrderStatusLogsWithOperatorRow struct {
	ID           int64       `json:"id"`
	OrderID      int64       `json:"order_id"`
	FromStatus   pgtype.Text `json:"from_status"`
	ToStatus     string      `json:"to_status"`
	OperatorID   pgtype.Int8 `json:"operator_id"`
	OperatorType pgtype.Text `json:"operator_type"`
	Notes        pgtype.Text `json:"notes"`
	CreatedAt    time.Time   `json:"created_at"`
	OperatorName pgtype.Text `json:"operator_name"`
}

func (q *Queries) ListOrderStatusLogsWithOperator(ctx context.Context, orderID int64) ([]ListOrderStatusLogsWithOperatorRow, error) {
	rows, err := q.db.Query(ctx, listOrderStatusLogsWithOperator, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrderStatusLogsWithOperatorRow{}
	for rows.Next() {
		var i ListOrderStatusLogsWithOperatorRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.FromStatus,
			&i.ToStatus,
			&i.OperatorID,
			&i.OperatorType,
			&i.Notes,
			&i.CreatedAt,
			&i.OperatorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
