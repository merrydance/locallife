// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: profit_sharing_order.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMerchantFinanceOrders = `-- name: CountMerchantFinanceOrders :one
SELECT COUNT(*)::bigint
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND created_at >= $2 AND created_at <= $3
`

type CountMerchantFinanceOrdersParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) CountMerchantFinanceOrders(ctx context.Context, arg CountMerchantFinanceOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantFinanceOrders, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countMerchantSettlements = `-- name: CountMerchantSettlements :one
SELECT COUNT(*)::bigint
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND created_at >= $2 AND created_at <= $3
`

type CountMerchantSettlementsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) CountMerchantSettlements(ctx context.Context, arg CountMerchantSettlementsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantSettlements, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countMerchantSettlementsByStatus = `-- name: CountMerchantSettlementsByStatus :one
SELECT COUNT(*)::bigint
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND status = $2
  AND created_at >= $3 AND created_at <= $4
`

type CountMerchantSettlementsByStatusParams struct {
	MerchantID  int64     `json:"merchant_id"`
	Status      string    `json:"status"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) CountMerchantSettlementsByStatus(ctx context.Context, arg CountMerchantSettlementsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantSettlementsByStatus,
		arg.MerchantID,
		arg.Status,
		arg.CreatedAt,
		arg.CreatedAt_2,
	)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createProfitSharingOrder = `-- name: CreateProfitSharingOrder :one
INSERT INTO profit_sharing_orders (
    payment_order_id,
    merchant_id,
    operator_id,
    order_source,
    total_amount,
    delivery_fee,
    rider_id,
    rider_amount,
    distributable_amount,
    platform_rate,
    operator_rate,
    platform_commission,
    operator_commission,
    merchant_amount,
    out_order_no,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
`

type CreateProfitSharingOrderParams struct {
	PaymentOrderID      int64       `json:"payment_order_id"`
	MerchantID          int64       `json:"merchant_id"`
	OperatorID          pgtype.Int8 `json:"operator_id"`
	OrderSource         string      `json:"order_source"`
	TotalAmount         int64       `json:"total_amount"`
	DeliveryFee         int64       `json:"delivery_fee"`
	RiderID             pgtype.Int8 `json:"rider_id"`
	RiderAmount         int64       `json:"rider_amount"`
	DistributableAmount int64       `json:"distributable_amount"`
	PlatformRate        int32       `json:"platform_rate"`
	OperatorRate        int32       `json:"operator_rate"`
	PlatformCommission  int64       `json:"platform_commission"`
	OperatorCommission  int64       `json:"operator_commission"`
	MerchantAmount      int64       `json:"merchant_amount"`
	OutOrderNo          string      `json:"out_order_no"`
	Status              string      `json:"status"`
}

func (q *Queries) CreateProfitSharingOrder(ctx context.Context, arg CreateProfitSharingOrderParams) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, createProfitSharingOrder,
		arg.PaymentOrderID,
		arg.MerchantID,
		arg.OperatorID,
		arg.OrderSource,
		arg.TotalAmount,
		arg.DeliveryFee,
		arg.RiderID,
		arg.RiderAmount,
		arg.DistributableAmount,
		arg.PlatformRate,
		arg.OperatorRate,
		arg.PlatformCommission,
		arg.OperatorCommission,
		arg.MerchantAmount,
		arg.OutOrderNo,
		arg.Status,
	)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const createProfitSharingOrderSimple = `-- name: CreateProfitSharingOrderSimple :one
INSERT INTO profit_sharing_orders (
    payment_order_id,
    merchant_id,
    operator_id,
    order_source,
    total_amount,
    delivery_fee,
    distributable_amount,
    platform_rate,
    operator_rate,
    platform_commission,
    operator_commission,
    merchant_amount,
    out_order_no,
    status
) VALUES (
    $1, $2, $3, $4, $5, 0, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
`

type CreateProfitSharingOrderSimpleParams struct {
	PaymentOrderID     int64       `json:"payment_order_id"`
	MerchantID         int64       `json:"merchant_id"`
	OperatorID         pgtype.Int8 `json:"operator_id"`
	OrderSource        string      `json:"order_source"`
	TotalAmount        int64       `json:"total_amount"`
	PlatformRate       int32       `json:"platform_rate"`
	OperatorRate       int32       `json:"operator_rate"`
	PlatformCommission int64       `json:"platform_commission"`
	OperatorCommission int64       `json:"operator_commission"`
	MerchantAmount     int64       `json:"merchant_amount"`
	OutOrderNo         string      `json:"out_order_no"`
	Status             string      `json:"status"`
}

// 简化版创建（不含骑手分账，用于堂食/自提订单）
func (q *Queries) CreateProfitSharingOrderSimple(ctx context.Context, arg CreateProfitSharingOrderSimpleParams) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, createProfitSharingOrderSimple,
		arg.PaymentOrderID,
		arg.MerchantID,
		arg.OperatorID,
		arg.OrderSource,
		arg.TotalAmount,
		arg.PlatformRate,
		arg.OperatorRate,
		arg.PlatformCommission,
		arg.OperatorCommission,
		arg.MerchantAmount,
		arg.OutOrderNo,
		arg.Status,
	)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const getMerchantDailyFinance = `-- name: GetMerchantDailyFinance :many
SELECT 
    DATE(created_at) AS date,
    COUNT(*) as order_count,
    COALESCE(SUM(total_amount), 0)::bigint as total_gmv,
    COALESCE(SUM(merchant_amount), 0)::bigint as merchant_income,
    COALESCE(SUM(platform_commission + operator_commission), 0)::bigint as total_fee
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND status = 'finished'
  AND created_at >= $2 AND created_at <= $3
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetMerchantDailyFinanceParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantDailyFinanceRow struct {
	Date           pgtype.Date `json:"date"`
	OrderCount     int64       `json:"order_count"`
	TotalGmv       int64       `json:"total_gmv"`
	MerchantIncome int64       `json:"merchant_income"`
	TotalFee       int64       `json:"total_fee"`
}

// 商户每日财务汇总
func (q *Queries) GetMerchantDailyFinance(ctx context.Context, arg GetMerchantDailyFinanceParams) ([]GetMerchantDailyFinanceRow, error) {
	rows, err := q.db.Query(ctx, getMerchantDailyFinance, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantDailyFinanceRow{}
	for rows.Next() {
		var i GetMerchantDailyFinanceRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderCount,
			&i.TotalGmv,
			&i.MerchantIncome,
			&i.TotalFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantFinanceOverview = `-- name: GetMerchantFinanceOverview :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'finished') as completed_orders,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_orders,
    COALESCE(SUM(CASE WHEN status = 'finished' THEN total_amount ELSE 0 END), 0)::bigint as total_gmv,
    COALESCE(SUM(CASE WHEN status = 'finished' THEN merchant_amount ELSE 0 END), 0)::bigint as total_income,
    COALESCE(SUM(CASE WHEN status = 'finished' THEN platform_commission ELSE 0 END), 0)::bigint as total_platform_fee,
    COALESCE(SUM(CASE WHEN status = 'finished' THEN operator_commission ELSE 0 END), 0)::bigint as total_operator_fee,
    COALESCE(SUM(CASE WHEN status = 'pending' THEN merchant_amount ELSE 0 END), 0)::bigint as pending_income
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND created_at >= $2 AND created_at <= $3
`

type GetMerchantFinanceOverviewParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantFinanceOverviewRow struct {
	CompletedOrders  int64 `json:"completed_orders"`
	PendingOrders    int64 `json:"pending_orders"`
	TotalGmv         int64 `json:"total_gmv"`
	TotalIncome      int64 `json:"total_income"`
	TotalPlatformFee int64 `json:"total_platform_fee"`
	TotalOperatorFee int64 `json:"total_operator_fee"`
	PendingIncome    int64 `json:"pending_income"`
}

// 商户财务概览：统计收入、服务费、净收入
func (q *Queries) GetMerchantFinanceOverview(ctx context.Context, arg GetMerchantFinanceOverviewParams) (GetMerchantFinanceOverviewRow, error) {
	row := q.db.QueryRow(ctx, getMerchantFinanceOverview, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantFinanceOverviewRow
	err := row.Scan(
		&i.CompletedOrders,
		&i.PendingOrders,
		&i.TotalGmv,
		&i.TotalIncome,
		&i.TotalPlatformFee,
		&i.TotalOperatorFee,
		&i.PendingIncome,
	)
	return i, err
}

const getMerchantProfitSharingStats = `-- name: GetMerchantProfitSharingStats :one
SELECT 
    COUNT(*) as total_orders,
    COALESCE(SUM(total_amount), 0)::bigint as total_amount,
    COALESCE(SUM(merchant_amount), 0)::bigint as total_merchant_amount,
    COALESCE(SUM(platform_commission), 0)::bigint as total_platform_commission,
    COALESCE(SUM(operator_commission), 0)::bigint as total_operator_commission
FROM profit_sharing_orders
WHERE merchant_id = $1 AND status = 'finished'
  AND created_at >= $2 AND created_at <= $3
`

type GetMerchantProfitSharingStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantProfitSharingStatsRow struct {
	TotalOrders             int64 `json:"total_orders"`
	TotalAmount             int64 `json:"total_amount"`
	TotalMerchantAmount     int64 `json:"total_merchant_amount"`
	TotalPlatformCommission int64 `json:"total_platform_commission"`
	TotalOperatorCommission int64 `json:"total_operator_commission"`
}

func (q *Queries) GetMerchantProfitSharingStats(ctx context.Context, arg GetMerchantProfitSharingStatsParams) (GetMerchantProfitSharingStatsRow, error) {
	row := q.db.QueryRow(ctx, getMerchantProfitSharingStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantProfitSharingStatsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalAmount,
		&i.TotalMerchantAmount,
		&i.TotalPlatformCommission,
		&i.TotalOperatorCommission,
	)
	return i, err
}

const getMerchantServiceFeeDetail = `-- name: GetMerchantServiceFeeDetail :many
SELECT 
    DATE(created_at) AS date,
    order_source,
    COUNT(*) as order_count,
    COALESCE(SUM(total_amount), 0)::bigint as total_amount,
    COALESCE(SUM(platform_commission), 0)::bigint as platform_fee,
    COALESCE(SUM(operator_commission), 0)::bigint as operator_fee
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND status = 'finished'
  AND created_at >= $2 AND created_at <= $3
GROUP BY DATE(created_at), order_source
ORDER BY date DESC, order_source
`

type GetMerchantServiceFeeDetailParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantServiceFeeDetailRow struct {
	Date        pgtype.Date `json:"date"`
	OrderSource string      `json:"order_source"`
	OrderCount  int64       `json:"order_count"`
	TotalAmount int64       `json:"total_amount"`
	PlatformFee int64       `json:"platform_fee"`
	OperatorFee int64       `json:"operator_fee"`
}

// 商户服务费明细
func (q *Queries) GetMerchantServiceFeeDetail(ctx context.Context, arg GetMerchantServiceFeeDetailParams) ([]GetMerchantServiceFeeDetailRow, error) {
	rows, err := q.db.Query(ctx, getMerchantServiceFeeDetail, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantServiceFeeDetailRow{}
	for rows.Next() {
		var i GetMerchantServiceFeeDetailRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderSource,
			&i.OrderCount,
			&i.TotalAmount,
			&i.PlatformFee,
			&i.OperatorFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperatorProfitSharingStats = `-- name: GetOperatorProfitSharingStats :one
SELECT 
    COUNT(*) as total_orders,
    COALESCE(SUM(total_amount), 0)::bigint as total_amount,
    COALESCE(SUM(operator_commission), 0)::bigint as total_operator_commission
FROM profit_sharing_orders
WHERE operator_id = $1 AND status = 'finished'
  AND created_at >= $2 AND created_at <= $3
`

type GetOperatorProfitSharingStatsParams struct {
	OperatorID  pgtype.Int8 `json:"operator_id"`
	CreatedAt   time.Time   `json:"created_at"`
	CreatedAt_2 time.Time   `json:"created_at_2"`
}

type GetOperatorProfitSharingStatsRow struct {
	TotalOrders             int64 `json:"total_orders"`
	TotalAmount             int64 `json:"total_amount"`
	TotalOperatorCommission int64 `json:"total_operator_commission"`
}

func (q *Queries) GetOperatorProfitSharingStats(ctx context.Context, arg GetOperatorProfitSharingStatsParams) (GetOperatorProfitSharingStatsRow, error) {
	row := q.db.QueryRow(ctx, getOperatorProfitSharingStats, arg.OperatorID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetOperatorProfitSharingStatsRow
	err := row.Scan(&i.TotalOrders, &i.TotalAmount, &i.TotalOperatorCommission)
	return i, err
}

const getProfitSharingOrder = `-- name: GetProfitSharingOrder :one
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProfitSharingOrder(ctx context.Context, id int64) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, getProfitSharingOrder, id)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const getProfitSharingOrderByOutOrderNo = `-- name: GetProfitSharingOrderByOutOrderNo :one
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE out_order_no = $1 LIMIT 1
`

func (q *Queries) GetProfitSharingOrderByOutOrderNo(ctx context.Context, outOrderNo string) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, getProfitSharingOrderByOutOrderNo, outOrderNo)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const getProfitSharingOrderByPaymentOrder = `-- name: GetProfitSharingOrderByPaymentOrder :one
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE payment_order_id = $1 LIMIT 1
`

func (q *Queries) GetProfitSharingOrderByPaymentOrder(ctx context.Context, paymentOrderID int64) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, getProfitSharingOrderByPaymentOrder, paymentOrderID)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const getProfitSharingOrderForUpdate = `-- name: GetProfitSharingOrderForUpdate :one
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetProfitSharingOrderForUpdate(ctx context.Context, id int64) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, getProfitSharingOrderForUpdate, id)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const getRiderDailyIncome = `-- name: GetRiderDailyIncome :many
SELECT 
    DATE(created_at) AS date,
    COUNT(*) as delivery_count,
    COALESCE(SUM(rider_amount), 0)::bigint as daily_income
FROM profit_sharing_orders
WHERE rider_id = $1
  AND status = 'finished'
  AND created_at >= $2 AND created_at <= $3
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetRiderDailyIncomeParams struct {
	RiderID     pgtype.Int8 `json:"rider_id"`
	CreatedAt   time.Time   `json:"created_at"`
	CreatedAt_2 time.Time   `json:"created_at_2"`
}

type GetRiderDailyIncomeRow struct {
	Date          pgtype.Date `json:"date"`
	DeliveryCount int64       `json:"delivery_count"`
	DailyIncome   int64       `json:"daily_income"`
}

// 骑手每日收入汇总
func (q *Queries) GetRiderDailyIncome(ctx context.Context, arg GetRiderDailyIncomeParams) ([]GetRiderDailyIncomeRow, error) {
	rows, err := q.db.Query(ctx, getRiderDailyIncome, arg.RiderID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRiderDailyIncomeRow{}
	for rows.Next() {
		var i GetRiderDailyIncomeRow
		if err := rows.Scan(&i.Date, &i.DeliveryCount, &i.DailyIncome); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRiderProfitSharingStats = `-- name: GetRiderProfitSharingStats :one

SELECT 
    COUNT(*) as total_deliveries,
    COALESCE(SUM(rider_amount), 0)::bigint as total_rider_income,
    COALESCE(SUM(delivery_fee), 0)::bigint as total_delivery_fee
FROM profit_sharing_orders
WHERE rider_id = $1 AND status = 'finished'
  AND created_at >= $2 AND created_at <= $3
`

type GetRiderProfitSharingStatsParams struct {
	RiderID     pgtype.Int8 `json:"rider_id"`
	CreatedAt   time.Time   `json:"created_at"`
	CreatedAt_2 time.Time   `json:"created_at_2"`
}

type GetRiderProfitSharingStatsRow struct {
	TotalDeliveries  int64 `json:"total_deliveries"`
	TotalRiderIncome int64 `json:"total_rider_income"`
	TotalDeliveryFee int64 `json:"total_delivery_fee"`
}

// ==================== 骑手分账查询 ====================
// 骑手配送费收入统计
func (q *Queries) GetRiderProfitSharingStats(ctx context.Context, arg GetRiderProfitSharingStatsParams) (GetRiderProfitSharingStatsRow, error) {
	row := q.db.QueryRow(ctx, getRiderProfitSharingStats, arg.RiderID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetRiderProfitSharingStatsRow
	err := row.Scan(&i.TotalDeliveries, &i.TotalRiderIncome, &i.TotalDeliveryFee)
	return i, err
}

const listMerchantFinanceOrders = `-- name: ListMerchantFinanceOrders :many
SELECT 
    p.id,
    p.payment_order_id,
    p.order_source,
    p.total_amount,
    p.platform_commission,
    p.operator_commission,
    p.merchant_amount,
    p.status,
    p.created_at,
    p.finished_at,
    po.order_id
FROM profit_sharing_orders p
JOIN payment_orders po ON po.id = p.payment_order_id
WHERE p.merchant_id = $1
  AND p.created_at >= $2 AND p.created_at <= $3
ORDER BY p.created_at DESC
LIMIT $4 OFFSET $5
`

type ListMerchantFinanceOrdersParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListMerchantFinanceOrdersRow struct {
	ID                 int64              `json:"id"`
	PaymentOrderID     int64              `json:"payment_order_id"`
	OrderSource        string             `json:"order_source"`
	TotalAmount        int64              `json:"total_amount"`
	PlatformCommission int64              `json:"platform_commission"`
	OperatorCommission int64              `json:"operator_commission"`
	MerchantAmount     int64              `json:"merchant_amount"`
	Status             string             `json:"status"`
	CreatedAt          time.Time          `json:"created_at"`
	FinishedAt         pgtype.Timestamptz `json:"finished_at"`
	OrderID            pgtype.Int8        `json:"order_id"`
}

// 商户财务订单明细（带分账信息）
func (q *Queries) ListMerchantFinanceOrders(ctx context.Context, arg ListMerchantFinanceOrdersParams) ([]ListMerchantFinanceOrdersRow, error) {
	rows, err := q.db.Query(ctx, listMerchantFinanceOrders,
		arg.MerchantID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantFinanceOrdersRow{}
	for rows.Next() {
		var i ListMerchantFinanceOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.Status,
			&i.CreatedAt,
			&i.FinishedAt,
			&i.OrderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantSettlements = `-- name: ListMerchantSettlements :many
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND created_at >= $2 AND created_at <= $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListMerchantSettlementsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

// 商户结算记录（带日期范围和状态筛选）
func (q *Queries) ListMerchantSettlements(ctx context.Context, arg ListMerchantSettlementsParams) ([]ProfitSharingOrder, error) {
	rows, err := q.db.Query(ctx, listMerchantSettlements,
		arg.MerchantID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfitSharingOrder{}
	for rows.Next() {
		var i ProfitSharingOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.MerchantID,
			&i.OperatorID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.OutOrderNo,
			&i.SharingOrderID,
			&i.Status,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.DeliveryFee,
			&i.RiderID,
			&i.RiderAmount,
			&i.DistributableAmount,
			&i.PlatformRate,
			&i.OperatorRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantSettlementsByStatus = `-- name: ListMerchantSettlementsByStatus :many
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
FROM profit_sharing_orders
WHERE merchant_id = $1
  AND status = $2
  AND created_at >= $3 AND created_at <= $4
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListMerchantSettlementsByStatusParams struct {
	MerchantID  int64     `json:"merchant_id"`
	Status      string    `json:"status"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

// 商户结算记录（带日期范围和状态筛选）
func (q *Queries) ListMerchantSettlementsByStatus(ctx context.Context, arg ListMerchantSettlementsByStatusParams) ([]ProfitSharingOrder, error) {
	rows, err := q.db.Query(ctx, listMerchantSettlementsByStatus,
		arg.MerchantID,
		arg.Status,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfitSharingOrder{}
	for rows.Next() {
		var i ProfitSharingOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.MerchantID,
			&i.OperatorID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.OutOrderNo,
			&i.SharingOrderID,
			&i.Status,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.DeliveryFee,
			&i.RiderID,
			&i.RiderAmount,
			&i.DistributableAmount,
			&i.PlatformRate,
			&i.OperatorRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfitSharingOrdersByMerchant = `-- name: ListProfitSharingOrdersByMerchant :many
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProfitSharingOrdersByMerchantParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListProfitSharingOrdersByMerchant(ctx context.Context, arg ListProfitSharingOrdersByMerchantParams) ([]ProfitSharingOrder, error) {
	rows, err := q.db.Query(ctx, listProfitSharingOrdersByMerchant, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfitSharingOrder{}
	for rows.Next() {
		var i ProfitSharingOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.MerchantID,
			&i.OperatorID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.OutOrderNo,
			&i.SharingOrderID,
			&i.Status,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.DeliveryFee,
			&i.RiderID,
			&i.RiderAmount,
			&i.DistributableAmount,
			&i.PlatformRate,
			&i.OperatorRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfitSharingOrdersByOperator = `-- name: ListProfitSharingOrdersByOperator :many
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE operator_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProfitSharingOrdersByOperatorParams struct {
	OperatorID pgtype.Int8 `json:"operator_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListProfitSharingOrdersByOperator(ctx context.Context, arg ListProfitSharingOrdersByOperatorParams) ([]ProfitSharingOrder, error) {
	rows, err := q.db.Query(ctx, listProfitSharingOrdersByOperator, arg.OperatorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfitSharingOrder{}
	for rows.Next() {
		var i ProfitSharingOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.MerchantID,
			&i.OperatorID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.OutOrderNo,
			&i.SharingOrderID,
			&i.Status,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.DeliveryFee,
			&i.RiderID,
			&i.RiderAmount,
			&i.DistributableAmount,
			&i.PlatformRate,
			&i.OperatorRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfitSharingOrdersByStatus = `-- name: ListProfitSharingOrdersByStatus :many
SELECT id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate FROM profit_sharing_orders
WHERE status = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListProfitSharingOrdersByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListProfitSharingOrdersByStatus(ctx context.Context, arg ListProfitSharingOrdersByStatusParams) ([]ProfitSharingOrder, error) {
	rows, err := q.db.Query(ctx, listProfitSharingOrdersByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfitSharingOrder{}
	for rows.Next() {
		var i ProfitSharingOrder
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.MerchantID,
			&i.OperatorID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.OutOrderNo,
			&i.SharingOrderID,
			&i.Status,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.DeliveryFee,
			&i.RiderID,
			&i.RiderAmount,
			&i.DistributableAmount,
			&i.PlatformRate,
			&i.OperatorRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderProfitSharingOrders = `-- name: ListRiderProfitSharingOrders :many
SELECT 
    p.id, p.payment_order_id, p.merchant_id, p.operator_id, p.order_source, p.total_amount, p.platform_commission, p.operator_commission, p.merchant_amount, p.out_order_no, p.sharing_order_id, p.status, p.finished_at, p.created_at, p.delivery_fee, p.rider_id, p.rider_amount, p.distributable_amount, p.platform_rate, p.operator_rate,
    po.order_id,
    o.order_no,
    m.name as merchant_name
FROM profit_sharing_orders p
JOIN payment_orders po ON po.id = p.payment_order_id
JOIN orders o ON o.id = po.order_id
JOIN merchants m ON m.id = p.merchant_id
WHERE p.rider_id = $1
  AND p.created_at >= $2 AND p.created_at <= $3
ORDER BY p.created_at DESC
LIMIT $4 OFFSET $5
`

type ListRiderProfitSharingOrdersParams struct {
	RiderID     pgtype.Int8 `json:"rider_id"`
	CreatedAt   time.Time   `json:"created_at"`
	CreatedAt_2 time.Time   `json:"created_at_2"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

type ListRiderProfitSharingOrdersRow struct {
	ID                  int64              `json:"id"`
	PaymentOrderID      int64              `json:"payment_order_id"`
	MerchantID          int64              `json:"merchant_id"`
	OperatorID          pgtype.Int8        `json:"operator_id"`
	OrderSource         string             `json:"order_source"`
	TotalAmount         int64              `json:"total_amount"`
	PlatformCommission  int64              `json:"platform_commission"`
	OperatorCommission  int64              `json:"operator_commission"`
	MerchantAmount      int64              `json:"merchant_amount"`
	OutOrderNo          string             `json:"out_order_no"`
	SharingOrderID      pgtype.Text        `json:"sharing_order_id"`
	Status              string             `json:"status"`
	FinishedAt          pgtype.Timestamptz `json:"finished_at"`
	CreatedAt           time.Time          `json:"created_at"`
	DeliveryFee         int64              `json:"delivery_fee"`
	RiderID             pgtype.Int8        `json:"rider_id"`
	RiderAmount         int64              `json:"rider_amount"`
	DistributableAmount int64              `json:"distributable_amount"`
	PlatformRate        int32              `json:"platform_rate"`
	OperatorRate        int32              `json:"operator_rate"`
	OrderID             pgtype.Int8        `json:"order_id"`
	OrderNo             string             `json:"order_no"`
	MerchantName        string             `json:"merchant_name"`
}

// 骑手配送费明细
func (q *Queries) ListRiderProfitSharingOrders(ctx context.Context, arg ListRiderProfitSharingOrdersParams) ([]ListRiderProfitSharingOrdersRow, error) {
	rows, err := q.db.Query(ctx, listRiderProfitSharingOrders,
		arg.RiderID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRiderProfitSharingOrdersRow{}
	for rows.Next() {
		var i ListRiderProfitSharingOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentOrderID,
			&i.MerchantID,
			&i.OperatorID,
			&i.OrderSource,
			&i.TotalAmount,
			&i.PlatformCommission,
			&i.OperatorCommission,
			&i.MerchantAmount,
			&i.OutOrderNo,
			&i.SharingOrderID,
			&i.Status,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.DeliveryFee,
			&i.RiderID,
			&i.RiderAmount,
			&i.DistributableAmount,
			&i.PlatformRate,
			&i.OperatorRate,
			&i.OrderID,
			&i.OrderNo,
			&i.MerchantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfitSharingOrderToFailed = `-- name: UpdateProfitSharingOrderToFailed :one
UPDATE profit_sharing_orders
SET
    status = 'failed'
WHERE id = $1
RETURNING id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
`

func (q *Queries) UpdateProfitSharingOrderToFailed(ctx context.Context, id int64) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, updateProfitSharingOrderToFailed, id)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const updateProfitSharingOrderToFinished = `-- name: UpdateProfitSharingOrderToFinished :one
UPDATE profit_sharing_orders
SET
    status = 'finished',
    finished_at = now()
WHERE id = $1 AND status = 'processing'
RETURNING id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
`

func (q *Queries) UpdateProfitSharingOrderToFinished(ctx context.Context, id int64) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, updateProfitSharingOrderToFinished, id)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}

const updateProfitSharingOrderToProcessing = `-- name: UpdateProfitSharingOrderToProcessing :one
UPDATE profit_sharing_orders
SET
    status = 'processing',
    sharing_order_id = $2
WHERE id = $1 AND status = 'pending'
RETURNING id, payment_order_id, merchant_id, operator_id, order_source, total_amount, platform_commission, operator_commission, merchant_amount, out_order_no, sharing_order_id, status, finished_at, created_at, delivery_fee, rider_id, rider_amount, distributable_amount, platform_rate, operator_rate
`

type UpdateProfitSharingOrderToProcessingParams struct {
	ID             int64       `json:"id"`
	SharingOrderID pgtype.Text `json:"sharing_order_id"`
}

func (q *Queries) UpdateProfitSharingOrderToProcessing(ctx context.Context, arg UpdateProfitSharingOrderToProcessingParams) (ProfitSharingOrder, error) {
	row := q.db.QueryRow(ctx, updateProfitSharingOrderToProcessing, arg.ID, arg.SharingOrderID)
	var i ProfitSharingOrder
	err := row.Scan(
		&i.ID,
		&i.PaymentOrderID,
		&i.MerchantID,
		&i.OperatorID,
		&i.OrderSource,
		&i.TotalAmount,
		&i.PlatformCommission,
		&i.OperatorCommission,
		&i.MerchantAmount,
		&i.OutOrderNo,
		&i.SharingOrderID,
		&i.Status,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.DeliveryFee,
		&i.RiderID,
		&i.RiderAmount,
		&i.DistributableAmount,
		&i.PlatformRate,
		&i.OperatorRate,
	)
	return i, err
}
