// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: region.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRegion = `-- name: CreateRegion :one
INSERT INTO regions (
  code,
  name,
  level,
  parent_id,
  longitude,
  latitude
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id
`

type CreateRegionParams struct {
	Code      string         `json:"code"`
	Name      string         `json:"name"`
	Level     int16          `json:"level"`
	ParentID  pgtype.Int8    `json:"parent_id"`
	Longitude pgtype.Numeric `json:"longitude"`
	Latitude  pgtype.Numeric `json:"latitude"`
}

func (q *Queries) CreateRegion(ctx context.Context, arg CreateRegionParams) (Region, error) {
	row := q.db.QueryRow(ctx, createRegion,
		arg.Code,
		arg.Name,
		arg.Level,
		arg.ParentID,
		arg.Longitude,
		arg.Latitude,
	)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Level,
		&i.ParentID,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.QweatherLocationID,
	)
	return i, err
}

const deleteRegion = `-- name: DeleteRegion :exec
DELETE FROM regions
WHERE id = $1
`

func (q *Queries) DeleteRegion(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRegion, id)
	return err
}

const getClosestRegion = `-- name: GetClosestRegion :one
SELECT id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id FROM regions
WHERE level = 3
ORDER BY (
    6371000 * acos(
        cos(radians($1::float8)) * cos(radians(latitude)) * 
        cos(radians(longitude) - radians($2::float8)) + 
        sin(radians($1::float8)) * sin(radians(latitude))
    )
) ASC
LIMIT 1
`

type GetClosestRegionParams struct {
	Lat float64 `json:"lat"`
	Lon float64 `json:"lon"`
}

// 根据经纬度获取最近的区县级区域
func (q *Queries) GetClosestRegion(ctx context.Context, arg GetClosestRegionParams) (Region, error) {
	row := q.db.QueryRow(ctx, getClosestRegion, arg.Lat, arg.Lon)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Level,
		&i.ParentID,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.QweatherLocationID,
	)
	return i, err
}

const getRegion = `-- name: GetRegion :one
SELECT id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id FROM regions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRegion(ctx context.Context, id int64) (Region, error) {
	row := q.db.QueryRow(ctx, getRegion, id)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Level,
		&i.ParentID,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.QweatherLocationID,
	)
	return i, err
}

const getRegionByCode = `-- name: GetRegionByCode :one
SELECT id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id FROM regions
WHERE code = $1 LIMIT 1
`

func (q *Queries) GetRegionByCode(ctx context.Context, code string) (Region, error) {
	row := q.db.QueryRow(ctx, getRegionByCode, code)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Level,
		&i.ParentID,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.QweatherLocationID,
	)
	return i, err
}

const getRegionsWithDeliveryFeeConfig = `-- name: GetRegionsWithDeliveryFeeConfig :many
SELECT 
  r.id,
  r.name,
  r.qweather_location_id,
  p.name as city_name
FROM regions r
JOIN delivery_fee_configs dfc ON r.id = dfc.region_id
LEFT JOIN regions p ON r.parent_id = p.id
WHERE dfc.is_active = true
`

type GetRegionsWithDeliveryFeeConfigRow struct {
	ID                 int64       `json:"id"`
	Name               string      `json:"name"`
	QweatherLocationID pgtype.Text `json:"qweather_location_id"`
	CityName           pgtype.Text `json:"city_name"`
}

// 获取已开通运费配置的区县（带市名，用于天气抓取）
func (q *Queries) GetRegionsWithDeliveryFeeConfig(ctx context.Context) ([]GetRegionsWithDeliveryFeeConfigRow, error) {
	rows, err := q.db.Query(ctx, getRegionsWithDeliveryFeeConfig)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionsWithDeliveryFeeConfigRow{}
	for rows.Next() {
		var i GetRegionsWithDeliveryFeeConfigRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.QweatherLocationID,
			&i.CityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailableRegions = `-- name: ListAvailableRegions :many
SELECT 
  r.id, r.code, r.name, r.level, r.parent_id, r.longitude, r.latitude, r.created_at, r.qweather_location_id,
  p.name as parent_name
FROM regions r
LEFT JOIN regions p ON r.parent_id = p.id
WHERE 
  NOT EXISTS (
    SELECT 1 FROM operators o WHERE o.region_id = r.id
  )
  AND CASE 
    WHEN $3::bigint IS NULL THEN TRUE
    ELSE r.parent_id = $3
  END
  AND CASE
    WHEN $4::smallint IS NULL THEN r.level = 3
    ELSE r.level = $4
  END
ORDER BY r.id
LIMIT $1
OFFSET $2
`

type ListAvailableRegionsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	ParentID pgtype.Int8 `json:"parent_id"`
	Level    pgtype.Int2 `json:"level"`
}

type ListAvailableRegionsRow struct {
	ID                 int64          `json:"id"`
	Code               string         `json:"code"`
	Name               string         `json:"name"`
	Level              int16          `json:"level"`
	ParentID           pgtype.Int8    `json:"parent_id"`
	Longitude          pgtype.Numeric `json:"longitude"`
	Latitude           pgtype.Numeric `json:"latitude"`
	CreatedAt          time.Time      `json:"created_at"`
	QweatherLocationID pgtype.Text    `json:"qweather_location_id"`
	ParentName         pgtype.Text    `json:"parent_name"`
}

// 获取未被运营商占用的区域列表（优化：避免 N+1 查询）
func (q *Queries) ListAvailableRegions(ctx context.Context, arg ListAvailableRegionsParams) ([]ListAvailableRegionsRow, error) {
	rows, err := q.db.Query(ctx, listAvailableRegions,
		arg.Limit,
		arg.Offset,
		arg.ParentID,
		arg.Level,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAvailableRegionsRow{}
	for rows.Next() {
		var i ListAvailableRegionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Level,
			&i.ParentID,
			&i.Longitude,
			&i.Latitude,
			&i.CreatedAt,
			&i.QweatherLocationID,
			&i.ParentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegionChildren = `-- name: ListRegionChildren :many
SELECT id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id FROM regions
WHERE parent_id = $1
ORDER BY id
`

func (q *Queries) ListRegionChildren(ctx context.Context, parentID pgtype.Int8) ([]Region, error) {
	rows, err := q.db.Query(ctx, listRegionChildren, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Region{}
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Level,
			&i.ParentID,
			&i.Longitude,
			&i.Latitude,
			&i.CreatedAt,
			&i.QweatherLocationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegions = `-- name: ListRegions :many
SELECT id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id FROM regions
WHERE 
  CASE 
    WHEN $3::bigint IS NULL THEN parent_id IS NULL
    ELSE parent_id = $3
  END
  AND CASE
    WHEN $4::smallint IS NULL THEN TRUE
    ELSE level = $4
  END
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListRegionsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	ParentID pgtype.Int8 `json:"parent_id"`
	Level    pgtype.Int2 `json:"level"`
}

func (q *Queries) ListRegions(ctx context.Context, arg ListRegionsParams) ([]Region, error) {
	rows, err := q.db.Query(ctx, listRegions,
		arg.Limit,
		arg.Offset,
		arg.ParentID,
		arg.Level,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Region{}
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Level,
			&i.ParentID,
			&i.Longitude,
			&i.Latitude,
			&i.CreatedAt,
			&i.QweatherLocationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRegionsByName = `-- name: SearchRegionsByName :many
SELECT id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id FROM regions
WHERE name LIKE '%' || $1 || '%'
ORDER BY level, id
LIMIT $2
`

type SearchRegionsByNameParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) SearchRegionsByName(ctx context.Context, arg SearchRegionsByNameParams) ([]Region, error) {
	rows, err := q.db.Query(ctx, searchRegionsByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Region{}
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Level,
			&i.ParentID,
			&i.Longitude,
			&i.Latitude,
			&i.CreatedAt,
			&i.QweatherLocationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRegion = `-- name: UpdateRegion :one
UPDATE regions
SET
  name = COALESCE($1, name),
  longitude = COALESCE($2, longitude),
  latitude = COALESCE($3, latitude)
WHERE id = $4
RETURNING id, code, name, level, parent_id, longitude, latitude, created_at, qweather_location_id
`

type UpdateRegionParams struct {
	Name      pgtype.Text    `json:"name"`
	Longitude pgtype.Numeric `json:"longitude"`
	Latitude  pgtype.Numeric `json:"latitude"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateRegion(ctx context.Context, arg UpdateRegionParams) (Region, error) {
	row := q.db.QueryRow(ctx, updateRegion,
		arg.Name,
		arg.Longitude,
		arg.Latitude,
		arg.ID,
	)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Level,
		&i.ParentID,
		&i.Longitude,
		&i.Latitude,
		&i.CreatedAt,
		&i.QweatherLocationID,
	)
	return i, err
}

const updateRegionQweatherLocationID = `-- name: UpdateRegionQweatherLocationID :exec
UPDATE regions 
SET qweather_location_id = $2 
WHERE id = $1
`

type UpdateRegionQweatherLocationIDParams struct {
	ID                 int64       `json:"id"`
	QweatherLocationID pgtype.Text `json:"qweather_location_id"`
}

// 更新区县的和风天气 LocationID（首次查询后缓存）
func (q *Queries) UpdateRegionQweatherLocationID(ctx context.Context, arg UpdateRegionQweatherLocationIDParams) error {
	_, err := q.db.Exec(ctx, updateRegionQweatherLocationID, arg.ID, arg.QweatherLocationID)
	return err
}
