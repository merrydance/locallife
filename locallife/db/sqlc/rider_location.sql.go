// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rider_location.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateRiderLocationsParams struct {
	RiderID    int64          `json:"rider_id"`
	DeliveryID pgtype.Int8    `json:"delivery_id"`
	Longitude  pgtype.Numeric `json:"longitude"`
	Latitude   pgtype.Numeric `json:"latitude"`
	Accuracy   pgtype.Numeric `json:"accuracy"`
	Speed      pgtype.Numeric `json:"speed"`
	Heading    pgtype.Numeric `json:"heading"`
	RecordedAt time.Time      `json:"recorded_at"`
}

const countRiderLocations = `-- name: CountRiderLocations :one
SELECT COUNT(*) FROM rider_locations
WHERE rider_id = $1
`

func (q *Queries) CountRiderLocations(ctx context.Context, riderID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countRiderLocations, riderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRiderLocation = `-- name: CreateRiderLocation :one
INSERT INTO rider_locations (
    rider_id,
    delivery_id,
    longitude,
    latitude,
    accuracy,
    speed,
    heading,
    recorded_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, rider_id, delivery_id, longitude, latitude, accuracy, speed, heading, recorded_at
`

type CreateRiderLocationParams struct {
	RiderID    int64          `json:"rider_id"`
	DeliveryID pgtype.Int8    `json:"delivery_id"`
	Longitude  pgtype.Numeric `json:"longitude"`
	Latitude   pgtype.Numeric `json:"latitude"`
	Accuracy   pgtype.Numeric `json:"accuracy"`
	Speed      pgtype.Numeric `json:"speed"`
	Heading    pgtype.Numeric `json:"heading"`
	RecordedAt time.Time      `json:"recorded_at"`
}

func (q *Queries) CreateRiderLocation(ctx context.Context, arg CreateRiderLocationParams) (RiderLocation, error) {
	row := q.db.QueryRow(ctx, createRiderLocation,
		arg.RiderID,
		arg.DeliveryID,
		arg.Longitude,
		arg.Latitude,
		arg.Accuracy,
		arg.Speed,
		arg.Heading,
		arg.RecordedAt,
	)
	var i RiderLocation
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DeliveryID,
		&i.Longitude,
		&i.Latitude,
		&i.Accuracy,
		&i.Speed,
		&i.Heading,
		&i.RecordedAt,
	)
	return i, err
}

const deleteOldRiderLocations = `-- name: DeleteOldRiderLocations :exec
DELETE FROM rider_locations
WHERE recorded_at < $1
`

func (q *Queries) DeleteOldRiderLocations(ctx context.Context, recordedAt time.Time) error {
	_, err := q.db.Exec(ctx, deleteOldRiderLocations, recordedAt)
	return err
}

const getDeliveryLatestLocation = `-- name: GetDeliveryLatestLocation :one
SELECT id, rider_id, delivery_id, longitude, latitude, accuracy, speed, heading, recorded_at FROM rider_locations
WHERE delivery_id = $1
ORDER BY recorded_at DESC
LIMIT 1
`

func (q *Queries) GetDeliveryLatestLocation(ctx context.Context, deliveryID pgtype.Int8) (RiderLocation, error) {
	row := q.db.QueryRow(ctx, getDeliveryLatestLocation, deliveryID)
	var i RiderLocation
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DeliveryID,
		&i.Longitude,
		&i.Latitude,
		&i.Accuracy,
		&i.Speed,
		&i.Heading,
		&i.RecordedAt,
	)
	return i, err
}

const getRiderLatestLocation = `-- name: GetRiderLatestLocation :one
SELECT id, rider_id, delivery_id, longitude, latitude, accuracy, speed, heading, recorded_at FROM rider_locations
WHERE rider_id = $1
ORDER BY recorded_at DESC
LIMIT 1
`

func (q *Queries) GetRiderLatestLocation(ctx context.Context, riderID int64) (RiderLocation, error) {
	row := q.db.QueryRow(ctx, getRiderLatestLocation, riderID)
	var i RiderLocation
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DeliveryID,
		&i.Longitude,
		&i.Latitude,
		&i.Accuracy,
		&i.Speed,
		&i.Heading,
		&i.RecordedAt,
	)
	return i, err
}

const listDeliveryLocations = `-- name: ListDeliveryLocations :many
SELECT id, rider_id, delivery_id, longitude, latitude, accuracy, speed, heading, recorded_at FROM rider_locations
WHERE delivery_id = $1
ORDER BY recorded_at ASC
`

func (q *Queries) ListDeliveryLocations(ctx context.Context, deliveryID pgtype.Int8) ([]RiderLocation, error) {
	rows, err := q.db.Query(ctx, listDeliveryLocations, deliveryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderLocation{}
	for rows.Next() {
		var i RiderLocation
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.DeliveryID,
			&i.Longitude,
			&i.Latitude,
			&i.Accuracy,
			&i.Speed,
			&i.Heading,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryLocationsSince = `-- name: ListDeliveryLocationsSince :many
SELECT id, rider_id, delivery_id, longitude, latitude, accuracy, speed, heading, recorded_at FROM rider_locations
WHERE delivery_id = $1
    AND recorded_at > $2
ORDER BY recorded_at ASC
`

type ListDeliveryLocationsSinceParams struct {
	DeliveryID pgtype.Int8 `json:"delivery_id"`
	RecordedAt time.Time   `json:"recorded_at"`
}

func (q *Queries) ListDeliveryLocationsSince(ctx context.Context, arg ListDeliveryLocationsSinceParams) ([]RiderLocation, error) {
	rows, err := q.db.Query(ctx, listDeliveryLocationsSince, arg.DeliveryID, arg.RecordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderLocation{}
	for rows.Next() {
		var i RiderLocation
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.DeliveryID,
			&i.Longitude,
			&i.Latitude,
			&i.Accuracy,
			&i.Speed,
			&i.Heading,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderLocations = `-- name: ListRiderLocations :many
SELECT id, rider_id, delivery_id, longitude, latitude, accuracy, speed, heading, recorded_at FROM rider_locations
WHERE rider_id = $1
    AND recorded_at >= $2
    AND recorded_at <= $3
ORDER BY recorded_at ASC
`

type ListRiderLocationsParams struct {
	RiderID      int64     `json:"rider_id"`
	RecordedAt   time.Time `json:"recorded_at"`
	RecordedAt_2 time.Time `json:"recorded_at_2"`
}

func (q *Queries) ListRiderLocations(ctx context.Context, arg ListRiderLocationsParams) ([]RiderLocation, error) {
	rows, err := q.db.Query(ctx, listRiderLocations, arg.RiderID, arg.RecordedAt, arg.RecordedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderLocation{}
	for rows.Next() {
		var i RiderLocation
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.DeliveryID,
			&i.Longitude,
			&i.Latitude,
			&i.Accuracy,
			&i.Speed,
			&i.Heading,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
