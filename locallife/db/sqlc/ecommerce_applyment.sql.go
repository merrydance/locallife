// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ecommerce_applyment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEcommerceApplymentsByStatus = `-- name: CountEcommerceApplymentsByStatus :one
SELECT COUNT(*) FROM ecommerce_applyments
WHERE status = $1
`

func (q *Queries) CountEcommerceApplymentsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countEcommerceApplymentsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEcommerceApplyment = `-- name: CreateEcommerceApplyment :one
INSERT INTO ecommerce_applyments (
    subject_type,
    subject_id,
    out_request_no,
    organization_type,
    business_license_number,
    business_license_copy,
    merchant_name,
    legal_person,
    id_card_number,
    id_card_name,
    id_card_valid_time,
    id_card_front_copy,
    id_card_back_copy,
    account_type,
    account_bank,
    bank_address_code,
    bank_name,
    account_number,
    account_name,
    contact_name,
    contact_id_card_number,
    mobile_phone,
    contact_email,
    merchant_shortname,
    qualifications,
    business_addition_pics,
    business_addition_desc,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, 'pending'
) RETURNING id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at
`

type CreateEcommerceApplymentParams struct {
	SubjectType           string      `json:"subject_type"`
	SubjectID             int64       `json:"subject_id"`
	OutRequestNo          string      `json:"out_request_no"`
	OrganizationType      string      `json:"organization_type"`
	BusinessLicenseNumber pgtype.Text `json:"business_license_number"`
	BusinessLicenseCopy   pgtype.Text `json:"business_license_copy"`
	MerchantName          string      `json:"merchant_name"`
	LegalPerson           string      `json:"legal_person"`
	IDCardNumber          string      `json:"id_card_number"`
	IDCardName            string      `json:"id_card_name"`
	IDCardValidTime       string      `json:"id_card_valid_time"`
	IDCardFrontCopy       string      `json:"id_card_front_copy"`
	IDCardBackCopy        string      `json:"id_card_back_copy"`
	AccountType           string      `json:"account_type"`
	AccountBank           string      `json:"account_bank"`
	BankAddressCode       string      `json:"bank_address_code"`
	BankName              pgtype.Text `json:"bank_name"`
	AccountNumber         string      `json:"account_number"`
	AccountName           string      `json:"account_name"`
	ContactName           string      `json:"contact_name"`
	ContactIDCardNumber   pgtype.Text `json:"contact_id_card_number"`
	MobilePhone           string      `json:"mobile_phone"`
	ContactEmail          pgtype.Text `json:"contact_email"`
	MerchantShortname     string      `json:"merchant_shortname"`
	Qualifications        []byte      `json:"qualifications"`
	BusinessAdditionPics  []string    `json:"business_addition_pics"`
	BusinessAdditionDesc  pgtype.Text `json:"business_addition_desc"`
}

func (q *Queries) CreateEcommerceApplyment(ctx context.Context, arg CreateEcommerceApplymentParams) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, createEcommerceApplyment,
		arg.SubjectType,
		arg.SubjectID,
		arg.OutRequestNo,
		arg.OrganizationType,
		arg.BusinessLicenseNumber,
		arg.BusinessLicenseCopy,
		arg.MerchantName,
		arg.LegalPerson,
		arg.IDCardNumber,
		arg.IDCardName,
		arg.IDCardValidTime,
		arg.IDCardFrontCopy,
		arg.IDCardBackCopy,
		arg.AccountType,
		arg.AccountBank,
		arg.BankAddressCode,
		arg.BankName,
		arg.AccountNumber,
		arg.AccountName,
		arg.ContactName,
		arg.ContactIDCardNumber,
		arg.MobilePhone,
		arg.ContactEmail,
		arg.MerchantShortname,
		arg.Qualifications,
		arg.BusinessAdditionPics,
		arg.BusinessAdditionDesc,
	)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEcommerceApplyment = `-- name: GetEcommerceApplyment :one
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEcommerceApplyment(ctx context.Context, id int64) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, getEcommerceApplyment, id)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEcommerceApplymentByApplymentID = `-- name: GetEcommerceApplymentByApplymentID :one
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE applyment_id = $1 LIMIT 1
`

func (q *Queries) GetEcommerceApplymentByApplymentID(ctx context.Context, applymentID pgtype.Int8) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, getEcommerceApplymentByApplymentID, applymentID)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEcommerceApplymentByOutRequestNo = `-- name: GetEcommerceApplymentByOutRequestNo :one
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE out_request_no = $1 LIMIT 1
`

func (q *Queries) GetEcommerceApplymentByOutRequestNo(ctx context.Context, outRequestNo string) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, getEcommerceApplymentByOutRequestNo, outRequestNo)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEcommerceApplymentBySubject = `-- name: GetEcommerceApplymentBySubject :one
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE subject_type = $1 AND subject_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetEcommerceApplymentBySubjectParams struct {
	SubjectType string `json:"subject_type"`
	SubjectID   int64  `json:"subject_id"`
}

func (q *Queries) GetEcommerceApplymentBySubject(ctx context.Context, arg GetEcommerceApplymentBySubjectParams) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, getEcommerceApplymentBySubject, arg.SubjectType, arg.SubjectID)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestEcommerceApplymentBySubject = `-- name: GetLatestEcommerceApplymentBySubject :one
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE subject_type = $1 AND subject_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestEcommerceApplymentBySubjectParams struct {
	SubjectType string `json:"subject_type"`
	SubjectID   int64  `json:"subject_id"`
}

func (q *Queries) GetLatestEcommerceApplymentBySubject(ctx context.Context, arg GetLatestEcommerceApplymentBySubjectParams) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, getLatestEcommerceApplymentBySubject, arg.SubjectType, arg.SubjectID)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEcommerceApplymentsByStatus = `-- name: ListEcommerceApplymentsByStatus :many
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEcommerceApplymentsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListEcommerceApplymentsByStatus(ctx context.Context, arg ListEcommerceApplymentsByStatusParams) ([]EcommerceApplyment, error) {
	rows, err := q.db.Query(ctx, listEcommerceApplymentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EcommerceApplyment{}
	for rows.Next() {
		var i EcommerceApplyment
		if err := rows.Scan(
			&i.ID,
			&i.SubjectType,
			&i.SubjectID,
			&i.OutRequestNo,
			&i.ApplymentID,
			&i.OrganizationType,
			&i.BusinessLicenseNumber,
			&i.BusinessLicenseCopy,
			&i.MerchantName,
			&i.LegalPerson,
			&i.IDCardNumber,
			&i.IDCardName,
			&i.IDCardValidTime,
			&i.IDCardFrontCopy,
			&i.IDCardBackCopy,
			&i.AccountType,
			&i.AccountBank,
			&i.BankAddressCode,
			&i.BankName,
			&i.AccountNumber,
			&i.AccountName,
			&i.ContactName,
			&i.ContactIDCardNumber,
			&i.MobilePhone,
			&i.ContactEmail,
			&i.MerchantShortname,
			&i.Qualifications,
			&i.BusinessAdditionPics,
			&i.BusinessAdditionDesc,
			&i.Status,
			&i.SignUrl,
			&i.SignState,
			&i.RejectReason,
			&i.SubMchID,
			&i.CreatedAt,
			&i.SubmittedAt,
			&i.AuditedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEcommerceApplymentsBySubject = `-- name: ListEcommerceApplymentsBySubject :many
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE subject_type = $1 AND subject_id = $2
ORDER BY created_at DESC
`

type ListEcommerceApplymentsBySubjectParams struct {
	SubjectType string `json:"subject_type"`
	SubjectID   int64  `json:"subject_id"`
}

func (q *Queries) ListEcommerceApplymentsBySubject(ctx context.Context, arg ListEcommerceApplymentsBySubjectParams) ([]EcommerceApplyment, error) {
	rows, err := q.db.Query(ctx, listEcommerceApplymentsBySubject, arg.SubjectType, arg.SubjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EcommerceApplyment{}
	for rows.Next() {
		var i EcommerceApplyment
		if err := rows.Scan(
			&i.ID,
			&i.SubjectType,
			&i.SubjectID,
			&i.OutRequestNo,
			&i.ApplymentID,
			&i.OrganizationType,
			&i.BusinessLicenseNumber,
			&i.BusinessLicenseCopy,
			&i.MerchantName,
			&i.LegalPerson,
			&i.IDCardNumber,
			&i.IDCardName,
			&i.IDCardValidTime,
			&i.IDCardFrontCopy,
			&i.IDCardBackCopy,
			&i.AccountType,
			&i.AccountBank,
			&i.BankAddressCode,
			&i.BankName,
			&i.AccountNumber,
			&i.AccountName,
			&i.ContactName,
			&i.ContactIDCardNumber,
			&i.MobilePhone,
			&i.ContactEmail,
			&i.MerchantShortname,
			&i.Qualifications,
			&i.BusinessAdditionPics,
			&i.BusinessAdditionDesc,
			&i.Status,
			&i.SignUrl,
			&i.SignState,
			&i.RejectReason,
			&i.SubMchID,
			&i.CreatedAt,
			&i.SubmittedAt,
			&i.AuditedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingEcommerceApplyments = `-- name: ListPendingEcommerceApplyments :many
SELECT id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at FROM ecommerce_applyments
WHERE status IN ('submitted', 'auditing', 'to_be_signed', 'signing')
ORDER BY created_at ASC
LIMIT $1 OFFSET $2
`

type ListPendingEcommerceApplymentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPendingEcommerceApplyments(ctx context.Context, arg ListPendingEcommerceApplymentsParams) ([]EcommerceApplyment, error) {
	rows, err := q.db.Query(ctx, listPendingEcommerceApplyments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EcommerceApplyment{}
	for rows.Next() {
		var i EcommerceApplyment
		if err := rows.Scan(
			&i.ID,
			&i.SubjectType,
			&i.SubjectID,
			&i.OutRequestNo,
			&i.ApplymentID,
			&i.OrganizationType,
			&i.BusinessLicenseNumber,
			&i.BusinessLicenseCopy,
			&i.MerchantName,
			&i.LegalPerson,
			&i.IDCardNumber,
			&i.IDCardName,
			&i.IDCardValidTime,
			&i.IDCardFrontCopy,
			&i.IDCardBackCopy,
			&i.AccountType,
			&i.AccountBank,
			&i.BankAddressCode,
			&i.BankName,
			&i.AccountNumber,
			&i.AccountName,
			&i.ContactName,
			&i.ContactIDCardNumber,
			&i.MobilePhone,
			&i.ContactEmail,
			&i.MerchantShortname,
			&i.Qualifications,
			&i.BusinessAdditionPics,
			&i.BusinessAdditionDesc,
			&i.Status,
			&i.SignUrl,
			&i.SignState,
			&i.RejectReason,
			&i.SubMchID,
			&i.CreatedAt,
			&i.SubmittedAt,
			&i.AuditedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEcommerceApplymentStatus = `-- name: UpdateEcommerceApplymentStatus :one
UPDATE ecommerce_applyments
SET
    status = $2,
    reject_reason = $3,
    sign_url = $4,
    sign_state = $5,
    sub_mch_id = $6,
    audited_at = CASE WHEN $2 IN ('rejected', 'frozen', 'to_be_signed', 'finish') THEN now() ELSE audited_at END,
    updated_at = now()
WHERE id = $1
RETURNING id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at
`

type UpdateEcommerceApplymentStatusParams struct {
	ID           int64       `json:"id"`
	Status       string      `json:"status"`
	RejectReason pgtype.Text `json:"reject_reason"`
	SignUrl      pgtype.Text `json:"sign_url"`
	SignState    pgtype.Text `json:"sign_state"`
	SubMchID     pgtype.Text `json:"sub_mch_id"`
}

func (q *Queries) UpdateEcommerceApplymentStatus(ctx context.Context, arg UpdateEcommerceApplymentStatusParams) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, updateEcommerceApplymentStatus,
		arg.ID,
		arg.Status,
		arg.RejectReason,
		arg.SignUrl,
		arg.SignState,
		arg.SubMchID,
	)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEcommerceApplymentSubMchID = `-- name: UpdateEcommerceApplymentSubMchID :one
UPDATE ecommerce_applyments
SET
    sub_mch_id = $2,
    status = 'finish',
    audited_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at
`

type UpdateEcommerceApplymentSubMchIDParams struct {
	ID       int64       `json:"id"`
	SubMchID pgtype.Text `json:"sub_mch_id"`
}

func (q *Queries) UpdateEcommerceApplymentSubMchID(ctx context.Context, arg UpdateEcommerceApplymentSubMchIDParams) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, updateEcommerceApplymentSubMchID, arg.ID, arg.SubMchID)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEcommerceApplymentToSubmitted = `-- name: UpdateEcommerceApplymentToSubmitted :one
UPDATE ecommerce_applyments
SET
    applyment_id = $2,
    status = 'submitted',
    submitted_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, subject_type, subject_id, out_request_no, applyment_id, organization_type, business_license_number, business_license_copy, merchant_name, legal_person, id_card_number, id_card_name, id_card_valid_time, id_card_front_copy, id_card_back_copy, account_type, account_bank, bank_address_code, bank_name, account_number, account_name, contact_name, contact_id_card_number, mobile_phone, contact_email, merchant_shortname, qualifications, business_addition_pics, business_addition_desc, status, sign_url, sign_state, reject_reason, sub_mch_id, created_at, submitted_at, audited_at, updated_at
`

type UpdateEcommerceApplymentToSubmittedParams struct {
	ID          int64       `json:"id"`
	ApplymentID pgtype.Int8 `json:"applyment_id"`
}

func (q *Queries) UpdateEcommerceApplymentToSubmitted(ctx context.Context, arg UpdateEcommerceApplymentToSubmittedParams) (EcommerceApplyment, error) {
	row := q.db.QueryRow(ctx, updateEcommerceApplymentToSubmitted, arg.ID, arg.ApplymentID)
	var i EcommerceApplyment
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.OutRequestNo,
		&i.ApplymentID,
		&i.OrganizationType,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseCopy,
		&i.MerchantName,
		&i.LegalPerson,
		&i.IDCardNumber,
		&i.IDCardName,
		&i.IDCardValidTime,
		&i.IDCardFrontCopy,
		&i.IDCardBackCopy,
		&i.AccountType,
		&i.AccountBank,
		&i.BankAddressCode,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountName,
		&i.ContactName,
		&i.ContactIDCardNumber,
		&i.MobilePhone,
		&i.ContactEmail,
		&i.MerchantShortname,
		&i.Qualifications,
		&i.BusinessAdditionPics,
		&i.BusinessAdditionDesc,
		&i.Status,
		&i.SignUrl,
		&i.SignState,
		&i.RejectReason,
		&i.SubMchID,
		&i.CreatedAt,
		&i.SubmittedAt,
		&i.AuditedAt,
		&i.UpdatedAt,
	)
	return i, err
}
