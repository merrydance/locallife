// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operator_stats.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOperatorMerchantRanking = `-- name: GetOperatorMerchantRanking :many
SELECT 
    m.id AS merchant_id,
    m.name AS merchant_name,
    COUNT(ps.id)::int AS order_count,
    COALESCE(SUM(ps.total_amount), 0)::bigint AS total_sales,
    COALESCE(SUM(ps.platform_commission), 0)::bigint AS commission,
    CASE 
        WHEN COUNT(ps.id) > 0 
        THEN (COALESCE(SUM(ps.total_amount), 0) / COUNT(ps.id))::bigint
        ELSE 0
    END AS avg_order_amount
FROM merchants m
LEFT JOIN profit_sharing_orders ps ON ps.merchant_id = m.id 
    AND ps.created_at >= $2
    AND ps.created_at <= $3
    AND ps.status = 'finished'  -- 只统计分账成功的订单
WHERE m.region_id = $1
  AND m.status = 'approved'
GROUP BY m.id, m.name
ORDER BY total_sales DESC
LIMIT $4 OFFSET $5
`

type GetOperatorMerchantRankingParams struct {
	RegionID    int64     `json:"region_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetOperatorMerchantRankingRow struct {
	MerchantID     int64  `json:"merchant_id"`
	MerchantName   string `json:"merchant_name"`
	OrderCount     int32  `json:"order_count"`
	TotalSales     int64  `json:"total_sales"`
	Commission     int64  `json:"commission"`
	AvgOrderAmount int32  `json:"avg_order_amount"`
}

// 运营商区域内商户排行（基于实际分账数据）
func (q *Queries) GetOperatorMerchantRanking(ctx context.Context, arg GetOperatorMerchantRankingParams) ([]GetOperatorMerchantRankingRow, error) {
	rows, err := q.db.Query(ctx, getOperatorMerchantRanking,
		arg.RegionID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOperatorMerchantRankingRow{}
	for rows.Next() {
		var i GetOperatorMerchantRankingRow
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantName,
			&i.OrderCount,
			&i.TotalSales,
			&i.Commission,
			&i.AvgOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperatorRiderRanking = `-- name: GetOperatorRiderRanking :many
SELECT 
    r.id AS rider_id,
    u.full_name AS rider_name,
    COUNT(d.id)::int AS delivery_count,
    COUNT(CASE WHEN d.status = 'completed' THEN 1 END)::int AS completed_count,
    COALESCE(AVG(EXTRACT(EPOCH FROM (d.delivered_at - d.picked_at))), 0)::int AS avg_delivery_time,
    r.total_earnings
FROM riders r
JOIN users u ON u.id = r.user_id
LEFT JOIN deliveries d ON d.rider_id = r.id 
    AND d.created_at >= $2
    AND d.created_at <= $3
LEFT JOIN orders o ON o.id = d.order_id
LEFT JOIN merchants m ON m.id = o.merchant_id
WHERE m.region_id = $1
  AND r.status = 'active'
GROUP BY r.id, u.full_name, r.total_earnings
HAVING COUNT(d.id) > 0
ORDER BY completed_count DESC
LIMIT $4 OFFSET $5
`

type GetOperatorRiderRankingParams struct {
	RegionID    int64     `json:"region_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetOperatorRiderRankingRow struct {
	RiderID         int64  `json:"rider_id"`
	RiderName       string `json:"rider_name"`
	DeliveryCount   int32  `json:"delivery_count"`
	CompletedCount  int32  `json:"completed_count"`
	AvgDeliveryTime int32  `json:"avg_delivery_time"`
	TotalEarnings   int64  `json:"total_earnings"`
}

// 运营商区域内骑手绩效排行(通过配送订单关联区域)
func (q *Queries) GetOperatorRiderRanking(ctx context.Context, arg GetOperatorRiderRankingParams) ([]GetOperatorRiderRankingRow, error) {
	rows, err := q.db.Query(ctx, getOperatorRiderRanking,
		arg.RegionID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOperatorRiderRankingRow{}
	for rows.Next() {
		var i GetOperatorRiderRankingRow
		if err := rows.Scan(
			&i.RiderID,
			&i.RiderName,
			&i.DeliveryCount,
			&i.CompletedCount,
			&i.AvgDeliveryTime,
			&i.TotalEarnings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionDailyTrend = `-- name: GetRegionDailyTrend :many
SELECT 
    DATE(ps.created_at) AS date,
    COUNT(ps.id)::int AS order_count,
    COALESCE(SUM(ps.total_amount), 0)::bigint AS total_gmv,
    COALESCE(SUM(ps.platform_commission), 0)::bigint AS commission,
    COUNT(DISTINCT po.user_id)::int AS active_users,
    COUNT(DISTINCT ps.merchant_id)::int AS active_merchants
FROM profit_sharing_orders ps
JOIN merchants m ON m.id = ps.merchant_id
JOIN payment_orders po ON po.id = ps.payment_order_id
WHERE m.region_id = $1
  AND ps.created_at >= $2
  AND ps.created_at <= $3
  AND ps.status = 'finished'  -- 只统计分账成功的订单
GROUP BY DATE(ps.created_at)
ORDER BY date
`

type GetRegionDailyTrendParams struct {
	RegionID    int64     `json:"region_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetRegionDailyTrendRow struct {
	Date            pgtype.Date `json:"date"`
	OrderCount      int32       `json:"order_count"`
	TotalGmv        int64       `json:"total_gmv"`
	Commission      int64       `json:"commission"`
	ActiveUsers     int32       `json:"active_users"`
	ActiveMerchants int32       `json:"active_merchants"`
}

// 区域日趋势（基于实际分账数据）
func (q *Queries) GetRegionDailyTrend(ctx context.Context, arg GetRegionDailyTrendParams) ([]GetRegionDailyTrendRow, error) {
	rows, err := q.db.Query(ctx, getRegionDailyTrend, arg.RegionID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionDailyTrendRow{}
	for rows.Next() {
		var i GetRegionDailyTrendRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderCount,
			&i.TotalGmv,
			&i.Commission,
			&i.ActiveUsers,
			&i.ActiveMerchants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionStats = `-- name: GetRegionStats :one

SELECT 
    r.id AS region_id,
    r.name AS region_name,
    COUNT(DISTINCT m.id)::int AS merchant_count,
    COUNT(DISTINCT ps.id)::int AS total_orders,
    COALESCE(SUM(ps.total_amount), 0)::bigint AS total_gmv,
    COALESCE(SUM(ps.platform_commission), 0)::bigint AS total_commission
FROM regions r
LEFT JOIN merchants m ON m.region_id = r.id AND m.status = 'approved'
LEFT JOIN profit_sharing_orders ps ON ps.merchant_id = m.id 
    AND ps.created_at >= $2
    AND ps.created_at <= $3
    AND ps.status = 'finished'  -- 只统计分账成功的订单
WHERE r.id = $1
GROUP BY r.id, r.name
`

type GetRegionStatsParams struct {
	ID          int64     `json:"id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetRegionStatsRow struct {
	RegionID        int64  `json:"region_id"`
	RegionName      string `json:"region_name"`
	MerchantCount   int32  `json:"merchant_count"`
	TotalOrders     int32  `json:"total_orders"`
	TotalGmv        int64  `json:"total_gmv"`
	TotalCommission int64  `json:"total_commission"`
}

// M12: 运营商统计查询
//
// 说明: 运营商结算通过微信电商分账系统实时处理，每笔订单支付时自动分账
// 运营商佣金数据从 profit_sharing_orders 表 (status='finished') 实时统计
// operator_settlements 表已废弃删除，因为分账是实时的，不需要手动创建月度结算
// 区域统计：基于实际完成分账的数据（status='finished'）
// 这样确保统计的佣金是真实分账成功的，而不是预估值
func (q *Queries) GetRegionStats(ctx context.Context, arg GetRegionStatsParams) (GetRegionStatsRow, error) {
	row := q.db.QueryRow(ctx, getRegionStats, arg.ID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetRegionStatsRow
	err := row.Scan(
		&i.RegionID,
		&i.RegionName,
		&i.MerchantCount,
		&i.TotalOrders,
		&i.TotalGmv,
		&i.TotalCommission,
	)
	return i, err
}
