// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: membership.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMembershipTransaction = `-- name: CreateMembershipTransaction :one

INSERT INTO membership_transactions (
    membership_id,
    type,
    amount,
    balance_after,
    related_order_id,
    recharge_rule_id,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, membership_id, type, amount, balance_after, related_order_id, recharge_rule_id, notes, created_at
`

type CreateMembershipTransactionParams struct {
	MembershipID   int64       `json:"membership_id"`
	Type           string      `json:"type"`
	Amount         int64       `json:"amount"`
	BalanceAfter   int64       `json:"balance_after"`
	RelatedOrderID pgtype.Int8 `json:"related_order_id"`
	RechargeRuleID pgtype.Int8 `json:"recharge_rule_id"`
	Notes          pgtype.Text `json:"notes"`
}

// Membership Transactions
func (q *Queries) CreateMembershipTransaction(ctx context.Context, arg CreateMembershipTransactionParams) (MembershipTransaction, error) {
	row := q.db.QueryRow(ctx, createMembershipTransaction,
		arg.MembershipID,
		arg.Type,
		arg.Amount,
		arg.BalanceAfter,
		arg.RelatedOrderID,
		arg.RechargeRuleID,
		arg.Notes,
	)
	var i MembershipTransaction
	err := row.Scan(
		&i.ID,
		&i.MembershipID,
		&i.Type,
		&i.Amount,
		&i.BalanceAfter,
		&i.RelatedOrderID,
		&i.RechargeRuleID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createMerchantMembership = `-- name: CreateMerchantMembership :one
INSERT INTO merchant_memberships (
    merchant_id,
    user_id
) VALUES (
    $1, $2
) RETURNING id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at
`

type CreateMerchantMembershipParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
}

func (q *Queries) CreateMerchantMembership(ctx context.Context, arg CreateMerchantMembershipParams) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, createMerchantMembership, arg.MerchantID, arg.UserID)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRechargeRule = `-- name: CreateRechargeRule :one

INSERT INTO recharge_rules (
    merchant_id,
    recharge_amount,
    bonus_amount,
    is_active,
    valid_from,
    valid_until
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, merchant_id, recharge_amount, bonus_amount, is_active, valid_from, valid_until, created_at, updated_at
`

type CreateRechargeRuleParams struct {
	MerchantID     int64     `json:"merchant_id"`
	RechargeAmount int64     `json:"recharge_amount"`
	BonusAmount    int64     `json:"bonus_amount"`
	IsActive       bool      `json:"is_active"`
	ValidFrom      time.Time `json:"valid_from"`
	ValidUntil     time.Time `json:"valid_until"`
}

// Recharge Rules
func (q *Queries) CreateRechargeRule(ctx context.Context, arg CreateRechargeRuleParams) (RechargeRule, error) {
	row := q.db.QueryRow(ctx, createRechargeRule,
		arg.MerchantID,
		arg.RechargeAmount,
		arg.BonusAmount,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i RechargeRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.RechargeAmount,
		&i.BonusAmount,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementMembershipBalance = `-- name: DecrementMembershipBalance :one
UPDATE merchant_memberships
SET 
    balance = balance - $2,
    total_consumed = total_consumed + $2,
    updated_at = NOW()
WHERE id = $1 AND balance >= $2
RETURNING id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at
`

type DecrementMembershipBalanceParams struct {
	ID      int64 `json:"id"`
	Balance int64 `json:"balance"`
}

func (q *Queries) DecrementMembershipBalance(ctx context.Context, arg DecrementMembershipBalanceParams) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, decrementMembershipBalance, arg.ID, arg.Balance)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRechargeRule = `-- name: DeleteRechargeRule :exec
DELETE FROM recharge_rules
WHERE id = $1
`

func (q *Queries) DeleteRechargeRule(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRechargeRule, id)
	return err
}

const getMatchingRechargeRule = `-- name: GetMatchingRechargeRule :one
SELECT id, merchant_id, recharge_amount, bonus_amount, is_active, valid_from, valid_until, created_at, updated_at FROM recharge_rules
WHERE merchant_id = $1 
    AND recharge_amount = $2
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
LIMIT 1
`

type GetMatchingRechargeRuleParams struct {
	MerchantID     int64 `json:"merchant_id"`
	RechargeAmount int64 `json:"recharge_amount"`
}

func (q *Queries) GetMatchingRechargeRule(ctx context.Context, arg GetMatchingRechargeRuleParams) (RechargeRule, error) {
	row := q.db.QueryRow(ctx, getMatchingRechargeRule, arg.MerchantID, arg.RechargeAmount)
	var i RechargeRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.RechargeAmount,
		&i.BonusAmount,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMembershipByMerchantAndUser = `-- name: GetMembershipByMerchantAndUser :one
SELECT id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at FROM merchant_memberships
WHERE merchant_id = $1 AND user_id = $2 LIMIT 1
`

type GetMembershipByMerchantAndUserParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
}

func (q *Queries) GetMembershipByMerchantAndUser(ctx context.Context, arg GetMembershipByMerchantAndUserParams) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, getMembershipByMerchantAndUser, arg.MerchantID, arg.UserID)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMembershipByMerchantAndUserForUpdate = `-- name: GetMembershipByMerchantAndUserForUpdate :one
SELECT id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at FROM merchant_memberships
WHERE merchant_id = $1 AND user_id = $2 LIMIT 1
FOR UPDATE
`

type GetMembershipByMerchantAndUserForUpdateParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
}

func (q *Queries) GetMembershipByMerchantAndUserForUpdate(ctx context.Context, arg GetMembershipByMerchantAndUserForUpdateParams) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, getMembershipByMerchantAndUserForUpdate, arg.MerchantID, arg.UserID)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMembershipForUpdate = `-- name: GetMembershipForUpdate :one
SELECT id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at FROM merchant_memberships
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetMembershipForUpdate(ctx context.Context, id int64) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, getMembershipForUpdate, id)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMembershipTransaction = `-- name: GetMembershipTransaction :one
SELECT id, membership_id, type, amount, balance_after, related_order_id, recharge_rule_id, notes, created_at FROM membership_transactions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMembershipTransaction(ctx context.Context, id int64) (MembershipTransaction, error) {
	row := q.db.QueryRow(ctx, getMembershipTransaction, id)
	var i MembershipTransaction
	err := row.Scan(
		&i.ID,
		&i.MembershipID,
		&i.Type,
		&i.Amount,
		&i.BalanceAfter,
		&i.RelatedOrderID,
		&i.RechargeRuleID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getMembershipTransactionStats = `-- name: GetMembershipTransactionStats :one
SELECT 
    COUNT(*) as total_count,
    SUM(CASE WHEN amount > 0 THEN amount ELSE 0 END) as total_recharge,
    SUM(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END) as total_consume
FROM membership_transactions
WHERE membership_id = $1
`

type GetMembershipTransactionStatsRow struct {
	TotalCount    int64 `json:"total_count"`
	TotalRecharge int64 `json:"total_recharge"`
	TotalConsume  int64 `json:"total_consume"`
}

func (q *Queries) GetMembershipTransactionStats(ctx context.Context, membershipID int64) (GetMembershipTransactionStatsRow, error) {
	row := q.db.QueryRow(ctx, getMembershipTransactionStats, membershipID)
	var i GetMembershipTransactionStatsRow
	err := row.Scan(&i.TotalCount, &i.TotalRecharge, &i.TotalConsume)
	return i, err
}

const getMerchantMembership = `-- name: GetMerchantMembership :one
SELECT id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at FROM merchant_memberships
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMerchantMembership(ctx context.Context, id int64) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, getMerchantMembership, id)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRechargeRule = `-- name: GetRechargeRule :one
SELECT id, merchant_id, recharge_amount, bonus_amount, is_active, valid_from, valid_until, created_at, updated_at FROM recharge_rules
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRechargeRule(ctx context.Context, id int64) (RechargeRule, error) {
	row := q.db.QueryRow(ctx, getRechargeRule, id)
	var i RechargeRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.RechargeAmount,
		&i.BonusAmount,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementMembershipBalance = `-- name: IncrementMembershipBalance :one
UPDATE merchant_memberships
SET 
    balance = balance + $2,
    total_recharged = total_recharged + $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at
`

type IncrementMembershipBalanceParams struct {
	ID      int64 `json:"id"`
	Balance int64 `json:"balance"`
}

func (q *Queries) IncrementMembershipBalance(ctx context.Context, arg IncrementMembershipBalanceParams) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, incrementMembershipBalance, arg.ID, arg.Balance)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveRechargeRules = `-- name: ListActiveRechargeRules :many
SELECT id, merchant_id, recharge_amount, bonus_amount, is_active, valid_from, valid_until, created_at, updated_at FROM recharge_rules
WHERE merchant_id = $1 
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
ORDER BY recharge_amount ASC
`

func (q *Queries) ListActiveRechargeRules(ctx context.Context, merchantID int64) ([]RechargeRule, error) {
	rows, err := q.db.Query(ctx, listActiveRechargeRules, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RechargeRule{}
	for rows.Next() {
		var i RechargeRule
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.RechargeAmount,
			&i.BonusAmount,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipTransactions = `-- name: ListMembershipTransactions :many
SELECT id, membership_id, type, amount, balance_after, related_order_id, recharge_rule_id, notes, created_at FROM membership_transactions
WHERE membership_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMembershipTransactionsParams struct {
	MembershipID int64 `json:"membership_id"`
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
}

func (q *Queries) ListMembershipTransactions(ctx context.Context, arg ListMembershipTransactionsParams) ([]MembershipTransaction, error) {
	rows, err := q.db.Query(ctx, listMembershipTransactions, arg.MembershipID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MembershipTransaction{}
	for rows.Next() {
		var i MembershipTransaction
		if err := rows.Scan(
			&i.ID,
			&i.MembershipID,
			&i.Type,
			&i.Amount,
			&i.BalanceAfter,
			&i.RelatedOrderID,
			&i.RechargeRuleID,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipTransactionsByType = `-- name: ListMembershipTransactionsByType :many
SELECT id, membership_id, type, amount, balance_after, related_order_id, recharge_rule_id, notes, created_at FROM membership_transactions
WHERE membership_id = $1 AND type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListMembershipTransactionsByTypeParams struct {
	MembershipID int64  `json:"membership_id"`
	Type         string `json:"type"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) ListMembershipTransactionsByType(ctx context.Context, arg ListMembershipTransactionsByTypeParams) ([]MembershipTransaction, error) {
	rows, err := q.db.Query(ctx, listMembershipTransactionsByType,
		arg.MembershipID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MembershipTransaction{}
	for rows.Next() {
		var i MembershipTransaction
		if err := rows.Scan(
			&i.ID,
			&i.MembershipID,
			&i.Type,
			&i.Amount,
			&i.BalanceAfter,
			&i.RelatedOrderID,
			&i.RechargeRuleID,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantMembers = `-- name: ListMerchantMembers :many
SELECT m.id, m.merchant_id, m.user_id, m.balance, m.total_recharged, m.total_consumed, m.created_at, m.updated_at, u.full_name, u.phone, u.avatar_url
FROM merchant_memberships m
JOIN users u ON u.id = m.user_id
WHERE m.merchant_id = $1
ORDER BY m.total_consumed DESC
LIMIT $2 OFFSET $3
`

type ListMerchantMembersParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type ListMerchantMembersRow struct {
	ID             int64              `json:"id"`
	MerchantID     int64              `json:"merchant_id"`
	UserID         int64              `json:"user_id"`
	Balance        int64              `json:"balance"`
	TotalRecharged int64              `json:"total_recharged"`
	TotalConsumed  int64              `json:"total_consumed"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	FullName       string             `json:"full_name"`
	Phone          pgtype.Text        `json:"phone"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
}

func (q *Queries) ListMerchantMembers(ctx context.Context, arg ListMerchantMembersParams) ([]ListMerchantMembersRow, error) {
	rows, err := q.db.Query(ctx, listMerchantMembers, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantMembersRow{}
	for rows.Next() {
		var i ListMerchantMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.UserID,
			&i.Balance,
			&i.TotalRecharged,
			&i.TotalConsumed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantRechargeRules = `-- name: ListMerchantRechargeRules :many
SELECT id, merchant_id, recharge_amount, bonus_amount, is_active, valid_from, valid_until, created_at, updated_at FROM recharge_rules
WHERE merchant_id = $1
ORDER BY recharge_amount ASC
`

func (q *Queries) ListMerchantRechargeRules(ctx context.Context, merchantID int64) ([]RechargeRule, error) {
	rows, err := q.db.Query(ctx, listMerchantRechargeRules, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RechargeRule{}
	for rows.Next() {
		var i RechargeRule
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.RechargeAmount,
			&i.BonusAmount,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMemberships = `-- name: ListUserMemberships :many
SELECT m.id, m.merchant_id, m.user_id, m.balance, m.total_recharged, m.total_consumed, m.created_at, m.updated_at, mer.name as merchant_name, mer.logo_url
FROM merchant_memberships m
JOIN merchants mer ON mer.id = m.merchant_id
WHERE m.user_id = $1
ORDER BY m.balance DESC
LIMIT $2 OFFSET $3
`

type ListUserMembershipsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUserMembershipsRow struct {
	ID             int64              `json:"id"`
	MerchantID     int64              `json:"merchant_id"`
	UserID         int64              `json:"user_id"`
	Balance        int64              `json:"balance"`
	TotalRecharged int64              `json:"total_recharged"`
	TotalConsumed  int64              `json:"total_consumed"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	MerchantName   string             `json:"merchant_name"`
	LogoUrl        pgtype.Text        `json:"logo_url"`
}

func (q *Queries) ListUserMemberships(ctx context.Context, arg ListUserMembershipsParams) ([]ListUserMembershipsRow, error) {
	rows, err := q.db.Query(ctx, listUserMemberships, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserMembershipsRow{}
	for rows.Next() {
		var i ListUserMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.UserID,
			&i.Balance,
			&i.TotalRecharged,
			&i.TotalConsumed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MerchantName,
			&i.LogoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMembershipBalance = `-- name: UpdateMembershipBalance :one
UPDATE merchant_memberships
SET 
    balance = $2,
    total_recharged = $3,
    total_consumed = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, merchant_id, user_id, balance, total_recharged, total_consumed, created_at, updated_at
`

type UpdateMembershipBalanceParams struct {
	ID             int64 `json:"id"`
	Balance        int64 `json:"balance"`
	TotalRecharged int64 `json:"total_recharged"`
	TotalConsumed  int64 `json:"total_consumed"`
}

func (q *Queries) UpdateMembershipBalance(ctx context.Context, arg UpdateMembershipBalanceParams) (MerchantMembership, error) {
	row := q.db.QueryRow(ctx, updateMembershipBalance,
		arg.ID,
		arg.Balance,
		arg.TotalRecharged,
		arg.TotalConsumed,
	)
	var i MerchantMembership
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.UserID,
		&i.Balance,
		&i.TotalRecharged,
		&i.TotalConsumed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRechargeRule = `-- name: UpdateRechargeRule :one
UPDATE recharge_rules
SET 
    recharge_amount = COALESCE($1, recharge_amount),
    bonus_amount = COALESCE($2, bonus_amount),
    is_active = COALESCE($3, is_active),
    valid_from = COALESCE($4, valid_from),
    valid_until = COALESCE($5, valid_until),
    updated_at = NOW()
WHERE id = $6
RETURNING id, merchant_id, recharge_amount, bonus_amount, is_active, valid_from, valid_until, created_at, updated_at
`

type UpdateRechargeRuleParams struct {
	RechargeAmount pgtype.Int8        `json:"recharge_amount"`
	BonusAmount    pgtype.Int8        `json:"bonus_amount"`
	IsActive       pgtype.Bool        `json:"is_active"`
	ValidFrom      pgtype.Timestamptz `json:"valid_from"`
	ValidUntil     pgtype.Timestamptz `json:"valid_until"`
	ID             int64              `json:"id"`
}

func (q *Queries) UpdateRechargeRule(ctx context.Context, arg UpdateRechargeRuleParams) (RechargeRule, error) {
	row := q.db.QueryRow(ctx, updateRechargeRule,
		arg.RechargeAmount,
		arg.BonusAmount,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.ID,
	)
	var i RechargeRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.RechargeAmount,
		&i.BonusAmount,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
