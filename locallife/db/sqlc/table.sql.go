// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: table.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTableImage = `-- name: AddTableImage :one

INSERT INTO table_images (
    table_id,
    image_url,
    sort_order,
    is_primary
) VALUES (
    $1, $2, $3, $4
) RETURNING id, table_id, image_url, sort_order, is_primary, created_at
`

type AddTableImageParams struct {
	TableID   int64  `json:"table_id"`
	ImageUrl  string `json:"image_url"`
	SortOrder int32  `json:"sort_order"`
	IsPrimary bool   `json:"is_primary"`
}

// ============ Table Images ============
func (q *Queries) AddTableImage(ctx context.Context, arg AddTableImageParams) (TableImage, error) {
	row := q.db.QueryRow(ctx, addTableImage,
		arg.TableID,
		arg.ImageUrl,
		arg.SortOrder,
		arg.IsPrimary,
	)
	var i TableImage
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.ImageUrl,
		&i.SortOrder,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const addTableTag = `-- name: AddTableTag :one

INSERT INTO table_tags (
    table_id,
    tag_id
) VALUES (
    $1, $2
) RETURNING id, table_id, tag_id, created_at
`

type AddTableTagParams struct {
	TableID int64 `json:"table_id"`
	TagID   int64 `json:"tag_id"`
}

// ============ Table Tags ============
func (q *Queries) AddTableTag(ctx context.Context, arg AddTableTagParams) (TableTag, error) {
	row := q.db.QueryRow(ctx, addTableTag, arg.TableID, arg.TagID)
	var i TableTag
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.TagID,
		&i.CreatedAt,
	)
	return i, err
}

const countAvailableTablesByMerchant = `-- name: CountAvailableTablesByMerchant :one
SELECT COUNT(*) FROM tables
WHERE merchant_id = $1 
  AND status = 'available'
`

func (q *Queries) CountAvailableTablesByMerchant(ctx context.Context, merchantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableTablesByMerchant, merchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExploreNearbyRooms = `-- name: CountExploreNearbyRooms :one
SELECT COUNT(*) FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
WHERE t.table_type = 'room'
  AND t.status = 'available'
  AND m.status = 'approved'
  AND ($1::BIGINT IS NULL OR m.region_id = $1)
  AND ($2::SMALLINT IS NULL OR t.capacity >= $2)
  AND ($3::SMALLINT IS NULL OR t.capacity <= $3)
  AND ($4::BIGINT IS NULL OR t.minimum_spend IS NULL OR t.minimum_spend <= $4)
`

type CountExploreNearbyRoomsParams struct {
	RegionID        pgtype.Int8 `json:"region_id"`
	MinCapacity     pgtype.Int2 `json:"min_capacity"`
	MaxCapacity     pgtype.Int2 `json:"max_capacity"`
	MaxMinimumSpend pgtype.Int8 `json:"max_minimum_spend"`
}

// 统计可探索包间总数
func (q *Queries) CountExploreNearbyRooms(ctx context.Context, arg CountExploreNearbyRoomsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countExploreNearbyRooms,
		arg.RegionID,
		arg.MinCapacity,
		arg.MaxCapacity,
		arg.MaxMinimumSpend,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchRooms = `-- name: CountSearchRooms :one
SELECT COUNT(*) FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
WHERE t.table_type = 'room'
  AND t.status = 'available'
  AND m.status = 'approved'
  AND ($1::BIGINT IS NULL OR m.region_id = $1)
  AND ($2::SMALLINT IS NULL OR t.capacity >= $2)
  AND ($3::SMALLINT IS NULL OR t.capacity <= $3)
  AND ($4::BIGINT IS NULL OR t.minimum_spend IS NULL OR t.minimum_spend <= $4)
  AND NOT EXISTS (
    SELECT 1 FROM table_reservations tr
    WHERE tr.table_id = t.id
      AND tr.reservation_date = $5::DATE
      AND tr.reservation_time = $6::TIME
      AND tr.status IN ('pending', 'paid', 'confirmed')
  )
`

type CountSearchRoomsParams struct {
	RegionID        pgtype.Int8 `json:"region_id"`
	MinCapacity     pgtype.Int2 `json:"min_capacity"`
	MaxCapacity     pgtype.Int2 `json:"max_capacity"`
	MaxMinimumSpend pgtype.Int8 `json:"max_minimum_spend"`
	ReservationDate pgtype.Date `json:"reservation_date"`
	ReservationTime pgtype.Time `json:"reservation_time"`
}

// 统计搜索包间结果数量
func (q *Queries) CountSearchRooms(ctx context.Context, arg CountSearchRoomsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchRooms,
		arg.RegionID,
		arg.MinCapacity,
		arg.MaxCapacity,
		arg.MaxMinimumSpend,
		arg.ReservationDate,
		arg.ReservationTime,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTablesByMerchant = `-- name: CountTablesByMerchant :one
SELECT COUNT(*) FROM tables
WHERE merchant_id = $1
`

func (q *Queries) CountTablesByMerchant(ctx context.Context, merchantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countTablesByMerchant, merchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTable = `-- name: CreateTable :one
INSERT INTO tables (
    merchant_id,
    table_no,
    table_type,
    capacity,
    description,
    minimum_spend,
    qr_code_url,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at
`

type CreateTableParams struct {
	MerchantID   int64       `json:"merchant_id"`
	TableNo      string      `json:"table_no"`
	TableType    string      `json:"table_type"`
	Capacity     int16       `json:"capacity"`
	Description  pgtype.Text `json:"description"`
	MinimumSpend pgtype.Int8 `json:"minimum_spend"`
	QrCodeUrl    pgtype.Text `json:"qr_code_url"`
	Status       string      `json:"status"`
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) (Table, error) {
	row := q.db.QueryRow(ctx, createTable,
		arg.MerchantID,
		arg.TableNo,
		arg.TableType,
		arg.Capacity,
		arg.Description,
		arg.MinimumSpend,
		arg.QrCodeUrl,
		arg.Status,
	)
	var i Table
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.QrCodeUrl,
		&i.Status,
		&i.CurrentReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllTableImages = `-- name: DeleteAllTableImages :exec
DELETE FROM table_images WHERE table_id = $1
`

func (q *Queries) DeleteAllTableImages(ctx context.Context, tableID int64) error {
	_, err := q.db.Exec(ctx, deleteAllTableImages, tableID)
	return err
}

const deleteTable = `-- name: DeleteTable :exec
DELETE FROM tables
WHERE id = $1
`

func (q *Queries) DeleteTable(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTable, id)
	return err
}

const deleteTableImage = `-- name: DeleteTableImage :exec
DELETE FROM table_images WHERE id = $1
`

func (q *Queries) DeleteTableImage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTableImage, id)
	return err
}

const exploreNearbyRooms = `-- name: ExploreNearbyRooms :many
SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.table_type,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.status,
    t.created_at,
    m.name as merchant_name,
    m.logo_url as merchant_logo,
    m.address as merchant_address,
    m.latitude as merchant_latitude,
    m.longitude as merchant_longitude,
    m.phone as merchant_phone,
    COALESCE((SELECT ti.image_url FROM table_images ti WHERE ti.table_id = t.id AND ti.is_primary = true LIMIT 1), '')::TEXT as primary_image,
    (SELECT COUNT(*) FROM table_reservations tr 
     WHERE tr.table_id = t.id 
       AND tr.reservation_date >= CURRENT_DATE - INTERVAL '30 days'
       AND tr.status IN ('paid', 'confirmed', 'completed')
    )::INT as monthly_reservations
FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
WHERE t.table_type = 'room'
  AND t.status = 'available'
  AND m.status = 'approved'
  -- 按区域筛选
  AND ($1::BIGINT IS NULL OR m.region_id = $1)
  -- 按人数筛选
  AND ($2::SMALLINT IS NULL OR t.capacity >= $2)
  AND ($3::SMALLINT IS NULL OR t.capacity <= $3)
  -- 按最低消费筛选
  AND ($4::BIGINT IS NULL OR t.minimum_spend IS NULL OR t.minimum_spend <= $4)
ORDER BY monthly_reservations DESC, t.capacity
LIMIT $6
OFFSET $5
`

type ExploreNearbyRoomsParams struct {
	RegionID        pgtype.Int8 `json:"region_id"`
	MinCapacity     pgtype.Int2 `json:"min_capacity"`
	MaxCapacity     pgtype.Int2 `json:"max_capacity"`
	MaxMinimumSpend pgtype.Int8 `json:"max_minimum_spend"`
	PageOffset      int32       `json:"page_offset"`
	PageSize        int32       `json:"page_size"`
}

type ExploreNearbyRoomsRow struct {
	ID                  int64          `json:"id"`
	MerchantID          int64          `json:"merchant_id"`
	TableNo             string         `json:"table_no"`
	TableType           string         `json:"table_type"`
	Capacity            int16          `json:"capacity"`
	Description         pgtype.Text    `json:"description"`
	MinimumSpend        pgtype.Int8    `json:"minimum_spend"`
	Status              string         `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	MerchantName        string         `json:"merchant_name"`
	MerchantLogo        pgtype.Text    `json:"merchant_logo"`
	MerchantAddress     string         `json:"merchant_address"`
	MerchantLatitude    pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude   pgtype.Numeric `json:"merchant_longitude"`
	MerchantPhone       string         `json:"merchant_phone"`
	PrimaryImage        string         `json:"primary_image"`
	MonthlyReservations int32          `json:"monthly_reservations"`
}

// 探索附近包间（无需指定预订日期时段），用于本地包间浏览流
// 返回包间信息 + 商户信息 + 主图 + 近30天预订量
func (q *Queries) ExploreNearbyRooms(ctx context.Context, arg ExploreNearbyRoomsParams) ([]ExploreNearbyRoomsRow, error) {
	rows, err := q.db.Query(ctx, exploreNearbyRooms,
		arg.RegionID,
		arg.MinCapacity,
		arg.MaxCapacity,
		arg.MaxMinimumSpend,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExploreNearbyRoomsRow{}
	for rows.Next() {
		var i ExploreNearbyRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.Status,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantAddress,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
			&i.MerchantPhone,
			&i.PrimaryImage,
			&i.MonthlyReservations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryTableImage = `-- name: GetPrimaryTableImage :one
SELECT id, table_id, image_url, sort_order, is_primary, created_at FROM table_images
WHERE table_id = $1 AND is_primary = TRUE
LIMIT 1
`

func (q *Queries) GetPrimaryTableImage(ctx context.Context, tableID int64) (TableImage, error) {
	row := q.db.QueryRow(ctx, getPrimaryTableImage, tableID)
	var i TableImage
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.ImageUrl,
		&i.SortOrder,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const getRoomDetailForCustomer = `-- name: GetRoomDetailForCustomer :one

SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.status,
    t.created_at,
    m.name as merchant_name,
    m.logo_url as merchant_logo,
    m.address as merchant_address,
    m.latitude as merchant_latitude,
    m.longitude as merchant_longitude,
    m.phone as merchant_phone,
    COALESCE((SELECT image_url FROM table_images WHERE table_id = t.id AND is_primary = TRUE LIMIT 1), '')::TEXT as primary_image,
    (SELECT COUNT(*) FROM table_reservations tr 
     WHERE tr.table_id = t.id 
       AND tr.status IN ('confirmed', 'completed')
       AND tr.created_at >= NOW() - INTERVAL '30 days') as monthly_reservations
FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
WHERE t.id = $1 
  AND t.table_type = 'room'
  AND m.status = 'approved'
`

type GetRoomDetailForCustomerRow struct {
	ID                  int64          `json:"id"`
	MerchantID          int64          `json:"merchant_id"`
	TableNo             string         `json:"table_no"`
	Capacity            int16          `json:"capacity"`
	Description         pgtype.Text    `json:"description"`
	MinimumSpend        pgtype.Int8    `json:"minimum_spend"`
	Status              string         `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	MerchantName        string         `json:"merchant_name"`
	MerchantLogo        pgtype.Text    `json:"merchant_logo"`
	MerchantAddress     string         `json:"merchant_address"`
	MerchantLatitude    pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude   pgtype.Numeric `json:"merchant_longitude"`
	MerchantPhone       string         `json:"merchant_phone"`
	PrimaryImage        string         `json:"primary_image"`
	MonthlyReservations int64          `json:"monthly_reservations"`
}

// ============ Customer-side Room Queries (C端包间查询) ============
// 获取包间详情（含商户信息、主图、月销量）供顾客查看
func (q *Queries) GetRoomDetailForCustomer(ctx context.Context, id int64) (GetRoomDetailForCustomerRow, error) {
	row := q.db.QueryRow(ctx, getRoomDetailForCustomer, id)
	var i GetRoomDetailForCustomerRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.Status,
		&i.CreatedAt,
		&i.MerchantName,
		&i.MerchantLogo,
		&i.MerchantAddress,
		&i.MerchantLatitude,
		&i.MerchantLongitude,
		&i.MerchantPhone,
		&i.PrimaryImage,
		&i.MonthlyReservations,
	)
	return i, err
}

const getTable = `-- name: GetTable :one
SELECT id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at FROM tables
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTable(ctx context.Context, id int64) (Table, error) {
	row := q.db.QueryRow(ctx, getTable, id)
	var i Table
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.QrCodeUrl,
		&i.Status,
		&i.CurrentReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTableByMerchantAndNo = `-- name: GetTableByMerchantAndNo :one
SELECT id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at FROM tables
WHERE merchant_id = $1 AND table_no = $2 LIMIT 1
`

type GetTableByMerchantAndNoParams struct {
	MerchantID int64  `json:"merchant_id"`
	TableNo    string `json:"table_no"`
}

func (q *Queries) GetTableByMerchantAndNo(ctx context.Context, arg GetTableByMerchantAndNoParams) (Table, error) {
	row := q.db.QueryRow(ctx, getTableByMerchantAndNo, arg.MerchantID, arg.TableNo)
	var i Table
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.QrCodeUrl,
		&i.Status,
		&i.CurrentReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTableForUpdate = `-- name: GetTableForUpdate :one
SELECT id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at FROM tables
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetTableForUpdate(ctx context.Context, id int64) (Table, error) {
	row := q.db.QueryRow(ctx, getTableForUpdate, id)
	var i Table
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.QrCodeUrl,
		&i.Status,
		&i.CurrentReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAvailableRooms = `-- name: ListAvailableRooms :many
SELECT id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at FROM tables
WHERE merchant_id = $1 
  AND table_type = 'room' 
  AND status = 'available'
ORDER BY table_no
`

func (q *Queries) ListAvailableRooms(ctx context.Context, merchantID int64) ([]Table, error) {
	rows, err := q.db.Query(ctx, listAvailableRooms, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Table{}
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CurrentReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailableRoomsForCustomer = `-- name: ListAvailableRoomsForCustomer :many
SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.status,
    COALESCE((SELECT image_url FROM table_images WHERE table_id = t.id AND is_primary = TRUE LIMIT 1), '')::TEXT as primary_image
FROM tables t
WHERE t.merchant_id = $1 
  AND t.table_type = 'room'
  AND t.status = 'available'
ORDER BY t.capacity, t.table_no
`

type ListAvailableRoomsForCustomerRow struct {
	ID           int64       `json:"id"`
	MerchantID   int64       `json:"merchant_id"`
	TableNo      string      `json:"table_no"`
	Capacity     int16       `json:"capacity"`
	Description  pgtype.Text `json:"description"`
	MinimumSpend pgtype.Int8 `json:"minimum_spend"`
	Status       string      `json:"status"`
	PrimaryImage string      `json:"primary_image"`
}

// 获取商户的可用包间列表（含主图）供顾客查看
func (q *Queries) ListAvailableRoomsForCustomer(ctx context.Context, merchantID int64) ([]ListAvailableRoomsForCustomerRow, error) {
	rows, err := q.db.Query(ctx, listAvailableRoomsForCustomer, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAvailableRoomsForCustomerRow{}
	for rows.Next() {
		var i ListAvailableRoomsForCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.Status,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantRoomsForCustomer = `-- name: ListMerchantRoomsForCustomer :many
SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.status,
    t.created_at,
    COALESCE((SELECT image_url FROM table_images WHERE table_id = t.id AND is_primary = TRUE LIMIT 1), '')::TEXT as primary_image,
    (SELECT COUNT(*) FROM table_reservations tr 
     WHERE tr.table_id = t.id 
       AND tr.status IN ('confirmed', 'completed')
       AND tr.created_at >= NOW() - INTERVAL '30 days') as monthly_reservations
FROM tables t
WHERE t.merchant_id = $1 
  AND t.table_type = 'room'
ORDER BY t.capacity, t.table_no
`

type ListMerchantRoomsForCustomerRow struct {
	ID                  int64       `json:"id"`
	MerchantID          int64       `json:"merchant_id"`
	TableNo             string      `json:"table_no"`
	Capacity            int16       `json:"capacity"`
	Description         pgtype.Text `json:"description"`
	MinimumSpend        pgtype.Int8 `json:"minimum_spend"`
	Status              string      `json:"status"`
	CreatedAt           time.Time   `json:"created_at"`
	PrimaryImage        string      `json:"primary_image"`
	MonthlyReservations int64       `json:"monthly_reservations"`
}

// 获取商户的包间列表（含主图、月销量）供顾客查看
func (q *Queries) ListMerchantRoomsForCustomer(ctx context.Context, merchantID int64) ([]ListMerchantRoomsForCustomerRow, error) {
	rows, err := q.db.Query(ctx, listMerchantRoomsForCustomer, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantRoomsForCustomerRow{}
	for rows.Next() {
		var i ListMerchantRoomsForCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.Status,
			&i.CreatedAt,
			&i.PrimaryImage,
			&i.MonthlyReservations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTableImages = `-- name: ListTableImages :many
SELECT id, table_id, image_url, sort_order, is_primary, created_at FROM table_images
WHERE table_id = $1
ORDER BY is_primary DESC, sort_order ASC, created_at ASC
`

func (q *Queries) ListTableImages(ctx context.Context, tableID int64) ([]TableImage, error) {
	rows, err := q.db.Query(ctx, listTableImages, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableImage{}
	for rows.Next() {
		var i TableImage
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.ImageUrl,
			&i.SortOrder,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTableTags = `-- name: ListTableTags :many
SELECT 
    tt.id,
    tt.table_id,
    tt.tag_id,
    tt.created_at,
    t.name as tag_name,
    t.type as tag_type
FROM table_tags tt
INNER JOIN tags t ON tt.tag_id = t.id
WHERE tt.table_id = $1
ORDER BY t.name
`

type ListTableTagsRow struct {
	ID        int64     `json:"id"`
	TableID   int64     `json:"table_id"`
	TagID     int64     `json:"tag_id"`
	CreatedAt time.Time `json:"created_at"`
	TagName   string    `json:"tag_name"`
	TagType   string    `json:"tag_type"`
}

func (q *Queries) ListTableTags(ctx context.Context, tableID int64) ([]ListTableTagsRow, error) {
	rows, err := q.db.Query(ctx, listTableTags, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTableTagsRow{}
	for rows.Next() {
		var i ListTableTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.TagID,
			&i.CreatedAt,
			&i.TagName,
			&i.TagType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTablesByMerchant = `-- name: ListTablesByMerchant :many
SELECT id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at FROM tables
WHERE merchant_id = $1
ORDER BY table_type, table_no
`

func (q *Queries) ListTablesByMerchant(ctx context.Context, merchantID int64) ([]Table, error) {
	rows, err := q.db.Query(ctx, listTablesByMerchant, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Table{}
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CurrentReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTablesByMerchantAndType = `-- name: ListTablesByMerchantAndType :many
SELECT id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at FROM tables
WHERE merchant_id = $1 
  AND table_type = $2
ORDER BY table_no
`

type ListTablesByMerchantAndTypeParams struct {
	MerchantID int64  `json:"merchant_id"`
	TableType  string `json:"table_type"`
}

func (q *Queries) ListTablesByMerchantAndType(ctx context.Context, arg ListTablesByMerchantAndTypeParams) ([]Table, error) {
	rows, err := q.db.Query(ctx, listTablesByMerchantAndType, arg.MerchantID, arg.TableType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Table{}
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CurrentReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTablesByTag = `-- name: ListTablesByTag :many
SELECT tb.id, tb.merchant_id, tb.table_no, tb.table_type, tb.capacity, tb.description, tb.minimum_spend, tb.qr_code_url, tb.status, tb.current_reservation_id, tb.created_at, tb.updated_at FROM tables tb
INNER JOIN table_tags tt ON tb.id = tt.table_id
WHERE tt.tag_id = $1
ORDER BY tb.table_no
`

func (q *Queries) ListTablesByTag(ctx context.Context, tagID int64) ([]Table, error) {
	rows, err := q.db.Query(ctx, listTablesByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Table{}
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CurrentReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllTableTags = `-- name: RemoveAllTableTags :exec
DELETE FROM table_tags
WHERE table_id = $1
`

func (q *Queries) RemoveAllTableTags(ctx context.Context, tableID int64) error {
	_, err := q.db.Exec(ctx, removeAllTableTags, tableID)
	return err
}

const removeTableTag = `-- name: RemoveTableTag :exec
DELETE FROM table_tags
WHERE table_id = $1 AND tag_id = $2
`

type RemoveTableTagParams struct {
	TableID int64 `json:"table_id"`
	TagID   int64 `json:"tag_id"`
}

func (q *Queries) RemoveTableTag(ctx context.Context, arg RemoveTableTagParams) error {
	_, err := q.db.Exec(ctx, removeTableTag, arg.TableID, arg.TagID)
	return err
}

const searchRooms = `-- name: SearchRooms :many

SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.table_type,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.qr_code_url,
    t.status,
    t.created_at,
    m.name as merchant_name,
    m.logo_url as merchant_logo,
    m.address as merchant_address,
    m.latitude as merchant_latitude,
    m.longitude as merchant_longitude
FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
WHERE t.table_type = 'room'
  AND t.status = 'available'
  AND m.status = 'approved'
  -- 按区域筛选（可选）
  AND ($1::BIGINT IS NULL OR m.region_id = $1)
  -- 按人数筛选
  AND ($2::SMALLINT IS NULL OR t.capacity >= $2)
  AND ($3::SMALLINT IS NULL OR t.capacity <= $3)
  -- 按最低消费筛选
  AND ($4::BIGINT IS NULL OR t.minimum_spend IS NULL OR t.minimum_spend <= $4)
  -- 排除已在指定日期时段被预定的包间
  AND NOT EXISTS (
    SELECT 1 FROM table_reservations tr
    WHERE tr.table_id = t.id
      AND tr.reservation_date = $5::DATE
      AND tr.reservation_time = $6::TIME
      AND tr.status IN ('pending', 'paid', 'confirmed')
  )
ORDER BY t.capacity, t.minimum_spend NULLS FIRST
LIMIT $8
OFFSET $7
`

type SearchRoomsParams struct {
	RegionID        pgtype.Int8 `json:"region_id"`
	MinCapacity     pgtype.Int2 `json:"min_capacity"`
	MaxCapacity     pgtype.Int2 `json:"max_capacity"`
	MaxMinimumSpend pgtype.Int8 `json:"max_minimum_spend"`
	ReservationDate pgtype.Date `json:"reservation_date"`
	ReservationTime pgtype.Time `json:"reservation_time"`
	PageOffset      int32       `json:"page_offset"`
	PageSize        int32       `json:"page_size"`
}

type SearchRoomsRow struct {
	ID                int64          `json:"id"`
	MerchantID        int64          `json:"merchant_id"`
	TableNo           string         `json:"table_no"`
	TableType         string         `json:"table_type"`
	Capacity          int16          `json:"capacity"`
	Description       pgtype.Text    `json:"description"`
	MinimumSpend      pgtype.Int8    `json:"minimum_spend"`
	QrCodeUrl         pgtype.Text    `json:"qr_code_url"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	MerchantName      string         `json:"merchant_name"`
	MerchantLogo      pgtype.Text    `json:"merchant_logo"`
	MerchantAddress   string         `json:"merchant_address"`
	MerchantLatitude  pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude pgtype.Numeric `json:"merchant_longitude"`
}

// ============ Room Search ============
// 搜索包间：按日期、时段、人数、菜系（商户标签）等条件过滤
// 返回可用包间及其商户信息
func (q *Queries) SearchRooms(ctx context.Context, arg SearchRoomsParams) ([]SearchRoomsRow, error) {
	rows, err := q.db.Query(ctx, searchRooms,
		arg.RegionID,
		arg.MinCapacity,
		arg.MaxCapacity,
		arg.MaxMinimumSpend,
		arg.ReservationDate,
		arg.ReservationTime,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRoomsRow{}
	for rows.Next() {
		var i SearchRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantAddress,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRoomsByMerchantTag = `-- name: SearchRoomsByMerchantTag :many
SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.table_type,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.qr_code_url,
    t.status,
    t.created_at,
    m.name as merchant_name,
    m.logo_url as merchant_logo,
    m.address as merchant_address,
    m.latitude as merchant_latitude,
    m.longitude as merchant_longitude
FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
INNER JOIN merchant_tags mt ON m.id = mt.merchant_id
WHERE t.table_type = 'room'
  AND t.status = 'available'
  AND m.status = 'approved'
  AND mt.tag_id = $1
  -- 按区域筛选（可选）
  AND ($2::BIGINT IS NULL OR m.region_id = $2)
  -- 按人数筛选
  AND ($3::SMALLINT IS NULL OR t.capacity >= $3)
  AND ($4::SMALLINT IS NULL OR t.capacity <= $4)
  -- 排除已在指定日期时段被预定的包间
  AND NOT EXISTS (
    SELECT 1 FROM table_reservations tr
    WHERE tr.table_id = t.id
      AND tr.reservation_date = $5::DATE
      AND tr.reservation_time = $6::TIME
      AND tr.status IN ('pending', 'paid', 'confirmed')
  )
ORDER BY t.capacity, t.minimum_spend NULLS FIRST
LIMIT $8
OFFSET $7
`

type SearchRoomsByMerchantTagParams struct {
	TagID           int64       `json:"tag_id"`
	RegionID        pgtype.Int8 `json:"region_id"`
	MinCapacity     pgtype.Int2 `json:"min_capacity"`
	MaxCapacity     pgtype.Int2 `json:"max_capacity"`
	ReservationDate pgtype.Date `json:"reservation_date"`
	ReservationTime pgtype.Time `json:"reservation_time"`
	PageOffset      int32       `json:"page_offset"`
	PageSize        int32       `json:"page_size"`
}

type SearchRoomsByMerchantTagRow struct {
	ID                int64          `json:"id"`
	MerchantID        int64          `json:"merchant_id"`
	TableNo           string         `json:"table_no"`
	TableType         string         `json:"table_type"`
	Capacity          int16          `json:"capacity"`
	Description       pgtype.Text    `json:"description"`
	MinimumSpend      pgtype.Int8    `json:"minimum_spend"`
	QrCodeUrl         pgtype.Text    `json:"qr_code_url"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	MerchantName      string         `json:"merchant_name"`
	MerchantLogo      pgtype.Text    `json:"merchant_logo"`
	MerchantAddress   string         `json:"merchant_address"`
	MerchantLatitude  pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude pgtype.Numeric `json:"merchant_longitude"`
}

// 按商户标签（菜系）搜索包间
func (q *Queries) SearchRoomsByMerchantTag(ctx context.Context, arg SearchRoomsByMerchantTagParams) ([]SearchRoomsByMerchantTagRow, error) {
	rows, err := q.db.Query(ctx, searchRoomsByMerchantTag,
		arg.TagID,
		arg.RegionID,
		arg.MinCapacity,
		arg.MaxCapacity,
		arg.ReservationDate,
		arg.ReservationTime,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRoomsByMerchantTagRow{}
	for rows.Next() {
		var i SearchRoomsByMerchantTagRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantAddress,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRoomsWithImage = `-- name: SearchRoomsWithImage :many
SELECT 
    t.id,
    t.merchant_id,
    t.table_no,
    t.table_type,
    t.capacity,
    t.description,
    t.minimum_spend,
    t.qr_code_url,
    t.status,
    t.created_at,
    m.name as merchant_name,
    m.logo_url as merchant_logo,
    m.address as merchant_address,
    m.latitude as merchant_latitude,
    m.longitude as merchant_longitude,
    COALESCE((SELECT ti.image_url FROM table_images ti WHERE ti.table_id = t.id AND ti.is_primary = true LIMIT 1), '')::TEXT as primary_image
FROM tables t
INNER JOIN merchants m ON t.merchant_id = m.id
WHERE t.table_type = 'room'
  AND t.status = 'available'
  AND m.status = 'approved'
  -- 按区域筛选（可选）
  AND ($1::BIGINT IS NULL OR m.region_id = $1)
  -- 按人数筛选
  AND ($2::SMALLINT IS NULL OR t.capacity >= $2)
  AND ($3::SMALLINT IS NULL OR t.capacity <= $3)
  -- 按最低消费筛选
  AND ($4::BIGINT IS NULL OR t.minimum_spend IS NULL OR t.minimum_spend <= $4)
  -- 排除已在指定日期时段被预定的包间
  AND NOT EXISTS (
    SELECT 1 FROM table_reservations tr
    WHERE tr.table_id = t.id
      AND tr.reservation_date = $5::DATE
      AND tr.reservation_time = $6::TIME
      AND tr.status IN ('pending', 'paid', 'confirmed')
  )
ORDER BY t.capacity, t.minimum_spend NULLS FIRST
LIMIT $8
OFFSET $7
`

type SearchRoomsWithImageParams struct {
	RegionID        pgtype.Int8 `json:"region_id"`
	MinCapacity     pgtype.Int2 `json:"min_capacity"`
	MaxCapacity     pgtype.Int2 `json:"max_capacity"`
	MaxMinimumSpend pgtype.Int8 `json:"max_minimum_spend"`
	ReservationDate pgtype.Date `json:"reservation_date"`
	ReservationTime pgtype.Time `json:"reservation_time"`
	PageOffset      int32       `json:"page_offset"`
	PageSize        int32       `json:"page_size"`
}

type SearchRoomsWithImageRow struct {
	ID                int64          `json:"id"`
	MerchantID        int64          `json:"merchant_id"`
	TableNo           string         `json:"table_no"`
	TableType         string         `json:"table_type"`
	Capacity          int16          `json:"capacity"`
	Description       pgtype.Text    `json:"description"`
	MinimumSpend      pgtype.Int8    `json:"minimum_spend"`
	QrCodeUrl         pgtype.Text    `json:"qr_code_url"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	MerchantName      string         `json:"merchant_name"`
	MerchantLogo      pgtype.Text    `json:"merchant_logo"`
	MerchantAddress   string         `json:"merchant_address"`
	MerchantLatitude  pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude pgtype.Numeric `json:"merchant_longitude"`
	PrimaryImage      string         `json:"primary_image"`
}

// 搜索包间（带主图），增强版 SearchRooms
func (q *Queries) SearchRoomsWithImage(ctx context.Context, arg SearchRoomsWithImageParams) ([]SearchRoomsWithImageRow, error) {
	rows, err := q.db.Query(ctx, searchRoomsWithImage,
		arg.RegionID,
		arg.MinCapacity,
		arg.MaxCapacity,
		arg.MaxMinimumSpend,
		arg.ReservationDate,
		arg.ReservationTime,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRoomsWithImageRow{}
	for rows.Next() {
		var i SearchRoomsWithImageRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.TableNo,
			&i.TableType,
			&i.Capacity,
			&i.Description,
			&i.MinimumSpend,
			&i.QrCodeUrl,
			&i.Status,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantAddress,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPrimaryTableImage = `-- name: SetPrimaryTableImage :exec
UPDATE table_images SET is_primary = FALSE WHERE table_id = $1
`

// 先清除所有主图标记，再设置新的主图
func (q *Queries) SetPrimaryTableImage(ctx context.Context, tableID int64) error {
	_, err := q.db.Exec(ctx, setPrimaryTableImage, tableID)
	return err
}

const setTableImagePrimary = `-- name: SetTableImagePrimary :one
UPDATE table_images SET is_primary = TRUE WHERE id = $1 RETURNING id, table_id, image_url, sort_order, is_primary, created_at
`

func (q *Queries) SetTableImagePrimary(ctx context.Context, id int64) (TableImage, error) {
	row := q.db.QueryRow(ctx, setTableImagePrimary, id)
	var i TableImage
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.ImageUrl,
		&i.SortOrder,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const updateTable = `-- name: UpdateTable :one
UPDATE tables
SET table_no = COALESCE($1, table_no),
    capacity = COALESCE($2, capacity),
    description = COALESCE($3, description),
    minimum_spend = COALESCE($4, minimum_spend),
    qr_code_url = COALESCE($5, qr_code_url),
    status = COALESCE($6, status),
    updated_at = now()
WHERE id = $7
RETURNING id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at
`

type UpdateTableParams struct {
	TableNo      pgtype.Text `json:"table_no"`
	Capacity     pgtype.Int2 `json:"capacity"`
	Description  pgtype.Text `json:"description"`
	MinimumSpend pgtype.Int8 `json:"minimum_spend"`
	QrCodeUrl    pgtype.Text `json:"qr_code_url"`
	Status       pgtype.Text `json:"status"`
	ID           int64       `json:"id"`
}

func (q *Queries) UpdateTable(ctx context.Context, arg UpdateTableParams) (Table, error) {
	row := q.db.QueryRow(ctx, updateTable,
		arg.TableNo,
		arg.Capacity,
		arg.Description,
		arg.MinimumSpend,
		arg.QrCodeUrl,
		arg.Status,
		arg.ID,
	)
	var i Table
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.QrCodeUrl,
		&i.Status,
		&i.CurrentReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTableImage = `-- name: UpdateTableImage :one
UPDATE table_images
SET sort_order = COALESCE($1, sort_order),
    is_primary = COALESCE($2, is_primary)
WHERE id = $3
RETURNING id, table_id, image_url, sort_order, is_primary, created_at
`

type UpdateTableImageParams struct {
	SortOrder pgtype.Int4 `json:"sort_order"`
	IsPrimary pgtype.Bool `json:"is_primary"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateTableImage(ctx context.Context, arg UpdateTableImageParams) (TableImage, error) {
	row := q.db.QueryRow(ctx, updateTableImage, arg.SortOrder, arg.IsPrimary, arg.ID)
	var i TableImage
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.ImageUrl,
		&i.SortOrder,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const updateTableStatus = `-- name: UpdateTableStatus :one
UPDATE tables
SET status = $2,
    current_reservation_id = $3,
    updated_at = now()
WHERE id = $1
RETURNING id, merchant_id, table_no, table_type, capacity, description, minimum_spend, qr_code_url, status, current_reservation_id, created_at, updated_at
`

type UpdateTableStatusParams struct {
	ID                   int64       `json:"id"`
	Status               string      `json:"status"`
	CurrentReservationID pgtype.Int8 `json:"current_reservation_id"`
}

func (q *Queries) UpdateTableStatus(ctx context.Context, arg UpdateTableStatusParams) (Table, error) {
	row := q.db.QueryRow(ctx, updateTableStatus, arg.ID, arg.Status, arg.CurrentReservationID)
	var i Table
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
		&i.Description,
		&i.MinimumSpend,
		&i.QrCodeUrl,
		&i.Status,
		&i.CurrentReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
