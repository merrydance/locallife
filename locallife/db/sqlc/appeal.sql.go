// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: appeal.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAppealExists = `-- name: CheckAppealExists :one

SELECT EXISTS (
    SELECT 1 FROM appeals WHERE claim_id = $1
) AS exists
`

// =========================== 通用查询 ===========================
// 检查索赔是否已有申诉
func (q *Queries) CheckAppealExists(ctx context.Context, claimID int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkAppealExists, claimID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countMerchantAppealsForMerchant = `-- name: CountMerchantAppealsForMerchant :one
SELECT COUNT(*) FROM appeals
WHERE appellant_type = 'merchant'
  AND appellant_id = $1
`

// 商户申诉计数
func (q *Queries) CountMerchantAppealsForMerchant(ctx context.Context, appellantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantAppealsForMerchant, appellantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMerchantClaimsForMerchant = `-- name: CountMerchantClaimsForMerchant :one
SELECT COUNT(*) 
FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE o.merchant_id = $1
  AND c.status IN ('approved', 'auto-approved')
`

// 商户收到的索赔计数
func (q *Queries) CountMerchantClaimsForMerchant(ctx context.Context, merchantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantClaimsForMerchant, merchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOperatorAppeals = `-- name: CountOperatorAppeals :one
SELECT COUNT(*) FROM appeals
WHERE region_id = $1
  AND (NULLIF($2::TEXT, '') IS NULL OR status = $2)
`

type CountOperatorAppealsParams struct {
	RegionID int64  `json:"region_id"`
	Column2  string `json:"column_2"`
}

// 运营商申诉计数
func (q *Queries) CountOperatorAppeals(ctx context.Context, arg CountOperatorAppealsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOperatorAppeals, arg.RegionID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRiderAppeals = `-- name: CountRiderAppeals :one
SELECT COUNT(*) FROM appeals
WHERE appellant_type = 'rider'
  AND appellant_id = $1
`

// 骑手申诉计数
func (q *Queries) CountRiderAppeals(ctx context.Context, appellantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countRiderAppeals, appellantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRiderClaimsForRider = `-- name: CountRiderClaimsForRider :one
SELECT COUNT(*) 
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN deliveries d ON d.order_id = o.id
WHERE d.rider_id = $1
  AND c.status IN ('approved', 'auto-approved')
`

// 骑手收到的索赔计数
func (q *Queries) CountRiderClaimsForRider(ctx context.Context, riderID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countRiderClaimsForRider, riderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAppeal = `-- name: CreateAppeal :one


INSERT INTO appeals (
    claim_id,
    appellant_type,
    appellant_id,
    reason,
    evidence_urls,
    region_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, claim_id, appellant_type, appellant_id, reason, evidence_urls, status, reviewer_id, review_notes, reviewed_at, compensation_amount, compensated_at, region_id, created_at
`

type CreateAppealParams struct {
	ClaimID       int64    `json:"claim_id"`
	AppellantType string   `json:"appellant_type"`
	AppellantID   int64    `json:"appellant_id"`
	Reason        string   `json:"reason"`
	EvidenceUrls  []string `json:"evidence_urls"`
	RegionID      int64    `json:"region_id"`
}

// =====================================================================
// Appeal Queries - 申诉相关查询
// =====================================================================
// =========================== 商户申诉 ===========================
// 创建申诉
func (q *Queries) CreateAppeal(ctx context.Context, arg CreateAppealParams) (Appeal, error) {
	row := q.db.QueryRow(ctx, createAppeal,
		arg.ClaimID,
		arg.AppellantType,
		arg.AppellantID,
		arg.Reason,
		arg.EvidenceUrls,
		arg.RegionID,
	)
	var i Appeal
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
	)
	return i, err
}

const getAppeal = `-- name: GetAppeal :one
SELECT id, claim_id, appellant_type, appellant_id, reason, evidence_urls, status, reviewer_id, review_notes, reviewed_at, compensation_amount, compensated_at, region_id, created_at FROM appeals
WHERE id = $1
LIMIT 1
`

// 获取申诉详情
func (q *Queries) GetAppeal(ctx context.Context, id int64) (Appeal, error) {
	row := q.db.QueryRow(ctx, getAppeal, id)
	var i Appeal
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
	)
	return i, err
}

const getAppealByClaim = `-- name: GetAppealByClaim :one
SELECT id, claim_id, appellant_type, appellant_id, reason, evidence_urls, status, reviewer_id, review_notes, reviewed_at, compensation_amount, compensated_at, region_id, created_at FROM appeals
WHERE claim_id = $1
LIMIT 1
`

// 根据索赔ID获取申诉
func (q *Queries) GetAppealByClaim(ctx context.Context, claimID int64) (Appeal, error) {
	row := q.db.QueryRow(ctx, getAppealByClaim, claimID)
	var i Appeal
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
	)
	return i, err
}

const getAppealForPostProcess = `-- name: GetAppealForPostProcess :one
SELECT 
    a.id AS appeal_id,
    a.claim_id,
    a.appellant_type,
    a.appellant_id,
    a.status AS appeal_status,
    a.compensation_amount,
    c.user_id AS claimant_user_id,
    c.claim_type,
    c.claim_amount,
    c.approved_amount AS claim_approved_amount,
    c.order_id,
    o.order_no,
    o.merchant_id,
    d.rider_id
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
LEFT JOIN deliveries d ON d.order_id = o.id
WHERE a.id = $1
`

type GetAppealForPostProcessRow struct {
	AppealID            int64       `json:"appeal_id"`
	ClaimID             int64       `json:"claim_id"`
	AppellantType       string      `json:"appellant_type"`
	AppellantID         int64       `json:"appellant_id"`
	AppealStatus        string      `json:"appeal_status"`
	CompensationAmount  pgtype.Int8 `json:"compensation_amount"`
	ClaimantUserID      int64       `json:"claimant_user_id"`
	ClaimType           string      `json:"claim_type"`
	ClaimAmount         int64       `json:"claim_amount"`
	ClaimApprovedAmount pgtype.Int8 `json:"claim_approved_amount"`
	OrderID             int64       `json:"order_id"`
	OrderNo             string      `json:"order_no"`
	MerchantID          int64       `json:"merchant_id"`
	RiderID             pgtype.Int8 `json:"rider_id"`
}

// 获取申诉审核后处理所需信息
func (q *Queries) GetAppealForPostProcess(ctx context.Context, id int64) (GetAppealForPostProcessRow, error) {
	row := q.db.QueryRow(ctx, getAppealForPostProcess, id)
	var i GetAppealForPostProcessRow
	err := row.Scan(
		&i.AppealID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.AppealStatus,
		&i.CompensationAmount,
		&i.ClaimantUserID,
		&i.ClaimType,
		&i.ClaimAmount,
		&i.ClaimApprovedAmount,
		&i.OrderID,
		&i.OrderNo,
		&i.MerchantID,
		&i.RiderID,
	)
	return i, err
}

const getAppealWithDetails = `-- name: GetAppealWithDetails :one
SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.approved_amount AS claim_approved_amount,
    c.description AS claim_description,
    c.evidence_urls AS claim_evidence_urls,
    c.status AS claim_status,
    c.created_at AS claim_created_at,
    o.order_no,
    o.total_amount AS order_amount,
    o.status AS order_status,
    o.created_at AS order_created_at,
    u.phone AS user_phone,
    u.full_name AS user_name
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
JOIN users u ON c.user_id = u.id
WHERE a.id = $1
LIMIT 1
`

type GetAppealWithDetailsRow struct {
	ID                  int64              `json:"id"`
	ClaimID             int64              `json:"claim_id"`
	AppellantType       string             `json:"appellant_type"`
	AppellantID         int64              `json:"appellant_id"`
	Reason              string             `json:"reason"`
	EvidenceUrls        []string           `json:"evidence_urls"`
	Status              string             `json:"status"`
	ReviewerID          pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes         pgtype.Text        `json:"review_notes"`
	ReviewedAt          pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount  pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt       pgtype.Timestamptz `json:"compensated_at"`
	RegionID            int64              `json:"region_id"`
	CreatedAt           time.Time          `json:"created_at"`
	ClaimType           string             `json:"claim_type"`
	ClaimAmount         int64              `json:"claim_amount"`
	ClaimApprovedAmount pgtype.Int8        `json:"claim_approved_amount"`
	ClaimDescription    string             `json:"claim_description"`
	ClaimEvidenceUrls   []string           `json:"claim_evidence_urls"`
	ClaimStatus         string             `json:"claim_status"`
	ClaimCreatedAt      time.Time          `json:"claim_created_at"`
	OrderNo             string             `json:"order_no"`
	OrderAmount         int64              `json:"order_amount"`
	OrderStatus         string             `json:"order_status"`
	OrderCreatedAt      time.Time          `json:"order_created_at"`
	UserPhone           pgtype.Text        `json:"user_phone"`
	UserName            string             `json:"user_name"`
}

// 获取申诉详情（包含索赔和订单信息）
func (q *Queries) GetAppealWithDetails(ctx context.Context, id int64) (GetAppealWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getAppealWithDetails, id)
	var i GetAppealWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
		&i.ClaimType,
		&i.ClaimAmount,
		&i.ClaimApprovedAmount,
		&i.ClaimDescription,
		&i.ClaimEvidenceUrls,
		&i.ClaimStatus,
		&i.ClaimCreatedAt,
		&i.OrderNo,
		&i.OrderAmount,
		&i.OrderStatus,
		&i.OrderCreatedAt,
		&i.UserPhone,
		&i.UserName,
	)
	return i, err
}

const getClaimForAppeal = `-- name: GetClaimForAppeal :one
SELECT 
    c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at,
    o.merchant_id,
    m.region_id,
    d.rider_id
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN merchants m ON o.merchant_id = m.id
LEFT JOIN deliveries d ON d.order_id = o.id
WHERE c.id = $1
  AND c.status IN ('approved', 'auto-approved')
LIMIT 1
`

type GetClaimForAppealRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	MerchantID         int64              `json:"merchant_id"`
	RegionID           int64              `json:"region_id"`
	RiderID            pgtype.Int8        `json:"rider_id"`
}

// 获取索赔信息（用于创建申诉时验证）
func (q *Queries) GetClaimForAppeal(ctx context.Context, id int64) (GetClaimForAppealRow, error) {
	row := q.db.QueryRow(ctx, getClaimForAppeal, id)
	var i GetClaimForAppealRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
		&i.MerchantID,
		&i.RegionID,
		&i.RiderID,
	)
	return i, err
}

const getMerchantAppealDetail = `-- name: GetMerchantAppealDetail :one
SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.approved_amount AS claim_approved_amount,
    c.description AS claim_description,
    c.evidence_urls AS claim_evidence_urls,
    o.order_no,
    o.total_amount AS order_amount,
    u.phone AS user_phone
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
JOIN users u ON c.user_id = u.id
WHERE a.id = $1
  AND a.appellant_type = 'merchant'
  AND a.appellant_id = $2
LIMIT 1
`

type GetMerchantAppealDetailParams struct {
	ID          int64 `json:"id"`
	AppellantID int64 `json:"appellant_id"`
}

type GetMerchantAppealDetailRow struct {
	ID                  int64              `json:"id"`
	ClaimID             int64              `json:"claim_id"`
	AppellantType       string             `json:"appellant_type"`
	AppellantID         int64              `json:"appellant_id"`
	Reason              string             `json:"reason"`
	EvidenceUrls        []string           `json:"evidence_urls"`
	Status              string             `json:"status"`
	ReviewerID          pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes         pgtype.Text        `json:"review_notes"`
	ReviewedAt          pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount  pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt       pgtype.Timestamptz `json:"compensated_at"`
	RegionID            int64              `json:"region_id"`
	CreatedAt           time.Time          `json:"created_at"`
	ClaimType           string             `json:"claim_type"`
	ClaimAmount         int64              `json:"claim_amount"`
	ClaimApprovedAmount pgtype.Int8        `json:"claim_approved_amount"`
	ClaimDescription    string             `json:"claim_description"`
	ClaimEvidenceUrls   []string           `json:"claim_evidence_urls"`
	OrderNo             string             `json:"order_no"`
	OrderAmount         int64              `json:"order_amount"`
	UserPhone           pgtype.Text        `json:"user_phone"`
}

// 商户查看自己的申诉详情
func (q *Queries) GetMerchantAppealDetail(ctx context.Context, arg GetMerchantAppealDetailParams) (GetMerchantAppealDetailRow, error) {
	row := q.db.QueryRow(ctx, getMerchantAppealDetail, arg.ID, arg.AppellantID)
	var i GetMerchantAppealDetailRow
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
		&i.ClaimType,
		&i.ClaimAmount,
		&i.ClaimApprovedAmount,
		&i.ClaimDescription,
		&i.ClaimEvidenceUrls,
		&i.OrderNo,
		&i.OrderAmount,
		&i.UserPhone,
	)
	return i, err
}

const getMerchantClaimDetailForMerchant = `-- name: GetMerchantClaimDetailForMerchant :one
SELECT 
    c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at,
    o.order_no,
    o.total_amount AS order_amount,
    o.created_at AS order_created_at,
    u.phone AS user_phone,
    u.full_name AS user_name,
    a.id AS appeal_id,
    a.status AS appeal_status,
    a.reason AS appeal_reason,
    a.review_notes AS appeal_review_notes
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN users u ON c.user_id = u.id
LEFT JOIN appeals a ON a.claim_id = c.id AND a.appellant_type = 'merchant'
WHERE c.id = $1
  AND o.merchant_id = $2
LIMIT 1
`

type GetMerchantClaimDetailForMerchantParams struct {
	ID         int64 `json:"id"`
	MerchantID int64 `json:"merchant_id"`
}

type GetMerchantClaimDetailForMerchantRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	OrderNo            string             `json:"order_no"`
	OrderAmount        int64              `json:"order_amount"`
	OrderCreatedAt     time.Time          `json:"order_created_at"`
	UserPhone          pgtype.Text        `json:"user_phone"`
	UserName           string             `json:"user_name"`
	AppealID           pgtype.Int8        `json:"appeal_id"`
	AppealStatus       pgtype.Text        `json:"appeal_status"`
	AppealReason       pgtype.Text        `json:"appeal_reason"`
	AppealReviewNotes  pgtype.Text        `json:"appeal_review_notes"`
}

// 商户查看索赔详情
func (q *Queries) GetMerchantClaimDetailForMerchant(ctx context.Context, arg GetMerchantClaimDetailForMerchantParams) (GetMerchantClaimDetailForMerchantRow, error) {
	row := q.db.QueryRow(ctx, getMerchantClaimDetailForMerchant, arg.ID, arg.MerchantID)
	var i GetMerchantClaimDetailForMerchantRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
		&i.OrderNo,
		&i.OrderAmount,
		&i.OrderCreatedAt,
		&i.UserPhone,
		&i.UserName,
		&i.AppealID,
		&i.AppealStatus,
		&i.AppealReason,
		&i.AppealReviewNotes,
	)
	return i, err
}

const getOperatorAppealDetail = `-- name: GetOperatorAppealDetail :one
SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.approved_amount AS claim_approved_amount,
    c.description AS claim_description,
    c.evidence_urls AS claim_evidence_urls,
    c.status AS claim_status,
    c.trust_score_snapshot AS user_trust_score,
    c.lookback_result,
    c.created_at AS claim_created_at,
    o.order_no,
    o.total_amount AS order_amount,
    o.status AS order_status,
    o.created_at AS order_created_at,
    o.merchant_id,
    m.name AS merchant_name,
    m.phone AS merchant_phone,
    u.phone AS user_phone,
    u.full_name AS user_name,
    d.rider_id
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
JOIN merchants m ON o.merchant_id = m.id
JOIN users u ON c.user_id = u.id
LEFT JOIN deliveries d ON d.order_id = o.id
WHERE a.id = $1
  AND a.region_id = $2
LIMIT 1
`

type GetOperatorAppealDetailParams struct {
	ID       int64 `json:"id"`
	RegionID int64 `json:"region_id"`
}

type GetOperatorAppealDetailRow struct {
	ID                  int64              `json:"id"`
	ClaimID             int64              `json:"claim_id"`
	AppellantType       string             `json:"appellant_type"`
	AppellantID         int64              `json:"appellant_id"`
	Reason              string             `json:"reason"`
	EvidenceUrls        []string           `json:"evidence_urls"`
	Status              string             `json:"status"`
	ReviewerID          pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes         pgtype.Text        `json:"review_notes"`
	ReviewedAt          pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount  pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt       pgtype.Timestamptz `json:"compensated_at"`
	RegionID            int64              `json:"region_id"`
	CreatedAt           time.Time          `json:"created_at"`
	ClaimType           string             `json:"claim_type"`
	ClaimAmount         int64              `json:"claim_amount"`
	ClaimApprovedAmount pgtype.Int8        `json:"claim_approved_amount"`
	ClaimDescription    string             `json:"claim_description"`
	ClaimEvidenceUrls   []string           `json:"claim_evidence_urls"`
	ClaimStatus         string             `json:"claim_status"`
	UserTrustScore      pgtype.Int2        `json:"user_trust_score"`
	LookbackResult      []byte             `json:"lookback_result"`
	ClaimCreatedAt      time.Time          `json:"claim_created_at"`
	OrderNo             string             `json:"order_no"`
	OrderAmount         int64              `json:"order_amount"`
	OrderStatus         string             `json:"order_status"`
	OrderCreatedAt      time.Time          `json:"order_created_at"`
	MerchantID          int64              `json:"merchant_id"`
	MerchantName        string             `json:"merchant_name"`
	MerchantPhone       string             `json:"merchant_phone"`
	UserPhone           pgtype.Text        `json:"user_phone"`
	UserName            string             `json:"user_name"`
	RiderID             pgtype.Int8        `json:"rider_id"`
}

// 运营商查看申诉详情
func (q *Queries) GetOperatorAppealDetail(ctx context.Context, arg GetOperatorAppealDetailParams) (GetOperatorAppealDetailRow, error) {
	row := q.db.QueryRow(ctx, getOperatorAppealDetail, arg.ID, arg.RegionID)
	var i GetOperatorAppealDetailRow
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
		&i.ClaimType,
		&i.ClaimAmount,
		&i.ClaimApprovedAmount,
		&i.ClaimDescription,
		&i.ClaimEvidenceUrls,
		&i.ClaimStatus,
		&i.UserTrustScore,
		&i.LookbackResult,
		&i.ClaimCreatedAt,
		&i.OrderNo,
		&i.OrderAmount,
		&i.OrderStatus,
		&i.OrderCreatedAt,
		&i.MerchantID,
		&i.MerchantName,
		&i.MerchantPhone,
		&i.UserPhone,
		&i.UserName,
		&i.RiderID,
	)
	return i, err
}

const getRiderAppealDetail = `-- name: GetRiderAppealDetail :one
SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.approved_amount AS claim_approved_amount,
    c.description AS claim_description,
    c.evidence_urls AS claim_evidence_urls,
    o.order_no,
    o.total_amount AS order_amount,
    u.phone AS user_phone
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
JOIN users u ON c.user_id = u.id
WHERE a.id = $1
  AND a.appellant_type = 'rider'
  AND a.appellant_id = $2
LIMIT 1
`

type GetRiderAppealDetailParams struct {
	ID          int64 `json:"id"`
	AppellantID int64 `json:"appellant_id"`
}

type GetRiderAppealDetailRow struct {
	ID                  int64              `json:"id"`
	ClaimID             int64              `json:"claim_id"`
	AppellantType       string             `json:"appellant_type"`
	AppellantID         int64              `json:"appellant_id"`
	Reason              string             `json:"reason"`
	EvidenceUrls        []string           `json:"evidence_urls"`
	Status              string             `json:"status"`
	ReviewerID          pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes         pgtype.Text        `json:"review_notes"`
	ReviewedAt          pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount  pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt       pgtype.Timestamptz `json:"compensated_at"`
	RegionID            int64              `json:"region_id"`
	CreatedAt           time.Time          `json:"created_at"`
	ClaimType           string             `json:"claim_type"`
	ClaimAmount         int64              `json:"claim_amount"`
	ClaimApprovedAmount pgtype.Int8        `json:"claim_approved_amount"`
	ClaimDescription    string             `json:"claim_description"`
	ClaimEvidenceUrls   []string           `json:"claim_evidence_urls"`
	OrderNo             string             `json:"order_no"`
	OrderAmount         int64              `json:"order_amount"`
	UserPhone           pgtype.Text        `json:"user_phone"`
}

// 骑手查看自己的申诉详情
func (q *Queries) GetRiderAppealDetail(ctx context.Context, arg GetRiderAppealDetailParams) (GetRiderAppealDetailRow, error) {
	row := q.db.QueryRow(ctx, getRiderAppealDetail, arg.ID, arg.AppellantID)
	var i GetRiderAppealDetailRow
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
		&i.ClaimType,
		&i.ClaimAmount,
		&i.ClaimApprovedAmount,
		&i.ClaimDescription,
		&i.ClaimEvidenceUrls,
		&i.OrderNo,
		&i.OrderAmount,
		&i.UserPhone,
	)
	return i, err
}

const getRiderClaimDetailForRider = `-- name: GetRiderClaimDetailForRider :one
SELECT 
    c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at,
    o.order_no,
    o.total_amount AS order_amount,
    o.created_at AS order_created_at,
    u.phone AS user_phone,
    u.full_name AS user_name,
    a.id AS appeal_id,
    a.status AS appeal_status,
    a.reason AS appeal_reason,
    a.review_notes AS appeal_review_notes
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN deliveries d ON d.order_id = o.id
JOIN users u ON c.user_id = u.id
LEFT JOIN appeals a ON a.claim_id = c.id AND a.appellant_type = 'rider'
WHERE c.id = $1
  AND d.rider_id = $2
LIMIT 1
`

type GetRiderClaimDetailForRiderParams struct {
	ID      int64       `json:"id"`
	RiderID pgtype.Int8 `json:"rider_id"`
}

type GetRiderClaimDetailForRiderRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	OrderNo            string             `json:"order_no"`
	OrderAmount        int64              `json:"order_amount"`
	OrderCreatedAt     time.Time          `json:"order_created_at"`
	UserPhone          pgtype.Text        `json:"user_phone"`
	UserName           string             `json:"user_name"`
	AppealID           pgtype.Int8        `json:"appeal_id"`
	AppealStatus       pgtype.Text        `json:"appeal_status"`
	AppealReason       pgtype.Text        `json:"appeal_reason"`
	AppealReviewNotes  pgtype.Text        `json:"appeal_review_notes"`
}

// 骑手查看索赔详情
func (q *Queries) GetRiderClaimDetailForRider(ctx context.Context, arg GetRiderClaimDetailForRiderParams) (GetRiderClaimDetailForRiderRow, error) {
	row := q.db.QueryRow(ctx, getRiderClaimDetailForRider, arg.ID, arg.RiderID)
	var i GetRiderClaimDetailForRiderRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
		&i.OrderNo,
		&i.OrderAmount,
		&i.OrderCreatedAt,
		&i.UserPhone,
		&i.UserName,
		&i.AppealID,
		&i.AppealStatus,
		&i.AppealReason,
		&i.AppealReviewNotes,
	)
	return i, err
}

const listMerchantAppealsForMerchant = `-- name: ListMerchantAppealsForMerchant :many

SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.description AS claim_description,
    o.order_no
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
WHERE a.appellant_type = 'merchant'
  AND a.appellant_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantAppealsForMerchantParams struct {
	AppellantID int64 `json:"appellant_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListMerchantAppealsForMerchantRow struct {
	ID                 int64              `json:"id"`
	ClaimID            int64              `json:"claim_id"`
	AppellantType      string             `json:"appellant_type"`
	AppellantID        int64              `json:"appellant_id"`
	Reason             string             `json:"reason"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	Status             string             `json:"status"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt      pgtype.Timestamptz `json:"compensated_at"`
	RegionID           int64              `json:"region_id"`
	CreatedAt          time.Time          `json:"created_at"`
	ClaimType          string             `json:"claim_type"`
	ClaimAmount        int64              `json:"claim_amount"`
	ClaimDescription   string             `json:"claim_description"`
	OrderNo            string             `json:"order_no"`
}

// =========================== 商户视角 ===========================
// 商户查询自己的申诉列表
func (q *Queries) ListMerchantAppealsForMerchant(ctx context.Context, arg ListMerchantAppealsForMerchantParams) ([]ListMerchantAppealsForMerchantRow, error) {
	rows, err := q.db.Query(ctx, listMerchantAppealsForMerchant, arg.AppellantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantAppealsForMerchantRow{}
	for rows.Next() {
		var i ListMerchantAppealsForMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.ClaimID,
			&i.AppellantType,
			&i.AppellantID,
			&i.Reason,
			&i.EvidenceUrls,
			&i.Status,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ReviewedAt,
			&i.CompensationAmount,
			&i.CompensatedAt,
			&i.RegionID,
			&i.CreatedAt,
			&i.ClaimType,
			&i.ClaimAmount,
			&i.ClaimDescription,
			&i.OrderNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantClaimsForMerchant = `-- name: ListMerchantClaimsForMerchant :many
SELECT 
    c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at,
    o.order_no,
    o.total_amount AS order_amount,
    u.phone AS user_phone,
    u.full_name AS user_name,
    a.id AS appeal_id,
    a.status AS appeal_status
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN users u ON c.user_id = u.id
LEFT JOIN appeals a ON a.claim_id = c.id AND a.appellant_type = 'merchant'
WHERE o.merchant_id = $1
  AND c.status IN ('approved', 'auto-approved')
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantClaimsForMerchantParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type ListMerchantClaimsForMerchantRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	OrderNo            string             `json:"order_no"`
	OrderAmount        int64              `json:"order_amount"`
	UserPhone          pgtype.Text        `json:"user_phone"`
	UserName           string             `json:"user_name"`
	AppealID           pgtype.Int8        `json:"appeal_id"`
	AppealStatus       pgtype.Text        `json:"appeal_status"`
}

// 商户查看收到的索赔列表（未申诉的+已申诉的）
func (q *Queries) ListMerchantClaimsForMerchant(ctx context.Context, arg ListMerchantClaimsForMerchantParams) ([]ListMerchantClaimsForMerchantRow, error) {
	rows, err := q.db.Query(ctx, listMerchantClaimsForMerchant, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantClaimsForMerchantRow{}
	for rows.Next() {
		var i ListMerchantClaimsForMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
			&i.OrderNo,
			&i.OrderAmount,
			&i.UserPhone,
			&i.UserName,
			&i.AppealID,
			&i.AppealStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperatorAppeals = `-- name: ListOperatorAppeals :many

SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.description AS claim_description,
    o.order_no,
    o.merchant_id,
    m.name AS merchant_name,
    CASE 
        WHEN a.appellant_type = 'merchant' THEN m.name
        ELSE (SELECT phone FROM riders WHERE id = a.appellant_id)
    END AS appellant_name
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
JOIN merchants m ON o.merchant_id = m.id
WHERE a.region_id = $1
  AND (NULLIF($2::TEXT, '') IS NULL OR a.status = $2)
ORDER BY 
    CASE WHEN a.status = 'pending' THEN 0 ELSE 1 END,
    a.created_at DESC
LIMIT $3 OFFSET $4
`

type ListOperatorAppealsParams struct {
	RegionID int64  `json:"region_id"`
	Column2  string `json:"column_2"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type ListOperatorAppealsRow struct {
	ID                 int64              `json:"id"`
	ClaimID            int64              `json:"claim_id"`
	AppellantType      string             `json:"appellant_type"`
	AppellantID        int64              `json:"appellant_id"`
	Reason             string             `json:"reason"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	Status             string             `json:"status"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt      pgtype.Timestamptz `json:"compensated_at"`
	RegionID           int64              `json:"region_id"`
	CreatedAt          time.Time          `json:"created_at"`
	ClaimType          string             `json:"claim_type"`
	ClaimAmount        int64              `json:"claim_amount"`
	ClaimDescription   string             `json:"claim_description"`
	OrderNo            string             `json:"order_no"`
	MerchantID         int64              `json:"merchant_id"`
	MerchantName       string             `json:"merchant_name"`
	AppellantName      interface{}        `json:"appellant_name"`
}

// =========================== 运营商视角 ===========================
// 运营商查询区域内的申诉列表
func (q *Queries) ListOperatorAppeals(ctx context.Context, arg ListOperatorAppealsParams) ([]ListOperatorAppealsRow, error) {
	rows, err := q.db.Query(ctx, listOperatorAppeals,
		arg.RegionID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOperatorAppealsRow{}
	for rows.Next() {
		var i ListOperatorAppealsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClaimID,
			&i.AppellantType,
			&i.AppellantID,
			&i.Reason,
			&i.EvidenceUrls,
			&i.Status,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ReviewedAt,
			&i.CompensationAmount,
			&i.CompensatedAt,
			&i.RegionID,
			&i.CreatedAt,
			&i.ClaimType,
			&i.ClaimAmount,
			&i.ClaimDescription,
			&i.OrderNo,
			&i.MerchantID,
			&i.MerchantName,
			&i.AppellantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderAppeals = `-- name: ListRiderAppeals :many

SELECT 
    a.id, a.claim_id, a.appellant_type, a.appellant_id, a.reason, a.evidence_urls, a.status, a.reviewer_id, a.review_notes, a.reviewed_at, a.compensation_amount, a.compensated_at, a.region_id, a.created_at,
    c.claim_type,
    c.claim_amount,
    c.description AS claim_description,
    o.order_no
FROM appeals a
JOIN claims c ON a.claim_id = c.id
JOIN orders o ON c.order_id = o.id
WHERE a.appellant_type = 'rider'
  AND a.appellant_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListRiderAppealsParams struct {
	AppellantID int64 `json:"appellant_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListRiderAppealsRow struct {
	ID                 int64              `json:"id"`
	ClaimID            int64              `json:"claim_id"`
	AppellantType      string             `json:"appellant_type"`
	AppellantID        int64              `json:"appellant_id"`
	Reason             string             `json:"reason"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	Status             string             `json:"status"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	CompensationAmount pgtype.Int8        `json:"compensation_amount"`
	CompensatedAt      pgtype.Timestamptz `json:"compensated_at"`
	RegionID           int64              `json:"region_id"`
	CreatedAt          time.Time          `json:"created_at"`
	ClaimType          string             `json:"claim_type"`
	ClaimAmount        int64              `json:"claim_amount"`
	ClaimDescription   string             `json:"claim_description"`
	OrderNo            string             `json:"order_no"`
}

// =========================== 骑手视角 ===========================
// 骑手查询自己的申诉列表
func (q *Queries) ListRiderAppeals(ctx context.Context, arg ListRiderAppealsParams) ([]ListRiderAppealsRow, error) {
	rows, err := q.db.Query(ctx, listRiderAppeals, arg.AppellantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRiderAppealsRow{}
	for rows.Next() {
		var i ListRiderAppealsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClaimID,
			&i.AppellantType,
			&i.AppellantID,
			&i.Reason,
			&i.EvidenceUrls,
			&i.Status,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ReviewedAt,
			&i.CompensationAmount,
			&i.CompensatedAt,
			&i.RegionID,
			&i.CreatedAt,
			&i.ClaimType,
			&i.ClaimAmount,
			&i.ClaimDescription,
			&i.OrderNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderClaimsForRider = `-- name: ListRiderClaimsForRider :many
SELECT 
    c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at,
    o.order_no,
    o.total_amount AS order_amount,
    u.phone AS user_phone,
    u.full_name AS user_name,
    a.id AS appeal_id,
    a.status AS appeal_status
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN deliveries d ON d.order_id = o.id
JOIN users u ON c.user_id = u.id
LEFT JOIN appeals a ON a.claim_id = c.id AND a.appellant_type = 'rider'
WHERE d.rider_id = $1
  AND c.status IN ('approved', 'auto-approved')
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type ListRiderClaimsForRiderParams struct {
	RiderID pgtype.Int8 `json:"rider_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListRiderClaimsForRiderRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	OrderNo            string             `json:"order_no"`
	OrderAmount        int64              `json:"order_amount"`
	UserPhone          pgtype.Text        `json:"user_phone"`
	UserName           string             `json:"user_name"`
	AppealID           pgtype.Int8        `json:"appeal_id"`
	AppealStatus       pgtype.Text        `json:"appeal_status"`
}

// 骑手查看收到的索赔列表（通过配送单关联）
func (q *Queries) ListRiderClaimsForRider(ctx context.Context, arg ListRiderClaimsForRiderParams) ([]ListRiderClaimsForRiderRow, error) {
	rows, err := q.db.Query(ctx, listRiderClaimsForRider, arg.RiderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRiderClaimsForRiderRow{}
	for rows.Next() {
		var i ListRiderClaimsForRiderRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
			&i.OrderNo,
			&i.OrderAmount,
			&i.UserPhone,
			&i.UserName,
			&i.AppealID,
			&i.AppealStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reviewAppeal = `-- name: ReviewAppeal :one
UPDATE appeals
SET status = $1,
    reviewer_id = $2,
    review_notes = $3,
    reviewed_at = NOW(),
    compensation_amount = CASE WHEN $1 = 'approved' THEN $4::bigint ELSE NULL END,
    compensated_at = CASE WHEN $1 = 'approved' THEN NOW() ELSE NULL END
WHERE id = $5
  AND status = 'pending'
RETURNING id, claim_id, appellant_type, appellant_id, reason, evidence_urls, status, reviewer_id, review_notes, reviewed_at, compensation_amount, compensated_at, region_id, created_at
`

type ReviewAppealParams struct {
	Status             string      `json:"status"`
	ReviewerID         pgtype.Int8 `json:"reviewer_id"`
	ReviewNotes        pgtype.Text `json:"review_notes"`
	CompensationAmount pgtype.Int8 `json:"compensation_amount"`
	ID                 int64       `json:"id"`
}

// 审核申诉
func (q *Queries) ReviewAppeal(ctx context.Context, arg ReviewAppealParams) (Appeal, error) {
	row := q.db.QueryRow(ctx, reviewAppeal,
		arg.Status,
		arg.ReviewerID,
		arg.ReviewNotes,
		arg.CompensationAmount,
		arg.ID,
	)
	var i Appeal
	err := row.Scan(
		&i.ID,
		&i.ClaimID,
		&i.AppellantType,
		&i.AppellantID,
		&i.Reason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ReviewedAt,
		&i.CompensationAmount,
		&i.CompensatedAt,
		&i.RegionID,
		&i.CreatedAt,
	)
	return i, err
}
