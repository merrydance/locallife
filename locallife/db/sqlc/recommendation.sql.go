// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recommendation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteExpiredRecommendations = `-- name: DeleteExpiredRecommendations :exec
DELETE FROM recommendations
WHERE expired_at <= now()
`

func (q *Queries) DeleteExpiredRecommendations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRecommendations)
	return err
}

const getAllRecommendationConfigs = `-- name: GetAllRecommendationConfigs :many
SELECT id, region_id, exploitation_ratio, exploration_ratio, random_ratio, auto_adjust, updated_at FROM recommendation_configs
ORDER BY region_id
`

func (q *Queries) GetAllRecommendationConfigs(ctx context.Context) ([]RecommendationConfig, error) {
	rows, err := q.db.Query(ctx, getAllRecommendationConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecommendationConfig{}
	for rows.Next() {
		var i RecommendationConfig
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.ExploitationRatio,
			&i.ExplorationRatio,
			&i.RandomRatio,
			&i.AutoAdjust,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestRecommendations = `-- name: GetLatestRecommendations :one
SELECT id, user_id, dish_ids, combo_ids, merchant_ids, algorithm, score, generated_at, expired_at FROM recommendations
WHERE user_id = $1
  AND expired_at > now()
ORDER BY generated_at DESC
LIMIT 1
`

func (q *Queries) GetLatestRecommendations(ctx context.Context, userID int64) (Recommendation, error) {
	row := q.db.QueryRow(ctx, getLatestRecommendations, userID)
	var i Recommendation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DishIds,
		&i.ComboIds,
		&i.MerchantIds,
		&i.Algorithm,
		&i.Score,
		&i.GeneratedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getRecommendationConfig = `-- name: GetRecommendationConfig :one

SELECT id, region_id, exploitation_ratio, exploration_ratio, random_ratio, auto_adjust, updated_at FROM recommendation_configs
WHERE region_id = $1
`

// ============================================================================
// 推荐配置管理（运营商）
// ============================================================================
func (q *Queries) GetRecommendationConfig(ctx context.Context, regionID int64) (RecommendationConfig, error) {
	row := q.db.QueryRow(ctx, getRecommendationConfig, regionID)
	var i RecommendationConfig
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.ExploitationRatio,
		&i.ExplorationRatio,
		&i.RandomRatio,
		&i.AutoAdjust,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBehaviorsByType = `-- name: GetUserBehaviorsByType :many
SELECT id, user_id, behavior_type, dish_id, combo_id, merchant_id, duration, created_at FROM user_behaviors
WHERE user_id = $1
  AND behavior_type = $2
  AND created_at >= $3
ORDER BY created_at DESC
LIMIT $4
`

type GetUserBehaviorsByTypeParams struct {
	UserID       int64     `json:"user_id"`
	BehaviorType string    `json:"behavior_type"`
	CreatedAt    time.Time `json:"created_at"`
	Limit        int32     `json:"limit"`
}

func (q *Queries) GetUserBehaviorsByType(ctx context.Context, arg GetUserBehaviorsByTypeParams) ([]UserBehavior, error) {
	rows, err := q.db.Query(ctx, getUserBehaviorsByType,
		arg.UserID,
		arg.BehaviorType,
		arg.CreatedAt,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserBehavior{}
	for rows.Next() {
		var i UserBehavior
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BehaviorType,
			&i.DishID,
			&i.ComboID,
			&i.MerchantID,
			&i.Duration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPreferences = `-- name: GetUserPreferences :one

SELECT id, user_id, cuisine_preferences, price_range_min, price_range_max, avg_order_amount, favorite_time_slots, purchase_frequency, last_order_date, top_cuisines, updated_at FROM user_preferences
WHERE user_id = $1
`

// ============================================================================
// 用户偏好管理
// ============================================================================
func (q *Queries) GetUserPreferences(ctx context.Context, userID int64) (UserPreference, error) {
	row := q.db.QueryRow(ctx, getUserPreferences, userID)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CuisinePreferences,
		&i.PriceRangeMin,
		&i.PriceRangeMax,
		&i.AvgOrderAmount,
		&i.FavoriteTimeSlots,
		&i.PurchaseFrequency,
		&i.LastOrderDate,
		&i.TopCuisines,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRecentBehaviors = `-- name: GetUserRecentBehaviors :many
SELECT id, user_id, behavior_type, dish_id, combo_id, merchant_id, duration, created_at FROM user_behaviors
WHERE user_id = $1
  AND created_at >= $2
ORDER BY created_at DESC
LIMIT $3
`

type GetUserRecentBehaviorsParams struct {
	UserID    int64     `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	Limit     int32     `json:"limit"`
}

func (q *Queries) GetUserRecentBehaviors(ctx context.Context, arg GetUserRecentBehaviorsParams) ([]UserBehavior, error) {
	rows, err := q.db.Query(ctx, getUserRecentBehaviors, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserBehavior{}
	for rows.Next() {
		var i UserBehavior
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BehaviorType,
			&i.DishID,
			&i.ComboID,
			&i.MerchantID,
			&i.Duration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveRecommendations = `-- name: SaveRecommendations :one

INSERT INTO recommendations (
  user_id,
  dish_ids,
  combo_ids,
  merchant_ids,
  algorithm,
  score,
  generated_at,
  expired_at
) VALUES (
  $1, $2, $3, $4, $5, $6, now(), $7
) RETURNING id, user_id, dish_ids, combo_ids, merchant_ids, algorithm, score, generated_at, expired_at
`

type SaveRecommendationsParams struct {
	UserID      int64          `json:"user_id"`
	DishIds     []int64        `json:"dish_ids"`
	ComboIds    []int64        `json:"combo_ids"`
	MerchantIds []int64        `json:"merchant_ids"`
	Algorithm   string         `json:"algorithm"`
	Score       pgtype.Numeric `json:"score"`
	ExpiredAt   time.Time      `json:"expired_at"`
}

// ============================================================================
// 推荐结果管理
// ============================================================================
func (q *Queries) SaveRecommendations(ctx context.Context, arg SaveRecommendationsParams) (Recommendation, error) {
	row := q.db.QueryRow(ctx, saveRecommendations,
		arg.UserID,
		arg.DishIds,
		arg.ComboIds,
		arg.MerchantIds,
		arg.Algorithm,
		arg.Score,
		arg.ExpiredAt,
	)
	var i Recommendation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DishIds,
		&i.ComboIds,
		&i.MerchantIds,
		&i.Algorithm,
		&i.Score,
		&i.GeneratedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const trackBehavior = `-- name: TrackBehavior :one


INSERT INTO user_behaviors (
  user_id,
  behavior_type,
  dish_id,
  combo_id,
  merchant_id,
  duration
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, behavior_type, dish_id, combo_id, merchant_id, duration, created_at
`

type TrackBehaviorParams struct {
	UserID       int64       `json:"user_id"`
	BehaviorType string      `json:"behavior_type"`
	DishID       pgtype.Int8 `json:"dish_id"`
	ComboID      pgtype.Int8 `json:"combo_id"`
	MerchantID   pgtype.Int8 `json:"merchant_id"`
	Duration     pgtype.Int4 `json:"duration"`
}

// M11: 千人千面推荐引擎 - SQLC查询
// ============================================================================
// 用户行为埋点
// ============================================================================
func (q *Queries) TrackBehavior(ctx context.Context, arg TrackBehaviorParams) (UserBehavior, error) {
	row := q.db.QueryRow(ctx, trackBehavior,
		arg.UserID,
		arg.BehaviorType,
		arg.DishID,
		arg.ComboID,
		arg.MerchantID,
		arg.Duration,
	)
	var i UserBehavior
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BehaviorType,
		&i.DishID,
		&i.ComboID,
		&i.MerchantID,
		&i.Duration,
		&i.CreatedAt,
	)
	return i, err
}

const upsertRecommendationConfig = `-- name: UpsertRecommendationConfig :one
INSERT INTO recommendation_configs (
  region_id,
  exploitation_ratio,
  exploration_ratio,
  random_ratio,
  auto_adjust,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, now()
)
ON CONFLICT (region_id)
DO UPDATE SET
  exploitation_ratio = EXCLUDED.exploitation_ratio,
  exploration_ratio = EXCLUDED.exploration_ratio,
  random_ratio = EXCLUDED.random_ratio,
  auto_adjust = EXCLUDED.auto_adjust,
  updated_at = now()
RETURNING id, region_id, exploitation_ratio, exploration_ratio, random_ratio, auto_adjust, updated_at
`

type UpsertRecommendationConfigParams struct {
	RegionID          int64          `json:"region_id"`
	ExploitationRatio pgtype.Numeric `json:"exploitation_ratio"`
	ExplorationRatio  pgtype.Numeric `json:"exploration_ratio"`
	RandomRatio       pgtype.Numeric `json:"random_ratio"`
	AutoAdjust        bool           `json:"auto_adjust"`
}

func (q *Queries) UpsertRecommendationConfig(ctx context.Context, arg UpsertRecommendationConfigParams) (RecommendationConfig, error) {
	row := q.db.QueryRow(ctx, upsertRecommendationConfig,
		arg.RegionID,
		arg.ExploitationRatio,
		arg.ExplorationRatio,
		arg.RandomRatio,
		arg.AutoAdjust,
	)
	var i RecommendationConfig
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.ExploitationRatio,
		&i.ExplorationRatio,
		&i.RandomRatio,
		&i.AutoAdjust,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserPreferences = `-- name: UpsertUserPreferences :one
INSERT INTO user_preferences (
  user_id,
  cuisine_preferences,
  price_range_min,
  price_range_max,
  avg_order_amount,
  favorite_time_slots,
  purchase_frequency,
  last_order_date,
  top_cuisines,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, now()
)
ON CONFLICT (user_id)
DO UPDATE SET
  cuisine_preferences = EXCLUDED.cuisine_preferences,
  price_range_min = EXCLUDED.price_range_min,
  price_range_max = EXCLUDED.price_range_max,
  avg_order_amount = EXCLUDED.avg_order_amount,
  favorite_time_slots = EXCLUDED.favorite_time_slots,
  purchase_frequency = EXCLUDED.purchase_frequency,
  last_order_date = EXCLUDED.last_order_date,
  top_cuisines = EXCLUDED.top_cuisines,
  updated_at = now()
RETURNING id, user_id, cuisine_preferences, price_range_min, price_range_max, avg_order_amount, favorite_time_slots, purchase_frequency, last_order_date, top_cuisines, updated_at
`

type UpsertUserPreferencesParams struct {
	UserID             int64       `json:"user_id"`
	CuisinePreferences []byte      `json:"cuisine_preferences"`
	PriceRangeMin      pgtype.Int8 `json:"price_range_min"`
	PriceRangeMax      pgtype.Int8 `json:"price_range_max"`
	AvgOrderAmount     pgtype.Int8 `json:"avg_order_amount"`
	FavoriteTimeSlots  []int32     `json:"favorite_time_slots"`
	PurchaseFrequency  int16       `json:"purchase_frequency"`
	LastOrderDate      pgtype.Date `json:"last_order_date"`
	TopCuisines        []byte      `json:"top_cuisines"`
}

func (q *Queries) UpsertUserPreferences(ctx context.Context, arg UpsertUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRow(ctx, upsertUserPreferences,
		arg.UserID,
		arg.CuisinePreferences,
		arg.PriceRangeMin,
		arg.PriceRangeMax,
		arg.AvgOrderAmount,
		arg.FavoriteTimeSlots,
		arg.PurchaseFrequency,
		arg.LastOrderDate,
		arg.TopCuisines,
	)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CuisinePreferences,
		&i.PriceRangeMin,
		&i.PriceRangeMax,
		&i.AvgOrderAmount,
		&i.FavoriteTimeSlots,
		&i.PurchaseFrequency,
		&i.LastOrderDate,
		&i.TopCuisines,
		&i.UpdatedAt,
	)
	return i, err
}
