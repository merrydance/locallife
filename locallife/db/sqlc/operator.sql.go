// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operator.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOperators = `-- name: CountOperators :one
SELECT COUNT(*) FROM operators
`

func (q *Queries) CountOperators(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOperators)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOperator = `-- name: CreateOperator :one
INSERT INTO operators (
    user_id,
    region_id,
    name,
    contact_name,
    contact_phone,
    wechat_mch_id,
    commission_rate,
    status,
    contract_start_date,
    contract_end_date,
    contract_years
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id
`

type CreateOperatorParams struct {
	UserID            int64          `json:"user_id"`
	RegionID          int64          `json:"region_id"`
	Name              string         `json:"name"`
	ContactName       string         `json:"contact_name"`
	ContactPhone      string         `json:"contact_phone"`
	WechatMchID       pgtype.Text    `json:"wechat_mch_id"`
	CommissionRate    pgtype.Numeric `json:"commission_rate"`
	Status            string         `json:"status"`
	ContractStartDate pgtype.Date    `json:"contract_start_date"`
	ContractEndDate   pgtype.Date    `json:"contract_end_date"`
	ContractYears     int32          `json:"contract_years"`
}

func (q *Queries) CreateOperator(ctx context.Context, arg CreateOperatorParams) (Operator, error) {
	row := q.db.QueryRow(ctx, createOperator,
		arg.UserID,
		arg.RegionID,
		arg.Name,
		arg.ContactName,
		arg.ContactPhone,
		arg.WechatMchID,
		arg.CommissionRate,
		arg.Status,
		arg.ContractStartDate,
		arg.ContractEndDate,
		arg.ContractYears,
	)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const getApprovedOperatorApplicationByUserID = `-- name: GetApprovedOperatorApplicationByUserID :one
SELECT id, user_id, region_id, name, contact_name, contact_phone, business_license_url, business_license_number, business_license_ocr, legal_person_name, legal_person_id_number, id_card_front_url, id_card_back_url, id_card_front_ocr, id_card_back_ocr, requested_contract_years, status, reject_reason, reviewed_by, reviewed_at, created_at, updated_at, submitted_at FROM operator_applications
WHERE user_id = $1 AND status = 'approved'
ORDER BY reviewed_at DESC
LIMIT 1
`

// 获取用户审核通过的运营商申请（用于绑卡开户）
func (q *Queries) GetApprovedOperatorApplicationByUserID(ctx context.Context, userID int64) (OperatorApplication, error) {
	row := q.db.QueryRow(ctx, getApprovedOperatorApplicationByUserID, userID)
	var i OperatorApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.BusinessLicenseUrl,
		&i.BusinessLicenseNumber,
		&i.BusinessLicenseOcr,
		&i.LegalPersonName,
		&i.LegalPersonIDNumber,
		&i.IDCardFrontUrl,
		&i.IDCardBackUrl,
		&i.IDCardFrontOcr,
		&i.IDCardBackOcr,
		&i.RequestedContractYears,
		&i.Status,
		&i.RejectReason,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const getOperator = `-- name: GetOperator :one
SELECT id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id FROM operators
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOperator(ctx context.Context, id int64) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperator, id)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const getOperatorByRegion = `-- name: GetOperatorByRegion :one
SELECT id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id FROM operators
WHERE region_id = $1 LIMIT 1
`

func (q *Queries) GetOperatorByRegion(ctx context.Context, regionID int64) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperatorByRegion, regionID)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const getOperatorByUser = `-- name: GetOperatorByUser :one
SELECT id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id FROM operators
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetOperatorByUser(ctx context.Context, userID int64) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperatorByUser, userID)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const listExpiredOperators = `-- name: ListExpiredOperators :many
SELECT 
    o.id, o.user_id, o.region_id, o.name, o.contact_name, o.contact_phone, o.wechat_mch_id, o.commission_rate, o.status, o.created_at, o.updated_at, o.contract_start_date, o.contract_end_date, o.contract_years, o.sub_mch_id,
    r.name as region_name
FROM operators o
INNER JOIN regions r ON o.region_id = r.id
WHERE o.contract_end_date IS NOT NULL
  AND o.contract_end_date < CURRENT_DATE
  AND o.status = 'active'
`

type ListExpiredOperatorsRow struct {
	ID                int64              `json:"id"`
	UserID            int64              `json:"user_id"`
	RegionID          int64              `json:"region_id"`
	Name              string             `json:"name"`
	ContactName       string             `json:"contact_name"`
	ContactPhone      string             `json:"contact_phone"`
	WechatMchID       pgtype.Text        `json:"wechat_mch_id"`
	CommissionRate    pgtype.Numeric     `json:"commission_rate"`
	Status            string             `json:"status"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ContractStartDate pgtype.Date        `json:"contract_start_date"`
	ContractEndDate   pgtype.Date        `json:"contract_end_date"`
	ContractYears     int32              `json:"contract_years"`
	SubMchID          pgtype.Text        `json:"sub_mch_id"`
	RegionName        string             `json:"region_name"`
}

// 列出已过期的运营商
func (q *Queries) ListExpiredOperators(ctx context.Context) ([]ListExpiredOperatorsRow, error) {
	rows, err := q.db.Query(ctx, listExpiredOperators)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiredOperatorsRow{}
	for rows.Next() {
		var i ListExpiredOperatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RegionID,
			&i.Name,
			&i.ContactName,
			&i.ContactPhone,
			&i.WechatMchID,
			&i.CommissionRate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.ContractYears,
			&i.SubMchID,
			&i.RegionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiringOperators = `-- name: ListExpiringOperators :many
SELECT 
    o.id, o.user_id, o.region_id, o.name, o.contact_name, o.contact_phone, o.wechat_mch_id, o.commission_rate, o.status, o.created_at, o.updated_at, o.contract_start_date, o.contract_end_date, o.contract_years, o.sub_mch_id,
    r.name as region_name
FROM operators o
INNER JOIN regions r ON o.region_id = r.id
WHERE o.status = 'active' 
  AND o.contract_end_date IS NOT NULL
  AND o.contract_end_date <= CURRENT_DATE + $1::int  -- 参数为天数，如30天内到期
ORDER BY o.contract_end_date ASC
`

type ListExpiringOperatorsRow struct {
	ID                int64              `json:"id"`
	UserID            int64              `json:"user_id"`
	RegionID          int64              `json:"region_id"`
	Name              string             `json:"name"`
	ContactName       string             `json:"contact_name"`
	ContactPhone      string             `json:"contact_phone"`
	WechatMchID       pgtype.Text        `json:"wechat_mch_id"`
	CommissionRate    pgtype.Numeric     `json:"commission_rate"`
	Status            string             `json:"status"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ContractStartDate pgtype.Date        `json:"contract_start_date"`
	ContractEndDate   pgtype.Date        `json:"contract_end_date"`
	ContractYears     int32              `json:"contract_years"`
	SubMchID          pgtype.Text        `json:"sub_mch_id"`
	RegionName        string             `json:"region_name"`
}

// 列出即将到期的运营商（用于提前通知续约）
func (q *Queries) ListExpiringOperators(ctx context.Context, dollar_1 int32) ([]ListExpiringOperatorsRow, error) {
	rows, err := q.db.Query(ctx, listExpiringOperators, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiringOperatorsRow{}
	for rows.Next() {
		var i ListExpiringOperatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RegionID,
			&i.Name,
			&i.ContactName,
			&i.ContactPhone,
			&i.WechatMchID,
			&i.CommissionRate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.ContractYears,
			&i.SubMchID,
			&i.RegionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperators = `-- name: ListOperators :many
SELECT 
    o.id, o.user_id, o.region_id, o.name, o.contact_name, o.contact_phone, o.wechat_mch_id, o.commission_rate, o.status, o.created_at, o.updated_at, o.contract_start_date, o.contract_end_date, o.contract_years, o.sub_mch_id,
    r.name as region_name
FROM operators o
INNER JOIN regions r ON o.region_id = r.id
ORDER BY o.created_at
LIMIT $1 OFFSET $2
`

type ListOperatorsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListOperatorsRow struct {
	ID                int64              `json:"id"`
	UserID            int64              `json:"user_id"`
	RegionID          int64              `json:"region_id"`
	Name              string             `json:"name"`
	ContactName       string             `json:"contact_name"`
	ContactPhone      string             `json:"contact_phone"`
	WechatMchID       pgtype.Text        `json:"wechat_mch_id"`
	CommissionRate    pgtype.Numeric     `json:"commission_rate"`
	Status            string             `json:"status"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ContractStartDate pgtype.Date        `json:"contract_start_date"`
	ContractEndDate   pgtype.Date        `json:"contract_end_date"`
	ContractYears     int32              `json:"contract_years"`
	SubMchID          pgtype.Text        `json:"sub_mch_id"`
	RegionName        string             `json:"region_name"`
}

func (q *Queries) ListOperators(ctx context.Context, arg ListOperatorsParams) ([]ListOperatorsRow, error) {
	rows, err := q.db.Query(ctx, listOperators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOperatorsRow{}
	for rows.Next() {
		var i ListOperatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RegionID,
			&i.Name,
			&i.ContactName,
			&i.ContactPhone,
			&i.WechatMchID,
			&i.CommissionRate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.ContractYears,
			&i.SubMchID,
			&i.RegionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const renewOperatorContract = `-- name: RenewOperatorContract :one
UPDATE operators
SET
    contract_start_date = $2,
    contract_end_date = $3,
    contract_years = $4,
    status = 'active',
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id
`

type RenewOperatorContractParams struct {
	ID                int64       `json:"id"`
	ContractStartDate pgtype.Date `json:"contract_start_date"`
	ContractEndDate   pgtype.Date `json:"contract_end_date"`
	ContractYears     int32       `json:"contract_years"`
}

// 续约运营商合同
func (q *Queries) RenewOperatorContract(ctx context.Context, arg RenewOperatorContractParams) (Operator, error) {
	row := q.db.QueryRow(ctx, renewOperatorContract,
		arg.ID,
		arg.ContractStartDate,
		arg.ContractEndDate,
		arg.ContractYears,
	)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const updateOperator = `-- name: UpdateOperator :one
UPDATE operators
SET
    name = COALESCE($2, name),
    contact_name = COALESCE($3, contact_name),
    contact_phone = COALESCE($4, contact_phone),
    wechat_mch_id = COALESCE($5, wechat_mch_id),
    commission_rate = COALESCE($6, commission_rate),
    status = COALESCE($7, status),
    contract_start_date = COALESCE($8, contract_start_date),
    contract_end_date = COALESCE($9, contract_end_date),
    contract_years = COALESCE($10, contract_years),
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id
`

type UpdateOperatorParams struct {
	ID                int64          `json:"id"`
	Name              pgtype.Text    `json:"name"`
	ContactName       pgtype.Text    `json:"contact_name"`
	ContactPhone      pgtype.Text    `json:"contact_phone"`
	WechatMchID       pgtype.Text    `json:"wechat_mch_id"`
	CommissionRate    pgtype.Numeric `json:"commission_rate"`
	Status            pgtype.Text    `json:"status"`
	ContractStartDate pgtype.Date    `json:"contract_start_date"`
	ContractEndDate   pgtype.Date    `json:"contract_end_date"`
	ContractYears     pgtype.Int4    `json:"contract_years"`
}

func (q *Queries) UpdateOperator(ctx context.Context, arg UpdateOperatorParams) (Operator, error) {
	row := q.db.QueryRow(ctx, updateOperator,
		arg.ID,
		arg.Name,
		arg.ContactName,
		arg.ContactPhone,
		arg.WechatMchID,
		arg.CommissionRate,
		arg.Status,
		arg.ContractStartDate,
		arg.ContractEndDate,
		arg.ContractYears,
	)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const updateOperatorStatus = `-- name: UpdateOperatorStatus :one
UPDATE operators
SET
    status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id
`

type UpdateOperatorStatusParams struct {
	ID     int64  `json:"id"`
	Status string `json:"status"`
}

// 更新运营商状态（用于过期处理等）
func (q *Queries) UpdateOperatorStatus(ctx context.Context, arg UpdateOperatorStatusParams) (Operator, error) {
	row := q.db.QueryRow(ctx, updateOperatorStatus, arg.ID, arg.Status)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}

const updateOperatorSubMchID = `-- name: UpdateOperatorSubMchID :one
UPDATE operators
SET
    sub_mch_id = $2,
    status = 'active',
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, region_id, name, contact_name, contact_phone, wechat_mch_id, commission_rate, status, created_at, updated_at, contract_start_date, contract_end_date, contract_years, sub_mch_id
`

type UpdateOperatorSubMchIDParams struct {
	ID       int64       `json:"id"`
	SubMchID pgtype.Text `json:"sub_mch_id"`
}

// 更新运营商的微信二级商户号（开户成功后调用）
func (q *Queries) UpdateOperatorSubMchID(ctx context.Context, arg UpdateOperatorSubMchIDParams) (Operator, error) {
	row := q.db.QueryRow(ctx, updateOperatorSubMchID, arg.ID, arg.SubMchID)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RegionID,
		&i.Name,
		&i.ContactName,
		&i.ContactPhone,
		&i.WechatMchID,
		&i.CommissionRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ContractYears,
		&i.SubMchID,
	)
	return i, err
}
