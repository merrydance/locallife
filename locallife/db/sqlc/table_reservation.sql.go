// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: table_reservation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelMerchantFutureReservations = `-- name: CancelMerchantFutureReservations :execrows
UPDATE table_reservations
SET 
    status = 'cancelled',
    cancel_reason = $2,
    updated_at = now()
WHERE merchant_id = $1 
  AND reservation_date >= CURRENT_DATE
  AND status IN ('pending', 'paid', 'confirmed')
`

type CancelMerchantFutureReservationsParams struct {
	MerchantID   int64       `json:"merchant_id"`
	CancelReason pgtype.Text `json:"cancel_reason"`
}

// 商户熔断时自动取消所有未来的预订
func (q *Queries) CancelMerchantFutureReservations(ctx context.Context, arg CancelMerchantFutureReservationsParams) (int64, error) {
	result, err := q.db.Exec(ctx, cancelMerchantFutureReservations, arg.MerchantID, arg.CancelReason)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const checkTableAvailability = `-- name: CheckTableAvailability :one
SELECT COUNT(*) FROM table_reservations
WHERE table_id = $1 
  AND reservation_date = $2
  AND reservation_time = $3
  AND status IN ('pending', 'paid', 'confirmed')
`

type CheckTableAvailabilityParams struct {
	TableID         int64       `json:"table_id"`
	ReservationDate pgtype.Date `json:"reservation_date"`
	ReservationTime pgtype.Time `json:"reservation_time"`
}

// Check if table has any active reservation for given date and time
func (q *Queries) CheckTableAvailability(ctx context.Context, arg CheckTableAvailabilityParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkTableAvailability, arg.TableID, arg.ReservationDate, arg.ReservationTime)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFutureReservationsByTable = `-- name: CountFutureReservationsByTable :one
SELECT COUNT(*) FROM table_reservations
WHERE table_id = $1 
  AND reservation_date >= CURRENT_DATE
  AND status IN ('pending', 'paid', 'confirmed')
`

// 检查某桌台是否有未来的有效预定（用于删除桌台前检查）
func (q *Queries) CountFutureReservationsByTable(ctx context.Context, tableID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countFutureReservationsByTable, tableID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReservationsByMerchant = `-- name: CountReservationsByMerchant :one
SELECT COUNT(*) FROM table_reservations
WHERE merchant_id = $1
`

func (q *Queries) CountReservationsByMerchant(ctx context.Context, merchantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationsByMerchant, merchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReservationsByMerchantAndDate = `-- name: CountReservationsByMerchantAndDate :one
SELECT COUNT(*) FROM table_reservations
WHERE merchant_id = $1 AND reservation_date = $2
`

type CountReservationsByMerchantAndDateParams struct {
	MerchantID      int64       `json:"merchant_id"`
	ReservationDate pgtype.Date `json:"reservation_date"`
}

func (q *Queries) CountReservationsByMerchantAndDate(ctx context.Context, arg CountReservationsByMerchantAndDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationsByMerchantAndDate, arg.MerchantID, arg.ReservationDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReservationsByMerchantAndStatus = `-- name: CountReservationsByMerchantAndStatus :one
SELECT COUNT(*) FROM table_reservations
WHERE merchant_id = $1 AND status = $2
`

type CountReservationsByMerchantAndStatusParams struct {
	MerchantID int64  `json:"merchant_id"`
	Status     string `json:"status"`
}

func (q *Queries) CountReservationsByMerchantAndStatus(ctx context.Context, arg CountReservationsByMerchantAndStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationsByMerchantAndStatus, arg.MerchantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReservationsByUserAndStatus = `-- name: CountReservationsByUserAndStatus :one
SELECT COUNT(*) FROM table_reservations
WHERE user_id = $1 AND status = $2
`

type CountReservationsByUserAndStatusParams struct {
	UserID int64  `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) CountReservationsByUserAndStatus(ctx context.Context, arg CountReservationsByUserAndStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationsByUserAndStatus, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTableReservation = `-- name: CreateTableReservation :one
INSERT INTO table_reservations (
    table_id,
    user_id,
    merchant_id,
    reservation_date,
    reservation_time,
    guest_count,
    contact_name,
    contact_phone,
    payment_mode,
    deposit_amount,
    prepaid_amount,
    refund_deadline,
    payment_deadline,
    notes,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

type CreateTableReservationParams struct {
	TableID         int64       `json:"table_id"`
	UserID          int64       `json:"user_id"`
	MerchantID      int64       `json:"merchant_id"`
	ReservationDate pgtype.Date `json:"reservation_date"`
	ReservationTime pgtype.Time `json:"reservation_time"`
	GuestCount      int16       `json:"guest_count"`
	ContactName     string      `json:"contact_name"`
	ContactPhone    string      `json:"contact_phone"`
	PaymentMode     string      `json:"payment_mode"`
	DepositAmount   int64       `json:"deposit_amount"`
	PrepaidAmount   int64       `json:"prepaid_amount"`
	RefundDeadline  time.Time   `json:"refund_deadline"`
	PaymentDeadline time.Time   `json:"payment_deadline"`
	Notes           pgtype.Text `json:"notes"`
	Status          string      `json:"status"`
}

func (q *Queries) CreateTableReservation(ctx context.Context, arg CreateTableReservationParams) (TableReservation, error) {
	row := q.db.QueryRow(ctx, createTableReservation,
		arg.TableID,
		arg.UserID,
		arg.MerchantID,
		arg.ReservationDate,
		arg.ReservationTime,
		arg.GuestCount,
		arg.ContactName,
		arg.ContactPhone,
		arg.PaymentMode,
		arg.DepositAmount,
		arg.PrepaidAmount,
		arg.RefundDeadline,
		arg.PaymentDeadline,
		arg.Notes,
		arg.Status,
	)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationStats = `-- name: GetReservationStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'paid') as paid_count,
    COUNT(*) FILTER (WHERE status = 'confirmed') as confirmed_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
    COUNT(*) FILTER (WHERE status = 'no_show') as no_show_count
FROM table_reservations
WHERE merchant_id = $1
`

type GetReservationStatsRow struct {
	PendingCount   int64 `json:"pending_count"`
	PaidCount      int64 `json:"paid_count"`
	ConfirmedCount int64 `json:"confirmed_count"`
	CompletedCount int64 `json:"completed_count"`
	CancelledCount int64 `json:"cancelled_count"`
	ExpiredCount   int64 `json:"expired_count"`
	NoShowCount    int64 `json:"no_show_count"`
}

// Get reservation statistics for a merchant
func (q *Queries) GetReservationStats(ctx context.Context, merchantID int64) (GetReservationStatsRow, error) {
	row := q.db.QueryRow(ctx, getReservationStats, merchantID)
	var i GetReservationStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.PaidCount,
		&i.ConfirmedCount,
		&i.CompletedCount,
		&i.CancelledCount,
		&i.ExpiredCount,
		&i.NoShowCount,
	)
	return i, err
}

const getReservationStatsByDateRange = `-- name: GetReservationStatsByDateRange :one
SELECT 
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_count,
    COALESCE(SUM(deposit_amount) FILTER (WHERE status = 'completed'), 0) as total_deposit,
    COALESCE(SUM(prepaid_amount) FILTER (WHERE status = 'completed'), 0) as total_prepaid
FROM table_reservations
WHERE merchant_id = $1 
  AND reservation_date >= $2 
  AND reservation_date <= $3
`

type GetReservationStatsByDateRangeParams struct {
	MerchantID        int64       `json:"merchant_id"`
	ReservationDate   pgtype.Date `json:"reservation_date"`
	ReservationDate_2 pgtype.Date `json:"reservation_date_2"`
}

type GetReservationStatsByDateRangeRow struct {
	TotalCount     int64       `json:"total_count"`
	CompletedCount int64       `json:"completed_count"`
	CancelledCount int64       `json:"cancelled_count"`
	TotalDeposit   interface{} `json:"total_deposit"`
	TotalPrepaid   interface{} `json:"total_prepaid"`
}

// Get reservation statistics for a merchant within date range
func (q *Queries) GetReservationStatsByDateRange(ctx context.Context, arg GetReservationStatsByDateRangeParams) (GetReservationStatsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getReservationStatsByDateRange, arg.MerchantID, arg.ReservationDate, arg.ReservationDate_2)
	var i GetReservationStatsByDateRangeRow
	err := row.Scan(
		&i.TotalCount,
		&i.CompletedCount,
		&i.CancelledCount,
		&i.TotalDeposit,
		&i.TotalPrepaid,
	)
	return i, err
}

const getTableReservation = `-- name: GetTableReservation :one
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTableReservation(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, getTableReservation, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTableReservationForUpdate = `-- name: GetTableReservationForUpdate :one
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetTableReservationForUpdate(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, getTableReservationForUpdate, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTableReservationWithTable = `-- name: GetTableReservationWithTable :one
SELECT 
    tr.id, tr.table_id, tr.user_id, tr.merchant_id, tr.reservation_date, tr.reservation_time, tr.guest_count, tr.contact_name, tr.contact_phone, tr.payment_mode, tr.deposit_amount, tr.prepaid_amount, tr.refund_deadline, tr.status, tr.payment_deadline, tr.notes, tr.paid_at, tr.confirmed_at, tr.completed_at, tr.cancelled_at, tr.cancel_reason, tr.created_at, tr.updated_at,
    t.table_no,
    t.table_type,
    t.capacity
FROM table_reservations tr
INNER JOIN tables t ON tr.table_id = t.id
WHERE tr.id = $1
`

type GetTableReservationWithTableRow struct {
	ID              int64              `json:"id"`
	TableID         int64              `json:"table_id"`
	UserID          int64              `json:"user_id"`
	MerchantID      int64              `json:"merchant_id"`
	ReservationDate pgtype.Date        `json:"reservation_date"`
	ReservationTime pgtype.Time        `json:"reservation_time"`
	GuestCount      int16              `json:"guest_count"`
	ContactName     string             `json:"contact_name"`
	ContactPhone    string             `json:"contact_phone"`
	PaymentMode     string             `json:"payment_mode"`
	DepositAmount   int64              `json:"deposit_amount"`
	PrepaidAmount   int64              `json:"prepaid_amount"`
	RefundDeadline  time.Time          `json:"refund_deadline"`
	Status          string             `json:"status"`
	PaymentDeadline time.Time          `json:"payment_deadline"`
	Notes           pgtype.Text        `json:"notes"`
	PaidAt          pgtype.Timestamptz `json:"paid_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	CancelledAt     pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason    pgtype.Text        `json:"cancel_reason"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	TableNo         string             `json:"table_no"`
	TableType       string             `json:"table_type"`
	Capacity        int16              `json:"capacity"`
}

func (q *Queries) GetTableReservationWithTable(ctx context.Context, id int64) (GetTableReservationWithTableRow, error) {
	row := q.db.QueryRow(ctx, getTableReservationWithTable, id)
	var i GetTableReservationWithTableRow
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TableNo,
		&i.TableType,
		&i.Capacity,
	)
	return i, err
}

const listExpiredPendingReservations = `-- name: ListExpiredPendingReservations :many
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE status = 'pending'
  AND payment_deadline < now()
ORDER BY payment_deadline
`

// Find pending reservations that have passed their payment deadline
func (q *Queries) ListExpiredPendingReservations(ctx context.Context) ([]TableReservation, error) {
	rows, err := q.db.Query(ctx, listExpiredPendingReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableReservation{}
	for rows.Next() {
		var i TableReservation
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantFutureReservationsForRefund = `-- name: ListMerchantFutureReservationsForRefund :many
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE merchant_id = $1 
  AND reservation_date >= CURRENT_DATE
  AND status IN ('pending', 'paid', 'confirmed')
  AND (deposit_amount > 0 OR prepaid_amount > 0)
ORDER BY reservation_date, reservation_time
`

// 获取商户未来预订列表（用于熔断后退款处理）
func (q *Queries) ListMerchantFutureReservationsForRefund(ctx context.Context, merchantID int64) ([]TableReservation, error) {
	rows, err := q.db.Query(ctx, listMerchantFutureReservationsForRefund, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableReservation{}
	for rows.Next() {
		var i TableReservation
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingReservationsNearDeadline = `-- name: ListPendingReservationsNearDeadline :many
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE status = 'pending'
  AND payment_deadline > now()
  AND payment_deadline < now() + $1::interval
ORDER BY payment_deadline
`

// Find pending reservations within N minutes of payment deadline (for reminder notifications)
func (q *Queries) ListPendingReservationsNearDeadline(ctx context.Context, minutesBefore pgtype.Interval) ([]TableReservation, error) {
	rows, err := q.db.Query(ctx, listPendingReservationsNearDeadline, minutesBefore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableReservation{}
	for rows.Next() {
		var i TableReservation
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByMerchant = `-- name: ListReservationsByMerchant :many
SELECT 
    tr.id, tr.table_id, tr.user_id, tr.merchant_id, tr.reservation_date, tr.reservation_time, tr.guest_count, tr.contact_name, tr.contact_phone, tr.payment_mode, tr.deposit_amount, tr.prepaid_amount, tr.refund_deadline, tr.status, tr.payment_deadline, tr.notes, tr.paid_at, tr.confirmed_at, tr.completed_at, tr.cancelled_at, tr.cancel_reason, tr.created_at, tr.updated_at,
    t.table_no,
    t.table_type
FROM table_reservations tr
INNER JOIN tables t ON tr.table_id = t.id
WHERE tr.merchant_id = $1
ORDER BY tr.reservation_date DESC, tr.reservation_time DESC
LIMIT $2 OFFSET $3
`

type ListReservationsByMerchantParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type ListReservationsByMerchantRow struct {
	ID              int64              `json:"id"`
	TableID         int64              `json:"table_id"`
	UserID          int64              `json:"user_id"`
	MerchantID      int64              `json:"merchant_id"`
	ReservationDate pgtype.Date        `json:"reservation_date"`
	ReservationTime pgtype.Time        `json:"reservation_time"`
	GuestCount      int16              `json:"guest_count"`
	ContactName     string             `json:"contact_name"`
	ContactPhone    string             `json:"contact_phone"`
	PaymentMode     string             `json:"payment_mode"`
	DepositAmount   int64              `json:"deposit_amount"`
	PrepaidAmount   int64              `json:"prepaid_amount"`
	RefundDeadline  time.Time          `json:"refund_deadline"`
	Status          string             `json:"status"`
	PaymentDeadline time.Time          `json:"payment_deadline"`
	Notes           pgtype.Text        `json:"notes"`
	PaidAt          pgtype.Timestamptz `json:"paid_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	CancelledAt     pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason    pgtype.Text        `json:"cancel_reason"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	TableNo         string             `json:"table_no"`
	TableType       string             `json:"table_type"`
}

func (q *Queries) ListReservationsByMerchant(ctx context.Context, arg ListReservationsByMerchantParams) ([]ListReservationsByMerchantRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByMerchant, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByMerchantRow{}
	for rows.Next() {
		var i ListReservationsByMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TableNo,
			&i.TableType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByMerchantAndDate = `-- name: ListReservationsByMerchantAndDate :many
SELECT 
    tr.id, tr.table_id, tr.user_id, tr.merchant_id, tr.reservation_date, tr.reservation_time, tr.guest_count, tr.contact_name, tr.contact_phone, tr.payment_mode, tr.deposit_amount, tr.prepaid_amount, tr.refund_deadline, tr.status, tr.payment_deadline, tr.notes, tr.paid_at, tr.confirmed_at, tr.completed_at, tr.cancelled_at, tr.cancel_reason, tr.created_at, tr.updated_at,
    t.table_no,
    t.table_type
FROM table_reservations tr
INNER JOIN tables t ON tr.table_id = t.id
WHERE tr.merchant_id = $1 
  AND tr.reservation_date = $2
ORDER BY tr.reservation_time, t.table_no
`

type ListReservationsByMerchantAndDateParams struct {
	MerchantID      int64       `json:"merchant_id"`
	ReservationDate pgtype.Date `json:"reservation_date"`
}

type ListReservationsByMerchantAndDateRow struct {
	ID              int64              `json:"id"`
	TableID         int64              `json:"table_id"`
	UserID          int64              `json:"user_id"`
	MerchantID      int64              `json:"merchant_id"`
	ReservationDate pgtype.Date        `json:"reservation_date"`
	ReservationTime pgtype.Time        `json:"reservation_time"`
	GuestCount      int16              `json:"guest_count"`
	ContactName     string             `json:"contact_name"`
	ContactPhone    string             `json:"contact_phone"`
	PaymentMode     string             `json:"payment_mode"`
	DepositAmount   int64              `json:"deposit_amount"`
	PrepaidAmount   int64              `json:"prepaid_amount"`
	RefundDeadline  time.Time          `json:"refund_deadline"`
	Status          string             `json:"status"`
	PaymentDeadline time.Time          `json:"payment_deadline"`
	Notes           pgtype.Text        `json:"notes"`
	PaidAt          pgtype.Timestamptz `json:"paid_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	CancelledAt     pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason    pgtype.Text        `json:"cancel_reason"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	TableNo         string             `json:"table_no"`
	TableType       string             `json:"table_type"`
}

func (q *Queries) ListReservationsByMerchantAndDate(ctx context.Context, arg ListReservationsByMerchantAndDateParams) ([]ListReservationsByMerchantAndDateRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByMerchantAndDate, arg.MerchantID, arg.ReservationDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByMerchantAndDateRow{}
	for rows.Next() {
		var i ListReservationsByMerchantAndDateRow
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TableNo,
			&i.TableType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByMerchantAndStatus = `-- name: ListReservationsByMerchantAndStatus :many
SELECT 
    tr.id, tr.table_id, tr.user_id, tr.merchant_id, tr.reservation_date, tr.reservation_time, tr.guest_count, tr.contact_name, tr.contact_phone, tr.payment_mode, tr.deposit_amount, tr.prepaid_amount, tr.refund_deadline, tr.status, tr.payment_deadline, tr.notes, tr.paid_at, tr.confirmed_at, tr.completed_at, tr.cancelled_at, tr.cancel_reason, tr.created_at, tr.updated_at,
    t.table_no,
    t.table_type
FROM table_reservations tr
INNER JOIN tables t ON tr.table_id = t.id
WHERE tr.merchant_id = $1 
  AND tr.status = $2
ORDER BY tr.reservation_date, tr.reservation_time
LIMIT $3 OFFSET $4
`

type ListReservationsByMerchantAndStatusParams struct {
	MerchantID int64  `json:"merchant_id"`
	Status     string `json:"status"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type ListReservationsByMerchantAndStatusRow struct {
	ID              int64              `json:"id"`
	TableID         int64              `json:"table_id"`
	UserID          int64              `json:"user_id"`
	MerchantID      int64              `json:"merchant_id"`
	ReservationDate pgtype.Date        `json:"reservation_date"`
	ReservationTime pgtype.Time        `json:"reservation_time"`
	GuestCount      int16              `json:"guest_count"`
	ContactName     string             `json:"contact_name"`
	ContactPhone    string             `json:"contact_phone"`
	PaymentMode     string             `json:"payment_mode"`
	DepositAmount   int64              `json:"deposit_amount"`
	PrepaidAmount   int64              `json:"prepaid_amount"`
	RefundDeadline  time.Time          `json:"refund_deadline"`
	Status          string             `json:"status"`
	PaymentDeadline time.Time          `json:"payment_deadline"`
	Notes           pgtype.Text        `json:"notes"`
	PaidAt          pgtype.Timestamptz `json:"paid_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	CancelledAt     pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason    pgtype.Text        `json:"cancel_reason"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	TableNo         string             `json:"table_no"`
	TableType       string             `json:"table_type"`
}

func (q *Queries) ListReservationsByMerchantAndStatus(ctx context.Context, arg ListReservationsByMerchantAndStatusParams) ([]ListReservationsByMerchantAndStatusRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByMerchantAndStatus,
		arg.MerchantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByMerchantAndStatusRow{}
	for rows.Next() {
		var i ListReservationsByMerchantAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TableNo,
			&i.TableType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByTable = `-- name: ListReservationsByTable :many
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE table_id = $1
ORDER BY reservation_date DESC, reservation_time DESC
LIMIT $2 OFFSET $3
`

type ListReservationsByTableParams struct {
	TableID int64 `json:"table_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListReservationsByTable(ctx context.Context, arg ListReservationsByTableParams) ([]TableReservation, error) {
	rows, err := q.db.Query(ctx, listReservationsByTable, arg.TableID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableReservation{}
	for rows.Next() {
		var i TableReservation
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByTableAndDate = `-- name: ListReservationsByTableAndDate :many
SELECT id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at FROM table_reservations
WHERE table_id = $1 
  AND reservation_date = $2
ORDER BY reservation_time
`

type ListReservationsByTableAndDateParams struct {
	TableID         int64       `json:"table_id"`
	ReservationDate pgtype.Date `json:"reservation_date"`
}

func (q *Queries) ListReservationsByTableAndDate(ctx context.Context, arg ListReservationsByTableAndDateParams) ([]TableReservation, error) {
	rows, err := q.db.Query(ctx, listReservationsByTableAndDate, arg.TableID, arg.ReservationDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableReservation{}
	for rows.Next() {
		var i TableReservation
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByUser = `-- name: ListReservationsByUser :many
SELECT 
    tr.id, tr.table_id, tr.user_id, tr.merchant_id, tr.reservation_date, tr.reservation_time, tr.guest_count, tr.contact_name, tr.contact_phone, tr.payment_mode, tr.deposit_amount, tr.prepaid_amount, tr.refund_deadline, tr.status, tr.payment_deadline, tr.notes, tr.paid_at, tr.confirmed_at, tr.completed_at, tr.cancelled_at, tr.cancel_reason, tr.created_at, tr.updated_at,
    t.table_no,
    t.table_type
FROM table_reservations tr
INNER JOIN tables t ON tr.table_id = t.id
WHERE tr.user_id = $1
ORDER BY tr.reservation_date DESC, tr.reservation_time DESC
LIMIT $2 OFFSET $3
`

type ListReservationsByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListReservationsByUserRow struct {
	ID              int64              `json:"id"`
	TableID         int64              `json:"table_id"`
	UserID          int64              `json:"user_id"`
	MerchantID      int64              `json:"merchant_id"`
	ReservationDate pgtype.Date        `json:"reservation_date"`
	ReservationTime pgtype.Time        `json:"reservation_time"`
	GuestCount      int16              `json:"guest_count"`
	ContactName     string             `json:"contact_name"`
	ContactPhone    string             `json:"contact_phone"`
	PaymentMode     string             `json:"payment_mode"`
	DepositAmount   int64              `json:"deposit_amount"`
	PrepaidAmount   int64              `json:"prepaid_amount"`
	RefundDeadline  time.Time          `json:"refund_deadline"`
	Status          string             `json:"status"`
	PaymentDeadline time.Time          `json:"payment_deadline"`
	Notes           pgtype.Text        `json:"notes"`
	PaidAt          pgtype.Timestamptz `json:"paid_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	CancelledAt     pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason    pgtype.Text        `json:"cancel_reason"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	TableNo         string             `json:"table_no"`
	TableType       string             `json:"table_type"`
}

func (q *Queries) ListReservationsByUser(ctx context.Context, arg ListReservationsByUserParams) ([]ListReservationsByUserRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByUserRow{}
	for rows.Next() {
		var i ListReservationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.UserID,
			&i.MerchantID,
			&i.ReservationDate,
			&i.ReservationTime,
			&i.GuestCount,
			&i.ContactName,
			&i.ContactPhone,
			&i.PaymentMode,
			&i.DepositAmount,
			&i.PrepaidAmount,
			&i.RefundDeadline,
			&i.Status,
			&i.PaymentDeadline,
			&i.Notes,
			&i.PaidAt,
			&i.ConfirmedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TableNo,
			&i.TableType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservationStatus = `-- name: UpdateReservationStatus :one
UPDATE table_reservations
SET status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

type UpdateReservationStatusParams struct {
	ID     int64  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateReservationStatus(ctx context.Context, arg UpdateReservationStatusParams) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationStatus, arg.ID, arg.Status)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservationToCancelled = `-- name: UpdateReservationToCancelled :one
UPDATE table_reservations
SET status = 'cancelled',
    cancelled_at = now(),
    cancel_reason = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

type UpdateReservationToCancelledParams struct {
	ID           int64       `json:"id"`
	CancelReason pgtype.Text `json:"cancel_reason"`
}

func (q *Queries) UpdateReservationToCancelled(ctx context.Context, arg UpdateReservationToCancelledParams) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationToCancelled, arg.ID, arg.CancelReason)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservationToCompleted = `-- name: UpdateReservationToCompleted :one
UPDATE table_reservations
SET status = 'completed',
    completed_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

func (q *Queries) UpdateReservationToCompleted(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationToCompleted, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservationToConfirmed = `-- name: UpdateReservationToConfirmed :one
UPDATE table_reservations
SET status = 'confirmed',
    confirmed_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

func (q *Queries) UpdateReservationToConfirmed(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationToConfirmed, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservationToExpired = `-- name: UpdateReservationToExpired :one
UPDATE table_reservations
SET status = 'expired',
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

func (q *Queries) UpdateReservationToExpired(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationToExpired, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservationToNoShow = `-- name: UpdateReservationToNoShow :one
UPDATE table_reservations
SET status = 'no_show',
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

func (q *Queries) UpdateReservationToNoShow(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationToNoShow, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservationToPaid = `-- name: UpdateReservationToPaid :one
UPDATE table_reservations
SET status = 'paid',
    paid_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, table_id, user_id, merchant_id, reservation_date, reservation_time, guest_count, contact_name, contact_phone, payment_mode, deposit_amount, prepaid_amount, refund_deadline, status, payment_deadline, notes, paid_at, confirmed_at, completed_at, cancelled_at, cancel_reason, created_at, updated_at
`

func (q *Queries) UpdateReservationToPaid(ctx context.Context, id int64) (TableReservation, error) {
	row := q.db.QueryRow(ctx, updateReservationToPaid, id)
	var i TableReservation
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.UserID,
		&i.MerchantID,
		&i.ReservationDate,
		&i.ReservationTime,
		&i.GuestCount,
		&i.ContactName,
		&i.ContactPhone,
		&i.PaymentMode,
		&i.DepositAmount,
		&i.PrepaidAmount,
		&i.RefundDeadline,
		&i.Status,
		&i.PaymentDeadline,
		&i.Notes,
		&i.PaidAt,
		&i.ConfirmedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
