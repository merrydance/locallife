// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: combo.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addComboDish = `-- name: AddComboDish :one

INSERT INTO combo_dishes (
  combo_id,
  dish_id,
  quantity
) VALUES (
  $1, $2, $3
) RETURNING id, combo_id, dish_id, quantity
`

type AddComboDishParams struct {
	ComboID  int64 `json:"combo_id"`
	DishID   int64 `json:"dish_id"`
	Quantity int16 `json:"quantity"`
}

// ============================================
// 套餐菜品关联查询 (Combo Dish Queries)
// ============================================
func (q *Queries) AddComboDish(ctx context.Context, arg AddComboDishParams) (ComboDish, error) {
	row := q.db.QueryRow(ctx, addComboDish, arg.ComboID, arg.DishID, arg.Quantity)
	var i ComboDish
	err := row.Scan(
		&i.ID,
		&i.ComboID,
		&i.DishID,
		&i.Quantity,
	)
	return i, err
}

const addComboTag = `-- name: AddComboTag :one

INSERT INTO combo_tags (
  combo_id,
  tag_id
) VALUES (
  $1, $2
) RETURNING id, combo_id, tag_id, created_at
`

type AddComboTagParams struct {
	ComboID int64 `json:"combo_id"`
	TagID   int64 `json:"tag_id"`
}

// ============================================
// 套餐标签关联查询 (Combo Tag Queries)
// ============================================
func (q *Queries) AddComboTag(ctx context.Context, arg AddComboTagParams) (ComboTag, error) {
	row := q.db.QueryRow(ctx, addComboTag, arg.ComboID, arg.TagID)
	var i ComboTag
	err := row.Scan(
		&i.ID,
		&i.ComboID,
		&i.TagID,
		&i.CreatedAt,
	)
	return i, err
}

const countComboSetsByMerchant = `-- name: CountComboSetsByMerchant :one
SELECT COUNT(*) FROM combo_sets
WHERE 
  merchant_id = $1
  AND deleted_at IS NULL
  AND ($2::boolean IS NULL OR is_online = $2)
`

type CountComboSetsByMerchantParams struct {
	MerchantID int64       `json:"merchant_id"`
	IsOnline   pgtype.Bool `json:"is_online"`
}

func (q *Queries) CountComboSetsByMerchant(ctx context.Context, arg CountComboSetsByMerchantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countComboSetsByMerchant, arg.MerchantID, arg.IsOnline)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComboSet = `-- name: CreateComboSet :one

INSERT INTO combo_sets (
  merchant_id,
  name,
  description,
  image_url,
  original_price,
  combo_price,
  is_online
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, merchant_id, name, description, image_url, original_price, combo_price, is_online, created_at, updated_at, deleted_at
`

type CreateComboSetParams struct {
	MerchantID    int64       `json:"merchant_id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	ImageUrl      pgtype.Text `json:"image_url"`
	OriginalPrice int64       `json:"original_price"`
	ComboPrice    int64       `json:"combo_price"`
	IsOnline      bool        `json:"is_online"`
}

// ============================================
// 套餐查询 (Combo Queries)
// ============================================
func (q *Queries) CreateComboSet(ctx context.Context, arg CreateComboSetParams) (ComboSet, error) {
	row := q.db.QueryRow(ctx, createComboSet,
		arg.MerchantID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.OriginalPrice,
		arg.ComboPrice,
		arg.IsOnline,
	)
	var i ComboSet
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.OriginalPrice,
		&i.ComboPrice,
		&i.IsOnline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteComboSet = `-- name: DeleteComboSet :exec
UPDATE combo_sets SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

// 软删除套餐
func (q *Queries) DeleteComboSet(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteComboSet, id)
	return err
}

const getComboSet = `-- name: GetComboSet :one
SELECT id, merchant_id, name, description, image_url, original_price, combo_price, is_online, created_at, updated_at, deleted_at FROM combo_sets
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetComboSet(ctx context.Context, id int64) (ComboSet, error) {
	row := q.db.QueryRow(ctx, getComboSet, id)
	var i ComboSet
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.OriginalPrice,
		&i.ComboPrice,
		&i.IsOnline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getComboSetWithDetails = `-- name: GetComboSetWithDetails :one
SELECT 
  cs.id, cs.merchant_id, cs.name, cs.description, cs.image_url, cs.original_price, cs.combo_price, cs.is_online, cs.created_at, cs.updated_at, cs.deleted_at,
  COALESCE(
    json_agg(DISTINCT
      jsonb_build_object(
        'dish_id', cd.dish_id,
        'dish_name', d.name,
        'dish_price', d.price,
        'dish_image_url', d.image_url,
        'quantity', cd.quantity
      )
    ) FILTER (WHERE cd.dish_id IS NOT NULL),
    '[]'
  ) as dishes,
  COALESCE(
    json_agg(DISTINCT
      jsonb_build_object(
        'id', t.id,
        'name', t.name
      )
    ) FILTER (WHERE t.id IS NOT NULL),
    '[]'
  ) as tags
FROM combo_sets cs
LEFT JOIN combo_dishes cd ON cs.id = cd.combo_id
LEFT JOIN dishes d ON cd.dish_id = d.id
LEFT JOIN combo_tags ct ON cs.id = ct.combo_id
LEFT JOIN tags t ON ct.tag_id = t.id
WHERE cs.id = $1 AND cs.deleted_at IS NULL
GROUP BY cs.id
`

type GetComboSetWithDetailsRow struct {
	ID            int64              `json:"id"`
	MerchantID    int64              `json:"merchant_id"`
	Name          string             `json:"name"`
	Description   pgtype.Text        `json:"description"`
	ImageUrl      pgtype.Text        `json:"image_url"`
	OriginalPrice int64              `json:"original_price"`
	ComboPrice    int64              `json:"combo_price"`
	IsOnline      bool               `json:"is_online"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	Dishes        interface{}        `json:"dishes"`
	Tags          interface{}        `json:"tags"`
}

func (q *Queries) GetComboSetWithDetails(ctx context.Context, id int64) (GetComboSetWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getComboSetWithDetails, id)
	var i GetComboSetWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.OriginalPrice,
		&i.ComboPrice,
		&i.IsOnline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Dishes,
		&i.Tags,
	)
	return i, err
}

const getCombosByIDs = `-- name: GetCombosByIDs :many
SELECT 
    id,
    merchant_id,
    name,
    description,
    image_url,
    original_price,
    combo_price,
    is_online
FROM combo_sets
WHERE id = ANY($1::bigint[])
  AND deleted_at IS NULL
  AND is_online = true
`

type GetCombosByIDsRow struct {
	ID            int64       `json:"id"`
	MerchantID    int64       `json:"merchant_id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	ImageUrl      pgtype.Text `json:"image_url"`
	OriginalPrice int64       `json:"original_price"`
	ComboPrice    int64       `json:"combo_price"`
	IsOnline      bool        `json:"is_online"`
}

// 批量获取套餐详情
func (q *Queries) GetCombosByIDs(ctx context.Context, dollar_1 []int64) ([]GetCombosByIDsRow, error) {
	rows, err := q.db.Query(ctx, getCombosByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCombosByIDsRow{}
	for rows.Next() {
		var i GetCombosByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.OriginalPrice,
			&i.ComboPrice,
			&i.IsOnline,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCombosWithMerchantByIDs = `-- name: GetCombosWithMerchantByIDs :many
SELECT 
    cs.id,
    cs.merchant_id,
    cs.name,
    cs.description,
    cs.image_url,
    cs.original_price,
    cs.combo_price,
    cs.is_online,
    m.name AS merchant_name,
    m.logo_url AS merchant_logo,
    m.latitude AS merchant_latitude,
    m.longitude AS merchant_longitude,
    m.region_id AS merchant_region_id,
    COALESCE(
        (SELECT SUM(oi.quantity)
         FROM order_items oi 
         JOIN orders o ON o.id = oi.order_id 
         WHERE oi.combo_id = cs.id 
           AND o.status IN ('delivered', 'completed')
           AND o.created_at >= NOW() - INTERVAL '30 days'
        ), 0
    )::int AS monthly_sales
FROM combo_sets cs
JOIN merchants m ON m.id = cs.merchant_id
WHERE cs.id = ANY($1::bigint[])
  AND cs.deleted_at IS NULL
  AND cs.is_online = true
  AND m.status = 'approved'
`

type GetCombosWithMerchantByIDsRow struct {
	ID                int64          `json:"id"`
	MerchantID        int64          `json:"merchant_id"`
	Name              string         `json:"name"`
	Description       pgtype.Text    `json:"description"`
	ImageUrl          pgtype.Text    `json:"image_url"`
	OriginalPrice     int64          `json:"original_price"`
	ComboPrice        int64          `json:"combo_price"`
	IsOnline          bool           `json:"is_online"`
	MerchantName      string         `json:"merchant_name"`
	MerchantLogo      pgtype.Text    `json:"merchant_logo"`
	MerchantLatitude  pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude pgtype.Numeric `json:"merchant_longitude"`
	MerchantRegionID  int64          `json:"merchant_region_id"`
	MonthlySales      int32          `json:"monthly_sales"`
}

// 批量获取套餐详情及商户信息（用于推荐流展示）
func (q *Queries) GetCombosWithMerchantByIDs(ctx context.Context, dollar_1 []int64) ([]GetCombosWithMerchantByIDsRow, error) {
	rows, err := q.db.Query(ctx, getCombosWithMerchantByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCombosWithMerchantByIDsRow{}
	for rows.Next() {
		var i GetCombosWithMerchantByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.OriginalPrice,
			&i.ComboPrice,
			&i.IsOnline,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
			&i.MerchantRegionID,
			&i.MonthlySales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularCombos = `-- name: GetPopularCombos :many

SELECT 
    cs.id,
    cs.merchant_id,
    cs.name,
    cs.description,
    cs.image_url,
    cs.original_price,
    cs.combo_price,
    COALESCE(SUM(oi.quantity), 0)::int AS total_sold
FROM combo_sets cs
LEFT JOIN order_items oi ON cs.id = oi.combo_id
LEFT JOIN orders o ON o.id = oi.order_id AND o.status IN ('delivered', 'completed')
WHERE cs.is_online = true AND cs.deleted_at IS NULL
GROUP BY cs.id
ORDER BY total_sold DESC, cs.created_at DESC
LIMIT $1
`

type GetPopularCombosRow struct {
	ID            int64       `json:"id"`
	MerchantID    int64       `json:"merchant_id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	ImageUrl      pgtype.Text `json:"image_url"`
	OriginalPrice int64       `json:"original_price"`
	ComboPrice    int64       `json:"combo_price"`
	TotalSold     int32       `json:"total_sold"`
}

// ============================================
// 套餐推荐查询
// ============================================
// 获取热门套餐（基于销量）
func (q *Queries) GetPopularCombos(ctx context.Context, limit int32) ([]GetPopularCombosRow, error) {
	rows, err := q.db.Query(ctx, getPopularCombos, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularCombosRow{}
	for rows.Next() {
		var i GetPopularCombosRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.OriginalPrice,
			&i.ComboPrice,
			&i.TotalSold,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComboDishes = `-- name: ListComboDishes :many
SELECT 
  d.id, d.merchant_id, d.category_id, d.name, d.description, d.image_url, d.price, d.member_price, d.is_available, d.is_online, d.sort_order, d.created_at, d.updated_at, d.prepare_time, d.deleted_at,
  cd.quantity
FROM dishes d
JOIN combo_dishes cd ON d.id = cd.dish_id
WHERE cd.combo_id = $1
ORDER BY cd.id ASC
`

type ListComboDishesRow struct {
	ID          int64              `json:"id"`
	MerchantID  int64              `json:"merchant_id"`
	CategoryID  pgtype.Int8        `json:"category_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	ImageUrl    pgtype.Text        `json:"image_url"`
	Price       int64              `json:"price"`
	MemberPrice pgtype.Int8        `json:"member_price"`
	IsAvailable bool               `json:"is_available"`
	IsOnline    bool               `json:"is_online"`
	SortOrder   int16              `json:"sort_order"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	PrepareTime int16              `json:"prepare_time"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	Quantity    int16              `json:"quantity"`
}

func (q *Queries) ListComboDishes(ctx context.Context, comboID int64) ([]ListComboDishesRow, error) {
	rows, err := q.db.Query(ctx, listComboDishes, comboID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListComboDishesRow{}
	for rows.Next() {
		var i ListComboDishesRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PrepareTime,
			&i.DeletedAt,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComboSetsByMerchant = `-- name: ListComboSetsByMerchant :many
SELECT id, merchant_id, name, description, image_url, original_price, combo_price, is_online, created_at, updated_at, deleted_at FROM combo_sets
WHERE 
  merchant_id = $1
  AND deleted_at IS NULL
  AND ($4::boolean IS NULL OR is_online = $4)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListComboSetsByMerchantParams struct {
	MerchantID int64       `json:"merchant_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	IsOnline   pgtype.Bool `json:"is_online"`
}

func (q *Queries) ListComboSetsByMerchant(ctx context.Context, arg ListComboSetsByMerchantParams) ([]ComboSet, error) {
	rows, err := q.db.Query(ctx, listComboSetsByMerchant,
		arg.MerchantID,
		arg.Limit,
		arg.Offset,
		arg.IsOnline,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ComboSet{}
	for rows.Next() {
		var i ComboSet
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.OriginalPrice,
			&i.ComboPrice,
			&i.IsOnline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComboTags = `-- name: ListComboTags :many
SELECT 
  t.id,
  t.name,
  t.type,
  t.sort_order,
  t.status,
  t.created_at
FROM tags t
JOIN combo_tags ct ON t.id = ct.tag_id
WHERE ct.combo_id = $1
ORDER BY t.sort_order ASC
`

func (q *Queries) ListComboTags(ctx context.Context, comboID int64) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listComboTags, comboID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.SortOrder,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOnlineCombosByMerchant = `-- name: ListOnlineCombosByMerchant :many
SELECT 
    id,
    merchant_id,
    name,
    description,
    image_url,
    original_price,
    combo_price AS price,
    is_online
FROM combo_sets
WHERE merchant_id = $1
  AND deleted_at IS NULL
  AND is_online = true
ORDER BY created_at DESC
`

type ListOnlineCombosByMerchantRow struct {
	ID            int64       `json:"id"`
	MerchantID    int64       `json:"merchant_id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	ImageUrl      pgtype.Text `json:"image_url"`
	OriginalPrice int64       `json:"original_price"`
	Price         int64       `json:"price"`
	IsOnline      bool        `json:"is_online"`
}

// 获取商户上架套餐（用于扫码点餐菜单展示）
func (q *Queries) ListOnlineCombosByMerchant(ctx context.Context, merchantID int64) ([]ListOnlineCombosByMerchantRow, error) {
	rows, err := q.db.Query(ctx, listOnlineCombosByMerchant, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOnlineCombosByMerchantRow{}
	for rows.Next() {
		var i ListOnlineCombosByMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.OriginalPrice,
			&i.Price,
			&i.IsOnline,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllComboDishes = `-- name: RemoveAllComboDishes :exec
DELETE FROM combo_dishes
WHERE combo_id = $1
`

func (q *Queries) RemoveAllComboDishes(ctx context.Context, comboID int64) error {
	_, err := q.db.Exec(ctx, removeAllComboDishes, comboID)
	return err
}

const removeAllComboTags = `-- name: RemoveAllComboTags :exec
DELETE FROM combo_tags
WHERE combo_id = $1
`

func (q *Queries) RemoveAllComboTags(ctx context.Context, comboID int64) error {
	_, err := q.db.Exec(ctx, removeAllComboTags, comboID)
	return err
}

const removeComboDish = `-- name: RemoveComboDish :exec
DELETE FROM combo_dishes
WHERE combo_id = $1 AND dish_id = $2
`

type RemoveComboDishParams struct {
	ComboID int64 `json:"combo_id"`
	DishID  int64 `json:"dish_id"`
}

func (q *Queries) RemoveComboDish(ctx context.Context, arg RemoveComboDishParams) error {
	_, err := q.db.Exec(ctx, removeComboDish, arg.ComboID, arg.DishID)
	return err
}

const removeComboTag = `-- name: RemoveComboTag :exec
DELETE FROM combo_tags
WHERE combo_id = $1 AND tag_id = $2
`

type RemoveComboTagParams struct {
	ComboID int64 `json:"combo_id"`
	TagID   int64 `json:"tag_id"`
}

func (q *Queries) RemoveComboTag(ctx context.Context, arg RemoveComboTagParams) error {
	_, err := q.db.Exec(ctx, removeComboTag, arg.ComboID, arg.TagID)
	return err
}

const searchComboIDsGlobal = `-- name: SearchComboIDsGlobal :many
SELECT cs.id FROM combo_sets cs
JOIN merchants m ON cs.merchant_id = m.id
WHERE 
  m.status = 'approved'
  AND m.deleted_at IS NULL
  AND cs.deleted_at IS NULL
  AND cs.is_online = true
  AND cs.name ILIKE '%' || $1 || '%'
ORDER BY cs.created_at DESC
`

// 全局套餐搜索，只返回套餐ID（用于推荐接口的关键词过滤）
func (q *Queries) SearchComboIDsGlobal(ctx context.Context, dollar_1 pgtype.Text) ([]int64, error) {
	rows, err := q.db.Query(ctx, searchComboIDsGlobal, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComboSet = `-- name: UpdateComboSet :one
UPDATE combo_sets
SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  image_url = COALESCE($3, image_url),
  original_price = COALESCE($4, original_price),
  combo_price = COALESCE($5, combo_price),
  is_online = COALESCE($6, is_online),
  updated_at = now()
WHERE id = $7 AND deleted_at IS NULL
RETURNING id, merchant_id, name, description, image_url, original_price, combo_price, is_online, created_at, updated_at, deleted_at
`

type UpdateComboSetParams struct {
	Name          pgtype.Text `json:"name"`
	Description   pgtype.Text `json:"description"`
	ImageUrl      pgtype.Text `json:"image_url"`
	OriginalPrice pgtype.Int8 `json:"original_price"`
	ComboPrice    pgtype.Int8 `json:"combo_price"`
	IsOnline      pgtype.Bool `json:"is_online"`
	ID            int64       `json:"id"`
}

func (q *Queries) UpdateComboSet(ctx context.Context, arg UpdateComboSetParams) (ComboSet, error) {
	row := q.db.QueryRow(ctx, updateComboSet,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.OriginalPrice,
		arg.ComboPrice,
		arg.IsOnline,
		arg.ID,
	)
	var i ComboSet
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.OriginalPrice,
		&i.ComboPrice,
		&i.IsOnline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateComboSetOnlineStatus = `-- name: UpdateComboSetOnlineStatus :exec
UPDATE combo_sets
SET 
  is_online = $2,
  updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateComboSetOnlineStatusParams struct {
	ID       int64 `json:"id"`
	IsOnline bool  `json:"is_online"`
}

func (q *Queries) UpdateComboSetOnlineStatus(ctx context.Context, arg UpdateComboSetOnlineStatusParams) error {
	_, err := q.db.Exec(ctx, updateComboSetOnlineStatus, arg.ID, arg.IsOnline)
	return err
}
