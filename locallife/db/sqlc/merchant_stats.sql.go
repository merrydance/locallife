// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: merchant_stats.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMerchantCustomers = `-- name: CountMerchantCustomers :one
SELECT COUNT(DISTINCT user_id)::int
FROM orders
WHERE merchant_id = $1
  AND status IN ('delivered', 'completed')
`

// 统计商户的顾客总数
func (q *Queries) CountMerchantCustomers(ctx context.Context, merchantID int64) (int32, error) {
	row := q.db.QueryRow(ctx, countMerchantCustomers, merchantID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getCustomerFavoriteDishes = `-- name: GetCustomerFavoriteDishes :many
SELECT 
    oi.dish_id,
    d.name AS dish_name,
    COUNT(*)::int AS order_count,
    SUM(oi.quantity)::int AS total_quantity
FROM order_items oi
JOIN dishes d ON d.id = oi.dish_id
JOIN orders o ON o.id = oi.order_id
WHERE o.merchant_id = $1
  AND o.user_id = $2
  AND o.status IN ('delivered', 'completed')
GROUP BY oi.dish_id, d.name
ORDER BY order_count DESC, total_quantity DESC
LIMIT $3
`

type GetCustomerFavoriteDishesParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
	Limit      int32 `json:"limit"`
}

type GetCustomerFavoriteDishesRow struct {
	DishID        pgtype.Int8 `json:"dish_id"`
	DishName      string      `json:"dish_name"`
	OrderCount    int32       `json:"order_count"`
	TotalQuantity int32       `json:"total_quantity"`
}

// 查询顾客最喜欢的菜品
func (q *Queries) GetCustomerFavoriteDishes(ctx context.Context, arg GetCustomerFavoriteDishesParams) ([]GetCustomerFavoriteDishesRow, error) {
	rows, err := q.db.Query(ctx, getCustomerFavoriteDishes, arg.MerchantID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerFavoriteDishesRow{}
	for rows.Next() {
		var i GetCustomerFavoriteDishesRow
		if err := rows.Scan(
			&i.DishID,
			&i.DishName,
			&i.OrderCount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerMerchantDetail = `-- name: GetCustomerMerchantDetail :one
SELECT 
    o.user_id,
    u.full_name,
    u.phone,
    u.avatar_url,
    COUNT(*)::int AS total_orders,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_amount,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COALESCE(SUM(o.final_amount), 0) / COUNT(*))::bigint
        ELSE 0
    END AS avg_order_amount,
    MIN(o.created_at) AS first_order_at,
    MAX(o.created_at) AS last_order_at
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE o.merchant_id = $1
  AND o.user_id = $2
  AND o.status IN ('delivered', 'completed')
GROUP BY o.user_id, u.full_name, u.phone, u.avatar_url
`

type GetCustomerMerchantDetailParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
}

type GetCustomerMerchantDetailRow struct {
	UserID         int64       `json:"user_id"`
	FullName       string      `json:"full_name"`
	Phone          pgtype.Text `json:"phone"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	TotalOrders    int32       `json:"total_orders"`
	TotalAmount    int64       `json:"total_amount"`
	AvgOrderAmount int32       `json:"avg_order_amount"`
	FirstOrderAt   interface{} `json:"first_order_at"`
	LastOrderAt    interface{} `json:"last_order_at"`
}

// 单个顾客在某商户的消费详情
func (q *Queries) GetCustomerMerchantDetail(ctx context.Context, arg GetCustomerMerchantDetailParams) (GetCustomerMerchantDetailRow, error) {
	row := q.db.QueryRow(ctx, getCustomerMerchantDetail, arg.MerchantID, arg.UserID)
	var i GetCustomerMerchantDetailRow
	err := row.Scan(
		&i.UserID,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.TotalOrders,
		&i.TotalAmount,
		&i.AvgOrderAmount,
		&i.FirstOrderAt,
		&i.LastOrderAt,
	)
	return i, err
}

const getDishCategoryStats = `-- name: GetDishCategoryStats :many
SELECT 
    dc.id AS category_id,
    dc.name AS category_name,
    COUNT(DISTINCT oi.dish_id)::int AS dish_count,
    SUM(oi.quantity)::int AS total_quantity,
    COALESCE(SUM(oi.subtotal), 0)::bigint AS total_revenue
FROM dish_categories dc
JOIN merchant_dish_categories mdc ON dc.id = mdc.category_id
LEFT JOIN dishes d ON d.category_id = dc.id AND d.merchant_id = mdc.merchant_id
LEFT JOIN order_items oi ON oi.dish_id = d.id
LEFT JOIN orders o ON o.id = oi.order_id 
    AND o.created_at >= $2 
    AND o.created_at <= $3
    AND o.status IN ('delivered', 'completed')
WHERE mdc.merchant_id = $1
GROUP BY dc.id, dc.name, mdc.sort_order
ORDER BY mdc.sort_order ASC, total_revenue DESC
`

type GetDishCategoryStatsParams struct {
	MerchantID int64     `json:"merchant_id"`
	StartDate  time.Time `json:"start_date"`
	EndDate    time.Time `json:"end_date"`
}

type GetDishCategoryStatsRow struct {
	CategoryID    int64  `json:"category_id"`
	CategoryName  string `json:"category_name"`
	DishCount     int32  `json:"dish_count"`
	TotalQuantity int32  `json:"total_quantity"`
	TotalRevenue  int64  `json:"total_revenue"`
}

// 菜品分类销售统计
func (q *Queries) GetDishCategoryStats(ctx context.Context, arg GetDishCategoryStatsParams) ([]GetDishCategoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getDishCategoryStats, arg.MerchantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDishCategoryStatsRow{}
	for rows.Next() {
		var i GetDishCategoryStatsRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.DishCount,
			&i.TotalQuantity,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantAvgPrepMinutes = `-- name: GetMerchantAvgPrepMinutes :one
SELECT COALESCE(
  AVG(EXTRACT(EPOCH FROM (ready_log.created_at - paid_log.created_at)) / 60),
  0
)::INTEGER as avg_prep_minutes
FROM orders o
JOIN order_status_logs paid_log ON paid_log.order_id = o.id AND paid_log.to_status = 'paid'
JOIN order_status_logs ready_log ON ready_log.order_id = o.id AND ready_log.to_status = 'ready'
WHERE o.merchant_id = $1
  AND o.status IN ('ready', 'delivering', 'completed')
  AND o.created_at > NOW() - INTERVAL '30 days'
`

// 获取商户平均出餐时间（分钟）
// 从 order_status_logs 计算 paid → ready 的时间差
// 取最近30天完成订单的平均值
func (q *Queries) GetMerchantAvgPrepMinutes(ctx context.Context, merchantID int64) (int32, error) {
	row := q.db.QueryRow(ctx, getMerchantAvgPrepMinutes, merchantID)
	var avg_prep_minutes int32
	err := row.Scan(&avg_prep_minutes)
	return avg_prep_minutes, err
}

const getMerchantCustomerStats = `-- name: GetMerchantCustomerStats :many
SELECT 
    o.user_id,
    u.full_name,
    u.phone,
    u.avatar_url,
    COUNT(*)::int AS total_orders,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_amount,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COALESCE(SUM(o.final_amount), 0) / COUNT(*))::bigint
        ELSE 0
    END AS avg_order_amount,
    MIN(o.created_at) AS first_order_at,
    MAX(o.created_at) AS last_order_at
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE o.merchant_id = $1
  AND o.status IN ('delivered', 'completed')
GROUP BY o.user_id, u.full_name, u.phone, u.avatar_url
ORDER BY 
    CASE 
        WHEN $4::text = 'total_orders' THEN COUNT(*)
        WHEN $4::text = 'total_amount' THEN SUM(o.final_amount)
        ELSE EXTRACT(EPOCH FROM MAX(o.created_at))
    END DESC
LIMIT $2 OFFSET $3
`

type GetMerchantCustomerStatsParams struct {
	MerchantID int64  `json:"merchant_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
	OrderBy    string `json:"order_by"`
}

type GetMerchantCustomerStatsRow struct {
	UserID         int64       `json:"user_id"`
	FullName       string      `json:"full_name"`
	Phone          pgtype.Text `json:"phone"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	TotalOrders    int32       `json:"total_orders"`
	TotalAmount    int64       `json:"total_amount"`
	AvgOrderAmount int32       `json:"avg_order_amount"`
	FirstOrderAt   interface{} `json:"first_order_at"`
	LastOrderAt    interface{} `json:"last_order_at"`
}

// 顾客消费分析: 实时计算每个顾客的消费统计
func (q *Queries) GetMerchantCustomerStats(ctx context.Context, arg GetMerchantCustomerStatsParams) ([]GetMerchantCustomerStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantCustomerStats,
		arg.MerchantID,
		arg.Limit,
		arg.Offset,
		arg.OrderBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantCustomerStatsRow{}
	for rows.Next() {
		var i GetMerchantCustomerStatsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
			&i.TotalOrders,
			&i.TotalAmount,
			&i.AvgOrderAmount,
			&i.FirstOrderAt,
			&i.LastOrderAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantDailyStats = `-- name: GetMerchantDailyStats :many

SELECT 
    DATE(created_at) AS date,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(SUM(platform_commission), 0)::bigint AS commission,
    COUNT(*) FILTER (WHERE order_type = 'takeout')::int AS takeout_orders,
    COUNT(*) FILTER (WHERE order_type = 'dine_in')::int AS dine_in_orders
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetMerchantDailyStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantDailyStatsRow struct {
	Date          pgtype.Date `json:"date"`
	OrderCount    int32       `json:"order_count"`
	TotalSales    int64       `json:"total_sales"`
	Commission    int64       `json:"commission"`
	TakeoutOrders int32       `json:"takeout_orders"`
	DineInOrders  int32       `json:"dine_in_orders"`
}

// M12: 商户统计查询 (实时计算)
// 商户日报: 按天聚合订单数据
func (q *Queries) GetMerchantDailyStats(ctx context.Context, arg GetMerchantDailyStatsParams) ([]GetMerchantDailyStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantDailyStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantDailyStatsRow{}
	for rows.Next() {
		var i GetMerchantDailyStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderCount,
			&i.TotalSales,
			&i.Commission,
			&i.TakeoutOrders,
			&i.DineInOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantDishesWithCategory = `-- name: GetMerchantDishesWithCategory :many
SELECT 
  d.id,
  d.name,
  d.description,
  d.price,
  d.member_price,
  d.image_url,
  d.is_available,
  d.sort_order,
  d.prepare_time,
  COALESCE(dc.id, 0) as category_id,
  COALESCE(dc.name, '未分类') as category_name,
  COALESCE(mdc.sort_order, 999) as category_sort_order,
  COALESCE(
    (SELECT json_agg(t.name) FROM dish_tags dt JOIN tags t ON t.id = dt.tag_id WHERE dt.dish_id = d.id),
    '[]'::json
  ) as tags,
  COALESCE(
    (SELECT SUM(oi.quantity)::int FROM order_items oi JOIN orders o ON o.id = oi.order_id 
     WHERE oi.dish_id = d.id AND o.status IN ('completed', 'delivered') 
     AND o.created_at > NOW() - INTERVAL '30 days'),
    0
  ) as monthly_sales
FROM dishes d
LEFT JOIN dish_categories dc ON dc.id = d.category_id
LEFT JOIN merchant_dish_categories mdc ON mdc.category_id = dc.id AND mdc.merchant_id = d.merchant_id
WHERE d.merchant_id = $1
  AND d.is_online = true
  AND d.is_available = true
  AND d.deleted_at IS NULL
ORDER BY COALESCE(mdc.sort_order, 999), d.sort_order, d.id
`

type GetMerchantDishesWithCategoryRow struct {
	ID                int64       `json:"id"`
	Name              string      `json:"name"`
	Description       pgtype.Text `json:"description"`
	Price             int64       `json:"price"`
	MemberPrice       pgtype.Int8 `json:"member_price"`
	ImageUrl          pgtype.Text `json:"image_url"`
	IsAvailable       bool        `json:"is_available"`
	SortOrder         int16       `json:"sort_order"`
	PrepareTime       int16       `json:"prepare_time"`
	CategoryID        int64       `json:"category_id"`
	CategoryName      string      `json:"category_name"`
	CategorySortOrder int16       `json:"category_sort_order"`
	Tags              interface{} `json:"tags"`
	MonthlySales      interface{} `json:"monthly_sales"`
}

// 获取商户所有在线菜品（含分类信息）- 消费者端使用
func (q *Queries) GetMerchantDishesWithCategory(ctx context.Context, merchantID int64) ([]GetMerchantDishesWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, getMerchantDishesWithCategory, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantDishesWithCategoryRow{}
	for rows.Next() {
		var i GetMerchantDishesWithCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.MemberPrice,
			&i.ImageUrl,
			&i.IsAvailable,
			&i.SortOrder,
			&i.PrepareTime,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategorySortOrder,
			&i.Tags,
			&i.MonthlySales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantHourlyStats = `-- name: GetMerchantHourlyStats :many
SELECT 
    EXTRACT(HOUR FROM created_at)::int AS hour,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(AVG(final_amount), 0)::bigint AS avg_order_amount
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
GROUP BY EXTRACT(HOUR FROM created_at)
ORDER BY hour
`

type GetMerchantHourlyStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantHourlyStatsRow struct {
	Hour           int32 `json:"hour"`
	OrderCount     int32 `json:"order_count"`
	TotalSales     int64 `json:"total_sales"`
	AvgOrderAmount int64 `json:"avg_order_amount"`
}

// 商户时段分析: 按小时统计订单分布
func (q *Queries) GetMerchantHourlyStats(ctx context.Context, arg GetMerchantHourlyStatsParams) ([]GetMerchantHourlyStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantHourlyStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantHourlyStatsRow{}
	for rows.Next() {
		var i GetMerchantHourlyStatsRow
		if err := rows.Scan(
			&i.Hour,
			&i.OrderCount,
			&i.TotalSales,
			&i.AvgOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantOnlineCombos = `-- name: GetMerchantOnlineCombos :many
SELECT 
  cs.id,
  cs.name,
  cs.description,
  cs.image_url,
  cs.combo_price,
  -- 实时计算实际原价（单品价之和）
  COALESCE(
    (SELECT SUM(d.price * cd.quantity) FROM combo_dishes cd JOIN dishes d ON d.id = cd.dish_id WHERE cd.combo_id = cs.id),
    cs.original_price
  )::bigint as original_price,
  cs.is_online,
  (
    SELECT json_agg(json_build_object(
      'dish_id', cd.dish_id,
      'dish_name', d.name,
      'quantity', cd.quantity
    ))
    FROM combo_dishes cd
    JOIN dishes d ON d.id = cd.dish_id
    WHERE cd.combo_id = cs.id
  ) as dishes
FROM combo_sets cs
WHERE cs.merchant_id = $1
  AND cs.is_online = true
  AND cs.deleted_at IS NULL
ORDER BY cs.id
`

type GetMerchantOnlineCombosRow struct {
	ID            int64       `json:"id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	ImageUrl      pgtype.Text `json:"image_url"`
	ComboPrice    int64       `json:"combo_price"`
	OriginalPrice int64       `json:"original_price"`
	IsOnline      bool        `json:"is_online"`
	Dishes        []byte      `json:"dishes"`
}

// 获取商户所有在线套餐 - 消费者端使用
func (q *Queries) GetMerchantOnlineCombos(ctx context.Context, merchantID int64) ([]GetMerchantOnlineCombosRow, error) {
	rows, err := q.db.Query(ctx, getMerchantOnlineCombos, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantOnlineCombosRow{}
	for rows.Next() {
		var i GetMerchantOnlineCombosRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.ComboPrice,
			&i.OriginalPrice,
			&i.IsOnline,
			&i.Dishes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantOrderSourceStats = `-- name: GetMerchantOrderSourceStats :many
SELECT 
    order_type,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(AVG(final_amount), 0)::bigint AS avg_order_amount
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
GROUP BY order_type
ORDER BY order_count DESC
`

type GetMerchantOrderSourceStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantOrderSourceStatsRow struct {
	OrderType      string `json:"order_type"`
	OrderCount     int32  `json:"order_count"`
	TotalSales     int64  `json:"total_sales"`
	AvgOrderAmount int64  `json:"avg_order_amount"`
}

// 订单来源分析
func (q *Queries) GetMerchantOrderSourceStats(ctx context.Context, arg GetMerchantOrderSourceStatsParams) ([]GetMerchantOrderSourceStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantOrderSourceStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantOrderSourceStatsRow{}
	for rows.Next() {
		var i GetMerchantOrderSourceStatsRow
		if err := rows.Scan(
			&i.OrderType,
			&i.OrderCount,
			&i.TotalSales,
			&i.AvgOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantOverview = `-- name: GetMerchantOverview :one
SELECT 
    COUNT(DISTINCT DATE(created_at))::int AS total_days,
    COUNT(*)::int AS total_orders,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(SUM(platform_commission), 0)::bigint AS total_commission,
    CASE 
        WHEN COUNT(DISTINCT DATE(created_at)) > 0 
        THEN (COALESCE(SUM(final_amount), 0) / COUNT(DISTINCT DATE(created_at)))::bigint
        ELSE 0
    END AS avg_daily_sales
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
`

type GetMerchantOverviewParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantOverviewRow struct {
	TotalDays       int32 `json:"total_days"`
	TotalOrders     int32 `json:"total_orders"`
	TotalSales      int64 `json:"total_sales"`
	TotalCommission int64 `json:"total_commission"`
	AvgDailySales   int32 `json:"avg_daily_sales"`
}

// 商户概览: 指定日期范围的汇总统计
func (q *Queries) GetMerchantOverview(ctx context.Context, arg GetMerchantOverviewParams) (GetMerchantOverviewRow, error) {
	row := q.db.QueryRow(ctx, getMerchantOverview, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantOverviewRow
	err := row.Scan(
		&i.TotalDays,
		&i.TotalOrders,
		&i.TotalSales,
		&i.TotalCommission,
		&i.AvgDailySales,
	)
	return i, err
}

const getMerchantRepurchaseRate = `-- name: GetMerchantRepurchaseRate :one
WITH customer_order_counts AS (
    SELECT 
        user_id,
        COUNT(*) AS order_count
    FROM orders
    WHERE merchant_id = $1
      AND created_at >= $2
      AND created_at <= $3
      AND status IN ('delivered', 'completed')
    GROUP BY user_id
)
SELECT 
    COUNT(*)::int AS total_customers,
    COUNT(*) FILTER (WHERE order_count > 1)::int AS repeat_customers,
    COALESCE(SUM(order_count), 0)::int AS total_orders,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COUNT(*) FILTER (WHERE order_count > 1)::numeric / COUNT(*)::numeric * 10000)::int
        ELSE 0
    END AS repurchase_rate_basis_points,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COALESCE(SUM(order_count), 0)::numeric / COUNT(*)::numeric * 100)::int
        ELSE 0
    END AS avg_orders_per_user_cents
FROM customer_order_counts
`

type GetMerchantRepurchaseRateParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantRepurchaseRateRow struct {
	TotalCustomers            int32 `json:"total_customers"`
	RepeatCustomers           int32 `json:"repeat_customers"`
	TotalOrders               int32 `json:"total_orders"`
	RepurchaseRateBasisPoints int32 `json:"repurchase_rate_basis_points"`
	AvgOrdersPerUserCents     int32 `json:"avg_orders_per_user_cents"`
}

// 复购率分析
// 注意: repurchase_rate_percent 返回万分比(如 7550 表示 75.50%)，API层需除以100
// 注意: avg_orders_per_user 返回百分比形式(如 235 表示 2.35次)，API层需除以100
func (q *Queries) GetMerchantRepurchaseRate(ctx context.Context, arg GetMerchantRepurchaseRateParams) (GetMerchantRepurchaseRateRow, error) {
	row := q.db.QueryRow(ctx, getMerchantRepurchaseRate, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantRepurchaseRateRow
	err := row.Scan(
		&i.TotalCustomers,
		&i.RepeatCustomers,
		&i.TotalOrders,
		&i.RepurchaseRateBasisPoints,
		&i.AvgOrdersPerUserCents,
	)
	return i, err
}

const getTopSellingDishes = `-- name: GetTopSellingDishes :many
SELECT 
    oi.dish_id,
    d.name AS dish_name,
    d.price AS dish_price,
    SUM(oi.quantity)::int AS total_sold,
    COALESCE(SUM(oi.subtotal), 0)::bigint AS total_revenue
FROM order_items oi
JOIN dishes d ON d.id = oi.dish_id
JOIN orders o ON o.id = oi.order_id
WHERE o.merchant_id = $1
  AND o.created_at >= $2
  AND o.created_at <= $3
  AND o.status IN ('delivered', 'completed')
GROUP BY oi.dish_id, d.name, d.price
ORDER BY total_sold DESC
LIMIT $4
`

type GetTopSellingDishesParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
}

type GetTopSellingDishesRow struct {
	DishID       pgtype.Int8 `json:"dish_id"`
	DishName     string      `json:"dish_name"`
	DishPrice    int64       `json:"dish_price"`
	TotalSold    int32       `json:"total_sold"`
	TotalRevenue int64       `json:"total_revenue"`
}

// 菜品销量排行: 从order_items实时聚合
func (q *Queries) GetTopSellingDishes(ctx context.Context, arg GetTopSellingDishesParams) ([]GetTopSellingDishesRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingDishes,
		arg.MerchantID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopSellingDishesRow{}
	for rows.Next() {
		var i GetTopSellingDishesRow
		if err := rows.Scan(
			&i.DishID,
			&i.DishName,
			&i.DishPrice,
			&i.TotalSold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantActiveDeliveryPromotions = `-- name: ListMerchantActiveDeliveryPromotions :many
SELECT id, merchant_id, name, min_order_amount, discount_amount, valid_from, valid_until, is_active, created_at, updated_at FROM merchant_delivery_promotions
WHERE merchant_id = $1
  AND is_active = true
  AND valid_from <= NOW()
  AND valid_until >= NOW()
ORDER BY min_order_amount ASC
`

// 获取商户当前有效的配送费优惠
func (q *Queries) ListMerchantActiveDeliveryPromotions(ctx context.Context, merchantID int64) ([]MerchantDeliveryPromotion, error) {
	rows, err := q.db.Query(ctx, listMerchantActiveDeliveryPromotions, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MerchantDeliveryPromotion{}
	for rows.Next() {
		var i MerchantDeliveryPromotion
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.MinOrderAmount,
			&i.DiscountAmount,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantActiveDiscountRules = `-- name: ListMerchantActiveDiscountRules :many
SELECT id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at FROM discount_rules
WHERE merchant_id = $1
  AND is_active = true
  AND valid_from <= NOW()
  AND valid_until >= NOW()
  AND deleted_at IS NULL
ORDER BY min_order_amount ASC
`

// 获取商户当前有效的满减规则
func (q *Queries) ListMerchantActiveDiscountRules(ctx context.Context, merchantID int64) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, listMerchantActiveDiscountRules, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.MinOrderAmount,
			&i.DiscountAmount,
			&i.CanStackWithVoucher,
			&i.CanStackWithMembership,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantActiveVouchers = `-- name: ListMerchantActiveVouchers :many
SELECT id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at FROM vouchers
WHERE merchant_id = $1
  AND is_active = true
  AND valid_from <= NOW()
  AND valid_until >= NOW()
  AND claimed_quantity < total_quantity
  AND deleted_at IS NULL
ORDER BY amount DESC
`

// 获取商户当前有效的代金券
func (q *Queries) ListMerchantActiveVouchers(ctx context.Context, merchantID int64) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, listMerchantActiveVouchers, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.MinOrderAmount,
			&i.TotalQuantity,
			&i.ClaimedQuantity,
			&i.UsedQuantity,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AllowedOrderTypes,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
