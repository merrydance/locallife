// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: merchant_stats.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMerchantCustomers = `-- name: CountMerchantCustomers :one
SELECT COUNT(DISTINCT user_id)::int
FROM orders
WHERE merchant_id = $1
  AND status IN ('delivered', 'completed')
`

// 统计商户的顾客总数
func (q *Queries) CountMerchantCustomers(ctx context.Context, merchantID int64) (int32, error) {
	row := q.db.QueryRow(ctx, countMerchantCustomers, merchantID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getCustomerFavoriteDishes = `-- name: GetCustomerFavoriteDishes :many
SELECT 
    oi.dish_id,
    d.name AS dish_name,
    COUNT(*)::int AS order_count,
    SUM(oi.quantity)::int AS total_quantity
FROM order_items oi
JOIN dishes d ON d.id = oi.dish_id
JOIN orders o ON o.id = oi.order_id
WHERE o.merchant_id = $1
  AND o.user_id = $2
  AND o.status IN ('delivered', 'completed')
GROUP BY oi.dish_id, d.name
ORDER BY order_count DESC, total_quantity DESC
LIMIT $3
`

type GetCustomerFavoriteDishesParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
	Limit      int32 `json:"limit"`
}

type GetCustomerFavoriteDishesRow struct {
	DishID        pgtype.Int8 `json:"dish_id"`
	DishName      string      `json:"dish_name"`
	OrderCount    int32       `json:"order_count"`
	TotalQuantity int32       `json:"total_quantity"`
}

// 查询顾客最喜欢的菜品
func (q *Queries) GetCustomerFavoriteDishes(ctx context.Context, arg GetCustomerFavoriteDishesParams) ([]GetCustomerFavoriteDishesRow, error) {
	rows, err := q.db.Query(ctx, getCustomerFavoriteDishes, arg.MerchantID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerFavoriteDishesRow{}
	for rows.Next() {
		var i GetCustomerFavoriteDishesRow
		if err := rows.Scan(
			&i.DishID,
			&i.DishName,
			&i.OrderCount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerMerchantDetail = `-- name: GetCustomerMerchantDetail :one
SELECT 
    o.user_id,
    u.full_name,
    u.phone,
    u.avatar_url,
    COUNT(*)::int AS total_orders,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_amount,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COALESCE(SUM(o.final_amount), 0) / COUNT(*))::bigint
        ELSE 0
    END AS avg_order_amount,
    MIN(o.created_at) AS first_order_at,
    MAX(o.created_at) AS last_order_at
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE o.merchant_id = $1
  AND o.user_id = $2
  AND o.status IN ('delivered', 'completed')
GROUP BY o.user_id, u.full_name, u.phone, u.avatar_url
`

type GetCustomerMerchantDetailParams struct {
	MerchantID int64 `json:"merchant_id"`
	UserID     int64 `json:"user_id"`
}

type GetCustomerMerchantDetailRow struct {
	UserID         int64       `json:"user_id"`
	FullName       string      `json:"full_name"`
	Phone          pgtype.Text `json:"phone"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	TotalOrders    int32       `json:"total_orders"`
	TotalAmount    int64       `json:"total_amount"`
	AvgOrderAmount int32       `json:"avg_order_amount"`
	FirstOrderAt   interface{} `json:"first_order_at"`
	LastOrderAt    interface{} `json:"last_order_at"`
}

// 单个顾客在某商户的消费详情
func (q *Queries) GetCustomerMerchantDetail(ctx context.Context, arg GetCustomerMerchantDetailParams) (GetCustomerMerchantDetailRow, error) {
	row := q.db.QueryRow(ctx, getCustomerMerchantDetail, arg.MerchantID, arg.UserID)
	var i GetCustomerMerchantDetailRow
	err := row.Scan(
		&i.UserID,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.TotalOrders,
		&i.TotalAmount,
		&i.AvgOrderAmount,
		&i.FirstOrderAt,
		&i.LastOrderAt,
	)
	return i, err
}

const getDishCategoryStats = `-- name: GetDishCategoryStats :many
SELECT 
    dc.id AS category_id,
    dc.name AS category_name,
    COUNT(DISTINCT oi.dish_id)::int AS dish_count,
    SUM(oi.quantity)::int AS total_quantity,
    COALESCE(SUM(oi.subtotal), 0)::bigint AS total_revenue
FROM dish_categories dc
JOIN merchant_dish_categories mdc ON dc.id = mdc.category_id
LEFT JOIN dishes d ON d.category_id = dc.id AND d.merchant_id = mdc.merchant_id
LEFT JOIN order_items oi ON oi.dish_id = d.id
LEFT JOIN orders o ON o.id = oi.order_id 
    AND o.created_at >= $2 
    AND o.created_at <= $3
    AND o.status IN ('delivered', 'completed')
WHERE mdc.merchant_id = $1
GROUP BY dc.id, dc.name, mdc.sort_order
ORDER BY mdc.sort_order ASC, total_revenue DESC
`

type GetDishCategoryStatsParams struct {
	MerchantID int64     `json:"merchant_id"`
	StartDate  time.Time `json:"start_date"`
	EndDate    time.Time `json:"end_date"`
}

type GetDishCategoryStatsRow struct {
	CategoryID    int64  `json:"category_id"`
	CategoryName  string `json:"category_name"`
	DishCount     int32  `json:"dish_count"`
	TotalQuantity int32  `json:"total_quantity"`
	TotalRevenue  int64  `json:"total_revenue"`
}

// 菜品分类销售统计
func (q *Queries) GetDishCategoryStats(ctx context.Context, arg GetDishCategoryStatsParams) ([]GetDishCategoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getDishCategoryStats, arg.MerchantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDishCategoryStatsRow{}
	for rows.Next() {
		var i GetDishCategoryStatsRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.DishCount,
			&i.TotalQuantity,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantCustomerStats = `-- name: GetMerchantCustomerStats :many
SELECT 
    o.user_id,
    u.full_name,
    u.phone,
    u.avatar_url,
    COUNT(*)::int AS total_orders,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_amount,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COALESCE(SUM(o.final_amount), 0) / COUNT(*))::bigint
        ELSE 0
    END AS avg_order_amount,
    MIN(o.created_at) AS first_order_at,
    MAX(o.created_at) AS last_order_at
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE o.merchant_id = $1
  AND o.status IN ('delivered', 'completed')
GROUP BY o.user_id, u.full_name, u.phone, u.avatar_url
ORDER BY 
    CASE 
        WHEN $4::text = 'total_orders' THEN COUNT(*)
        WHEN $4::text = 'total_amount' THEN SUM(o.final_amount)
        ELSE EXTRACT(EPOCH FROM MAX(o.created_at))
    END DESC
LIMIT $2 OFFSET $3
`

type GetMerchantCustomerStatsParams struct {
	MerchantID int64  `json:"merchant_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
	OrderBy    string `json:"order_by"`
}

type GetMerchantCustomerStatsRow struct {
	UserID         int64       `json:"user_id"`
	FullName       string      `json:"full_name"`
	Phone          pgtype.Text `json:"phone"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	TotalOrders    int32       `json:"total_orders"`
	TotalAmount    int64       `json:"total_amount"`
	AvgOrderAmount int32       `json:"avg_order_amount"`
	FirstOrderAt   interface{} `json:"first_order_at"`
	LastOrderAt    interface{} `json:"last_order_at"`
}

// 顾客消费分析: 实时计算每个顾客的消费统计
func (q *Queries) GetMerchantCustomerStats(ctx context.Context, arg GetMerchantCustomerStatsParams) ([]GetMerchantCustomerStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantCustomerStats,
		arg.MerchantID,
		arg.Limit,
		arg.Offset,
		arg.OrderBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantCustomerStatsRow{}
	for rows.Next() {
		var i GetMerchantCustomerStatsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
			&i.TotalOrders,
			&i.TotalAmount,
			&i.AvgOrderAmount,
			&i.FirstOrderAt,
			&i.LastOrderAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantDailyStats = `-- name: GetMerchantDailyStats :many

SELECT 
    DATE(created_at) AS date,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(SUM(platform_commission), 0)::bigint AS commission,
    COUNT(*) FILTER (WHERE order_type = 'takeout')::int AS takeout_orders,
    COUNT(*) FILTER (WHERE order_type = 'dine_in')::int AS dine_in_orders
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetMerchantDailyStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantDailyStatsRow struct {
	Date          pgtype.Date `json:"date"`
	OrderCount    int32       `json:"order_count"`
	TotalSales    int64       `json:"total_sales"`
	Commission    int64       `json:"commission"`
	TakeoutOrders int32       `json:"takeout_orders"`
	DineInOrders  int32       `json:"dine_in_orders"`
}

// M12: 商户统计查询 (实时计算)
// 商户日报: 按天聚合订单数据
func (q *Queries) GetMerchantDailyStats(ctx context.Context, arg GetMerchantDailyStatsParams) ([]GetMerchantDailyStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantDailyStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantDailyStatsRow{}
	for rows.Next() {
		var i GetMerchantDailyStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderCount,
			&i.TotalSales,
			&i.Commission,
			&i.TakeoutOrders,
			&i.DineInOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantHourlyStats = `-- name: GetMerchantHourlyStats :many
SELECT 
    EXTRACT(HOUR FROM created_at)::int AS hour,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(AVG(final_amount), 0)::bigint AS avg_order_amount
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
GROUP BY EXTRACT(HOUR FROM created_at)
ORDER BY hour
`

type GetMerchantHourlyStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantHourlyStatsRow struct {
	Hour           int32 `json:"hour"`
	OrderCount     int32 `json:"order_count"`
	TotalSales     int64 `json:"total_sales"`
	AvgOrderAmount int64 `json:"avg_order_amount"`
}

// 商户时段分析: 按小时统计订单分布
func (q *Queries) GetMerchantHourlyStats(ctx context.Context, arg GetMerchantHourlyStatsParams) ([]GetMerchantHourlyStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantHourlyStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantHourlyStatsRow{}
	for rows.Next() {
		var i GetMerchantHourlyStatsRow
		if err := rows.Scan(
			&i.Hour,
			&i.OrderCount,
			&i.TotalSales,
			&i.AvgOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantOrderSourceStats = `-- name: GetMerchantOrderSourceStats :many
SELECT 
    order_type,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(AVG(final_amount), 0)::bigint AS avg_order_amount
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
GROUP BY order_type
ORDER BY order_count DESC
`

type GetMerchantOrderSourceStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantOrderSourceStatsRow struct {
	OrderType      string `json:"order_type"`
	OrderCount     int32  `json:"order_count"`
	TotalSales     int64  `json:"total_sales"`
	AvgOrderAmount int64  `json:"avg_order_amount"`
}

// 订单来源分析
func (q *Queries) GetMerchantOrderSourceStats(ctx context.Context, arg GetMerchantOrderSourceStatsParams) ([]GetMerchantOrderSourceStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantOrderSourceStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantOrderSourceStatsRow{}
	for rows.Next() {
		var i GetMerchantOrderSourceStatsRow
		if err := rows.Scan(
			&i.OrderType,
			&i.OrderCount,
			&i.TotalSales,
			&i.AvgOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantOverview = `-- name: GetMerchantOverview :one
SELECT 
    COUNT(DISTINCT DATE(created_at))::int AS total_days,
    COUNT(*)::int AS total_orders,
    COALESCE(SUM(final_amount), 0)::bigint AS total_sales,
    COALESCE(SUM(platform_commission), 0)::bigint AS total_commission,
    CASE 
        WHEN COUNT(DISTINCT DATE(created_at)) > 0 
        THEN (COALESCE(SUM(final_amount), 0) / COUNT(DISTINCT DATE(created_at)))::bigint
        ELSE 0
    END AS avg_daily_sales
FROM orders
WHERE merchant_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND status IN ('delivered', 'completed')
`

type GetMerchantOverviewParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantOverviewRow struct {
	TotalDays       int32 `json:"total_days"`
	TotalOrders     int32 `json:"total_orders"`
	TotalSales      int64 `json:"total_sales"`
	TotalCommission int64 `json:"total_commission"`
	AvgDailySales   int32 `json:"avg_daily_sales"`
}

// 商户概览: 指定日期范围的汇总统计
func (q *Queries) GetMerchantOverview(ctx context.Context, arg GetMerchantOverviewParams) (GetMerchantOverviewRow, error) {
	row := q.db.QueryRow(ctx, getMerchantOverview, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantOverviewRow
	err := row.Scan(
		&i.TotalDays,
		&i.TotalOrders,
		&i.TotalSales,
		&i.TotalCommission,
		&i.AvgDailySales,
	)
	return i, err
}

const getMerchantRepurchaseRate = `-- name: GetMerchantRepurchaseRate :one
WITH customer_order_counts AS (
    SELECT 
        user_id,
        COUNT(*) AS order_count
    FROM orders
    WHERE merchant_id = $1
      AND created_at >= $2
      AND created_at <= $3
      AND status IN ('delivered', 'completed')
    GROUP BY user_id
)
SELECT 
    COUNT(*)::int AS total_customers,
    COUNT(*) FILTER (WHERE order_count > 1)::int AS repeat_customers,
    COALESCE(SUM(order_count), 0)::int AS total_orders,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COUNT(*) FILTER (WHERE order_count > 1)::numeric / COUNT(*)::numeric * 10000)::int
        ELSE 0
    END AS repurchase_rate_basis_points,
    CASE 
        WHEN COUNT(*) > 0 
        THEN (COALESCE(SUM(order_count), 0)::numeric / COUNT(*)::numeric * 100)::int
        ELSE 0
    END AS avg_orders_per_user_cents
FROM customer_order_counts
`

type GetMerchantRepurchaseRateParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantRepurchaseRateRow struct {
	TotalCustomers            int32 `json:"total_customers"`
	RepeatCustomers           int32 `json:"repeat_customers"`
	TotalOrders               int32 `json:"total_orders"`
	RepurchaseRateBasisPoints int32 `json:"repurchase_rate_basis_points"`
	AvgOrdersPerUserCents     int32 `json:"avg_orders_per_user_cents"`
}

// 复购率分析
// 注意: repurchase_rate_percent 返回万分比(如 7550 表示 75.50%)，API层需除以100
// 注意: avg_orders_per_user 返回百分比形式(如 235 表示 2.35次)，API层需除以100
func (q *Queries) GetMerchantRepurchaseRate(ctx context.Context, arg GetMerchantRepurchaseRateParams) (GetMerchantRepurchaseRateRow, error) {
	row := q.db.QueryRow(ctx, getMerchantRepurchaseRate, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantRepurchaseRateRow
	err := row.Scan(
		&i.TotalCustomers,
		&i.RepeatCustomers,
		&i.TotalOrders,
		&i.RepurchaseRateBasisPoints,
		&i.AvgOrdersPerUserCents,
	)
	return i, err
}

const getTopSellingDishes = `-- name: GetTopSellingDishes :many
SELECT 
    oi.dish_id,
    d.name AS dish_name,
    d.price AS dish_price,
    SUM(oi.quantity)::int AS total_sold,
    COALESCE(SUM(oi.subtotal), 0)::bigint AS total_revenue
FROM order_items oi
JOIN dishes d ON d.id = oi.dish_id
JOIN orders o ON o.id = oi.order_id
WHERE o.merchant_id = $1
  AND o.created_at >= $2
  AND o.created_at <= $3
  AND o.status IN ('delivered', 'completed')
GROUP BY oi.dish_id, d.name, d.price
ORDER BY total_sold DESC
LIMIT $4
`

type GetTopSellingDishesParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
}

type GetTopSellingDishesRow struct {
	DishID       pgtype.Int8 `json:"dish_id"`
	DishName     string      `json:"dish_name"`
	DishPrice    int64       `json:"dish_price"`
	TotalSold    int32       `json:"total_sold"`
	TotalRevenue int64       `json:"total_revenue"`
}

// 菜品销量排行: 从order_items实时聚合
func (q *Queries) GetTopSellingDishes(ctx context.Context, arg GetTopSellingDishesParams) ([]GetTopSellingDishesRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingDishes,
		arg.MerchantID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopSellingDishesRow{}
	for rows.Next() {
		var i GetTopSellingDishesRow
		if err := rows.Scan(
			&i.DishID,
			&i.DishName,
			&i.DishPrice,
			&i.TotalSold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
