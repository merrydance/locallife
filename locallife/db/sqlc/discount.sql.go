// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discount.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveDiscountRules = `-- name: CountActiveDiscountRules :one
SELECT COUNT(*) FROM discount_rules
WHERE merchant_id = $1 
    AND deleted_at IS NULL
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
`

func (q *Queries) CountActiveDiscountRules(ctx context.Context, merchantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveDiscountRules, merchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDiscountRule = `-- name: CreateDiscountRule :one

INSERT INTO discount_rules (
    merchant_id,
    name,
    description,
    min_order_amount,
    discount_amount,
    can_stack_with_voucher,
    can_stack_with_membership,
    valid_from,
    valid_until,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at
`

type CreateDiscountRuleParams struct {
	MerchantID             int64       `json:"merchant_id"`
	Name                   string      `json:"name"`
	Description            pgtype.Text `json:"description"`
	MinOrderAmount         int64       `json:"min_order_amount"`
	DiscountAmount         int64       `json:"discount_amount"`
	CanStackWithVoucher    bool        `json:"can_stack_with_voucher"`
	CanStackWithMembership bool        `json:"can_stack_with_membership"`
	ValidFrom              time.Time   `json:"valid_from"`
	ValidUntil             time.Time   `json:"valid_until"`
	IsActive               bool        `json:"is_active"`
}

// Discount Rules (满减规则)
func (q *Queries) CreateDiscountRule(ctx context.Context, arg CreateDiscountRuleParams) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, createDiscountRule,
		arg.MerchantID,
		arg.Name,
		arg.Description,
		arg.MinOrderAmount,
		arg.DiscountAmount,
		arg.CanStackWithVoucher,
		arg.CanStackWithMembership,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
	)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.MinOrderAmount,
		&i.DiscountAmount,
		&i.CanStackWithVoucher,
		&i.CanStackWithMembership,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteDiscountRule = `-- name: DeleteDiscountRule :exec
UPDATE discount_rules SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

// 软删除满减规则
func (q *Queries) DeleteDiscountRule(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDiscountRule, id)
	return err
}

const getApplicableDiscountRules = `-- name: GetApplicableDiscountRules :many
SELECT id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at FROM discount_rules
WHERE merchant_id = $1 
    AND deleted_at IS NULL
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
    AND min_order_amount <= $2
ORDER BY discount_amount DESC
`

type GetApplicableDiscountRulesParams struct {
	MerchantID     int64 `json:"merchant_id"`
	MinOrderAmount int64 `json:"min_order_amount"`
}

func (q *Queries) GetApplicableDiscountRules(ctx context.Context, arg GetApplicableDiscountRulesParams) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, getApplicableDiscountRules, arg.MerchantID, arg.MinOrderAmount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.MinOrderAmount,
			&i.DiscountAmount,
			&i.CanStackWithVoucher,
			&i.CanStackWithMembership,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestDiscountRule = `-- name: GetBestDiscountRule :one
SELECT id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at FROM discount_rules
WHERE merchant_id = $1 
    AND deleted_at IS NULL
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
    AND min_order_amount <= $2
ORDER BY discount_amount DESC
LIMIT 1
`

type GetBestDiscountRuleParams struct {
	MerchantID     int64 `json:"merchant_id"`
	MinOrderAmount int64 `json:"min_order_amount"`
}

func (q *Queries) GetBestDiscountRule(ctx context.Context, arg GetBestDiscountRuleParams) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, getBestDiscountRule, arg.MerchantID, arg.MinOrderAmount)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.MinOrderAmount,
		&i.DiscountAmount,
		&i.CanStackWithVoucher,
		&i.CanStackWithMembership,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDiscountRule = `-- name: GetDiscountRule :one
SELECT id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at FROM discount_rules
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetDiscountRule(ctx context.Context, id int64) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, getDiscountRule, id)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.MinOrderAmount,
		&i.DiscountAmount,
		&i.CanStackWithVoucher,
		&i.CanStackWithMembership,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveDiscountRules = `-- name: ListActiveDiscountRules :many
SELECT id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at FROM discount_rules
WHERE merchant_id = $1 
    AND deleted_at IS NULL
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
ORDER BY min_order_amount ASC
`

func (q *Queries) ListActiveDiscountRules(ctx context.Context, merchantID int64) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, listActiveDiscountRules, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.MinOrderAmount,
			&i.DiscountAmount,
			&i.CanStackWithVoucher,
			&i.CanStackWithMembership,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantDiscountRules = `-- name: ListMerchantDiscountRules :many
SELECT id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at FROM discount_rules
WHERE merchant_id = $1 AND deleted_at IS NULL
ORDER BY min_order_amount ASC
LIMIT $2 OFFSET $3
`

type ListMerchantDiscountRulesParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListMerchantDiscountRules(ctx context.Context, arg ListMerchantDiscountRulesParams) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, listMerchantDiscountRules, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.MinOrderAmount,
			&i.DiscountAmount,
			&i.CanStackWithVoucher,
			&i.CanStackWithMembership,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDiscountRule = `-- name: UpdateDiscountRule :one
UPDATE discount_rules
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    min_order_amount = COALESCE($3, min_order_amount),
    discount_amount = COALESCE($4, discount_amount),
    can_stack_with_voucher = COALESCE($5, can_stack_with_voucher),
    can_stack_with_membership = COALESCE($6, can_stack_with_membership),
    valid_from = COALESCE($7, valid_from),
    valid_until = COALESCE($8, valid_until),
    is_active = COALESCE($9, is_active),
    updated_at = NOW()
WHERE id = $10 AND deleted_at IS NULL
RETURNING id, merchant_id, name, description, min_order_amount, discount_amount, can_stack_with_voucher, can_stack_with_membership, valid_from, valid_until, is_active, created_at, updated_at, deleted_at
`

type UpdateDiscountRuleParams struct {
	Name                   pgtype.Text        `json:"name"`
	Description            pgtype.Text        `json:"description"`
	MinOrderAmount         pgtype.Int8        `json:"min_order_amount"`
	DiscountAmount         pgtype.Int8        `json:"discount_amount"`
	CanStackWithVoucher    pgtype.Bool        `json:"can_stack_with_voucher"`
	CanStackWithMembership pgtype.Bool        `json:"can_stack_with_membership"`
	ValidFrom              pgtype.Timestamptz `json:"valid_from"`
	ValidUntil             pgtype.Timestamptz `json:"valid_until"`
	IsActive               pgtype.Bool        `json:"is_active"`
	ID                     int64              `json:"id"`
}

func (q *Queries) UpdateDiscountRule(ctx context.Context, arg UpdateDiscountRuleParams) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, updateDiscountRule,
		arg.Name,
		arg.Description,
		arg.MinOrderAmount,
		arg.DiscountAmount,
		arg.CanStackWithVoucher,
		arg.CanStackWithMembership,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
		arg.ID,
	)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.MinOrderAmount,
		&i.DiscountAmount,
		&i.CanStackWithVoucher,
		&i.CanStackWithMembership,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
