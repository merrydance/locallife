// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCartItem = `-- name: AddCartItem :one
INSERT INTO cart_items (cart_id, dish_id, combo_id, quantity, customizations)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, cart_id, dish_id, combo_id, quantity, customizations, created_at, updated_at
`

type AddCartItemParams struct {
	CartID         int64       `json:"cart_id"`
	DishID         pgtype.Int8 `json:"dish_id"`
	ComboID        pgtype.Int8 `json:"combo_id"`
	Quantity       int16       `json:"quantity"`
	Customizations []byte      `json:"customizations"`
}

func (q *Queries) AddCartItem(ctx context.Context, arg AddCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, addCartItem,
		arg.CartID,
		arg.DishID,
		arg.ComboID,
		arg.Quantity,
		arg.Customizations,
	)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.DishID,
		&i.ComboID,
		&i.Quantity,
		&i.Customizations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const clearCart = `-- name: ClearCart :exec
DELETE FROM cart_items
WHERE cart_id = $1
`

func (q *Queries) ClearCart(ctx context.Context, cartID int64) error {
	_, err := q.db.Exec(ctx, clearCart, cartID)
	return err
}

const clearMultipleCarts = `-- name: ClearMultipleCarts :exec
DELETE FROM cart_items
WHERE cart_id = ANY($1::bigint[])
`

// 批量清空购物车（合单支付成功后）
func (q *Queries) ClearMultipleCarts(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, clearMultipleCarts, dollar_1)
	return err
}

const createCart = `-- name: CreateCart :one
INSERT INTO carts (user_id, merchant_id)
VALUES ($1, $2)
ON CONFLICT (user_id, merchant_id) DO UPDATE SET updated_at = now()
RETURNING id, user_id, merchant_id, updated_at, created_at
`

type CreateCartParams struct {
	UserID     int64 `json:"user_id"`
	MerchantID int64 `json:"merchant_id"`
}

func (q *Queries) CreateCart(ctx context.Context, arg CreateCartParams) (Cart, error) {
	row := q.db.QueryRow(ctx, createCart, arg.UserID, arg.MerchantID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCart = `-- name: DeleteCart :exec
DELETE FROM carts
WHERE id = $1
`

func (q *Queries) DeleteCart(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCart, id)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
DELETE FROM cart_items
WHERE id = $1
`

func (q *Queries) DeleteCartItem(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCartItem, id)
	return err
}

const getCart = `-- name: GetCart :one
SELECT id, user_id, merchant_id, updated_at, created_at FROM carts
WHERE id = $1
`

func (q *Queries) GetCart(ctx context.Context, id int64) (Cart, error) {
	row := q.db.QueryRow(ctx, getCart, id)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCartByUserAndMerchant = `-- name: GetCartByUserAndMerchant :one
SELECT id, user_id, merchant_id, updated_at, created_at FROM carts
WHERE user_id = $1 AND merchant_id = $2
`

type GetCartByUserAndMerchantParams struct {
	UserID     int64 `json:"user_id"`
	MerchantID int64 `json:"merchant_id"`
}

func (q *Queries) GetCartByUserAndMerchant(ctx context.Context, arg GetCartByUserAndMerchantParams) (Cart, error) {
	row := q.db.QueryRow(ctx, getCartByUserAndMerchant, arg.UserID, arg.MerchantID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCartItem = `-- name: GetCartItem :one
SELECT 
    ci.id, ci.cart_id, ci.dish_id, ci.combo_id, ci.quantity, ci.customizations, ci.created_at, ci.updated_at,
    d.name AS dish_name,
    d.price AS dish_price,
    d.member_price AS dish_member_price,
    d.is_available AS dish_is_available,
    cs.name AS combo_name,
    cs.combo_price AS combo_price,
    cs.is_online AS combo_is_available
FROM cart_items ci
LEFT JOIN dishes d ON d.id = ci.dish_id
LEFT JOIN combo_sets cs ON cs.id = ci.combo_id
WHERE ci.id = $1
`

type GetCartItemRow struct {
	ID               int64       `json:"id"`
	CartID           int64       `json:"cart_id"`
	DishID           pgtype.Int8 `json:"dish_id"`
	ComboID          pgtype.Int8 `json:"combo_id"`
	Quantity         int16       `json:"quantity"`
	Customizations   []byte      `json:"customizations"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	DishName         pgtype.Text `json:"dish_name"`
	DishPrice        pgtype.Int8 `json:"dish_price"`
	DishMemberPrice  pgtype.Int8 `json:"dish_member_price"`
	DishIsAvailable  pgtype.Bool `json:"dish_is_available"`
	ComboName        pgtype.Text `json:"combo_name"`
	ComboPrice       pgtype.Int8 `json:"combo_price"`
	ComboIsAvailable pgtype.Bool `json:"combo_is_available"`
}

func (q *Queries) GetCartItem(ctx context.Context, id int64) (GetCartItemRow, error) {
	row := q.db.QueryRow(ctx, getCartItem, id)
	var i GetCartItemRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.DishID,
		&i.ComboID,
		&i.Quantity,
		&i.Customizations,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DishName,
		&i.DishPrice,
		&i.DishMemberPrice,
		&i.DishIsAvailable,
		&i.ComboName,
		&i.ComboPrice,
		&i.ComboIsAvailable,
	)
	return i, err
}

const getCartItemByCombo = `-- name: GetCartItemByCombo :one
SELECT id, cart_id, dish_id, combo_id, quantity, customizations, created_at, updated_at FROM cart_items
WHERE cart_id = $1 AND combo_id = $2
`

type GetCartItemByComboParams struct {
	CartID  int64       `json:"cart_id"`
	ComboID pgtype.Int8 `json:"combo_id"`
}

func (q *Queries) GetCartItemByCombo(ctx context.Context, arg GetCartItemByComboParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, getCartItemByCombo, arg.CartID, arg.ComboID)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.DishID,
		&i.ComboID,
		&i.Quantity,
		&i.Customizations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByDishAndCustomizations = `-- name: GetCartItemByDishAndCustomizations :one
SELECT id, cart_id, dish_id, combo_id, quantity, customizations, created_at, updated_at FROM cart_items
WHERE cart_id = $1 AND dish_id = $2 AND customizations = $3
`

type GetCartItemByDishAndCustomizationsParams struct {
	CartID         int64       `json:"cart_id"`
	DishID         pgtype.Int8 `json:"dish_id"`
	Customizations []byte      `json:"customizations"`
}

func (q *Queries) GetCartItemByDishAndCustomizations(ctx context.Context, arg GetCartItemByDishAndCustomizationsParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, getCartItemByDishAndCustomizations, arg.CartID, arg.DishID, arg.Customizations)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.DishID,
		&i.ComboID,
		&i.Quantity,
		&i.Customizations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartWithItems = `-- name: GetCartWithItems :one
SELECT 
    c.id, c.user_id, c.merchant_id, c.updated_at, c.created_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', ci.id,
                'dish_id', ci.dish_id,
                'combo_id', ci.combo_id,
                'quantity', ci.quantity,
                'customizations', ci.customizations,
                'dish_name', d.name,
                'dish_image_url', d.image_url,
                'dish_price', d.price,
                'dish_member_price', d.member_price,
                'dish_is_available', d.is_available,
                'combo_name', cs.name,
                'combo_image_url', cs.image_url,
                'combo_original_price', cs.original_price,
                'combo_price', cs.combo_price,
                'combo_is_available', cs.is_online
            ) ORDER BY ci.created_at
        ) FILTER (WHERE ci.id IS NOT NULL), '[]'
    )::json AS items
FROM carts c
LEFT JOIN cart_items ci ON ci.cart_id = c.id
LEFT JOIN dishes d ON d.id = ci.dish_id
LEFT JOIN combo_sets cs ON cs.id = ci.combo_id
WHERE c.user_id = $1 AND c.merchant_id = $2
GROUP BY c.id
`

type GetCartWithItemsParams struct {
	UserID     int64 `json:"user_id"`
	MerchantID int64 `json:"merchant_id"`
}

type GetCartWithItemsRow struct {
	ID         int64     `json:"id"`
	UserID     int64     `json:"user_id"`
	MerchantID int64     `json:"merchant_id"`
	UpdatedAt  time.Time `json:"updated_at"`
	CreatedAt  time.Time `json:"created_at"`
	Items      []byte    `json:"items"`
}

func (q *Queries) GetCartWithItems(ctx context.Context, arg GetCartWithItemsParams) (GetCartWithItemsRow, error) {
	row := q.db.QueryRow(ctx, getCartWithItems, arg.UserID, arg.MerchantID)
	var i GetCartWithItemsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Items,
	)
	return i, err
}

const getUserCarts = `-- name: GetUserCarts :many
SELECT 
    c.id, c.user_id, c.merchant_id, c.updated_at, c.created_at,
    m.name AS merchant_name,
    m.logo_url AS merchant_logo,
    COUNT(ci.id) AS item_count
FROM carts c
JOIN merchants m ON m.id = c.merchant_id
LEFT JOIN cart_items ci ON ci.cart_id = c.id
WHERE c.user_id = $1
GROUP BY c.id, m.id
ORDER BY c.updated_at DESC
`

type GetUserCartsRow struct {
	ID           int64       `json:"id"`
	UserID       int64       `json:"user_id"`
	MerchantID   int64       `json:"merchant_id"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CreatedAt    time.Time   `json:"created_at"`
	MerchantName string      `json:"merchant_name"`
	MerchantLogo pgtype.Text `json:"merchant_logo"`
	ItemCount    int64       `json:"item_count"`
}

func (q *Queries) GetUserCarts(ctx context.Context, userID int64) ([]GetUserCartsRow, error) {
	rows, err := q.db.Query(ctx, getUserCarts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCartsRow{}
	for rows.Next() {
		var i GetUserCartsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.ItemCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCartsByCartIDs = `-- name: GetUserCartsByCartIDs :many
SELECT 
    c.id,
    c.user_id,
    c.merchant_id,
    c.updated_at,
    c.created_at,
    m.name AS merchant_name,
    m.logo_url AS merchant_logo,
    m.region_id AS region_id,
    mpc.sub_mch_id AS sub_mchid,
    m.status AS merchant_status,
    m.latitude AS merchant_latitude,
    m.longitude AS merchant_longitude
FROM carts c
JOIN merchants m ON m.id = c.merchant_id
LEFT JOIN merchant_payment_configs mpc ON mpc.merchant_id = m.id
WHERE c.user_id = $1 AND c.id = ANY($2::bigint[])
ORDER BY c.updated_at DESC
`

type GetUserCartsByCartIDsParams struct {
	UserID  int64   `json:"user_id"`
	Column2 []int64 `json:"column_2"`
}

type GetUserCartsByCartIDsRow struct {
	ID                int64          `json:"id"`
	UserID            int64          `json:"user_id"`
	MerchantID        int64          `json:"merchant_id"`
	UpdatedAt         time.Time      `json:"updated_at"`
	CreatedAt         time.Time      `json:"created_at"`
	MerchantName      string         `json:"merchant_name"`
	MerchantLogo      pgtype.Text    `json:"merchant_logo"`
	RegionID          int64          `json:"region_id"`
	SubMchid          pgtype.Text    `json:"sub_mchid"`
	MerchantStatus    string         `json:"merchant_status"`
	MerchantLatitude  pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude pgtype.Numeric `json:"merchant_longitude"`
}

// 根据购物车ID列表获取用户购物车详情（用于合单结算）
func (q *Queries) GetUserCartsByCartIDs(ctx context.Context, arg GetUserCartsByCartIDsParams) ([]GetUserCartsByCartIDsRow, error) {
	rows, err := q.db.Query(ctx, getUserCartsByCartIDs, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCartsByCartIDsRow{}
	for rows.Next() {
		var i GetUserCartsByCartIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.RegionID,
			&i.SubMchid,
			&i.MerchantStatus,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCartsByMerchantIDs = `-- name: GetUserCartsByMerchantIDs :many
SELECT 
    c.id, c.user_id, c.merchant_id, c.updated_at, c.created_at,
    m.name AS merchant_name,
    mpc.sub_mch_id AS sub_mchid,
    m.status AS merchant_status
FROM carts c
JOIN merchants m ON m.id = c.merchant_id
LEFT JOIN merchant_payment_configs mpc ON mpc.merchant_id = m.id
WHERE c.user_id = $1 AND c.merchant_id = ANY($2::bigint[])
ORDER BY c.updated_at DESC
`

type GetUserCartsByMerchantIDsParams struct {
	UserID  int64   `json:"user_id"`
	Column2 []int64 `json:"column_2"`
}

type GetUserCartsByMerchantIDsRow struct {
	ID             int64       `json:"id"`
	UserID         int64       `json:"user_id"`
	MerchantID     int64       `json:"merchant_id"`
	UpdatedAt      time.Time   `json:"updated_at"`
	CreatedAt      time.Time   `json:"created_at"`
	MerchantName   string      `json:"merchant_name"`
	SubMchid       pgtype.Text `json:"sub_mchid"`
	MerchantStatus string      `json:"merchant_status"`
}

// 根据商户ID列表获取用户购物车（用于合单结算时验证）
func (q *Queries) GetUserCartsByMerchantIDs(ctx context.Context, arg GetUserCartsByMerchantIDsParams) ([]GetUserCartsByMerchantIDsRow, error) {
	rows, err := q.db.Query(ctx, getUserCartsByMerchantIDs, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCartsByMerchantIDsRow{}
	for rows.Next() {
		var i GetUserCartsByMerchantIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.MerchantName,
			&i.SubMchid,
			&i.MerchantStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCartsSummary = `-- name: GetUserCartsSummary :one

SELECT 
    COUNT(DISTINCT c.id)::int AS cart_count,
    COUNT(ci.id)::int AS total_items,
    COALESCE(SUM(
        CASE 
            WHEN ci.dish_id IS NOT NULL THEN d.price * ci.quantity
            WHEN ci.combo_id IS NOT NULL THEN cs.combo_price * ci.quantity
            ELSE 0
        END
    ), 0)::bigint AS total_amount
FROM carts c
LEFT JOIN cart_items ci ON ci.cart_id = c.id
LEFT JOIN dishes d ON d.id = ci.dish_id
LEFT JOIN combo_sets cs ON cs.id = ci.combo_id
WHERE c.user_id = $1
`

type GetUserCartsSummaryRow struct {
	CartCount   int32 `json:"cart_count"`
	TotalItems  int32 `json:"total_items"`
	TotalAmount int64 `json:"total_amount"`
}

// ==================== 多商户购物车汇总查询 ====================
// 获取用户所有购物车的汇总统计
func (q *Queries) GetUserCartsSummary(ctx context.Context, userID int64) (GetUserCartsSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserCartsSummary, userID)
	var i GetUserCartsSummaryRow
	err := row.Scan(&i.CartCount, &i.TotalItems, &i.TotalAmount)
	return i, err
}

const getUserCartsWithDetails = `-- name: GetUserCartsWithDetails :many
SELECT 
    c.id AS cart_id,
    c.merchant_id,
    m.name AS merchant_name,
    m.logo_url AS merchant_logo,
    mpc.sub_mch_id AS sub_mchid,
    COUNT(ci.id)::int AS item_count,
    COALESCE(SUM(
        CASE 
            WHEN ci.dish_id IS NOT NULL THEN d.price * ci.quantity
            WHEN ci.combo_id IS NOT NULL THEN cs.combo_price * ci.quantity
            ELSE 0
        END
    ), 0)::bigint AS subtotal,
    -- 检查商品可用性
    BOOL_AND(
        CASE 
            WHEN ci.dish_id IS NOT NULL THEN d.is_available AND d.is_online
            WHEN ci.combo_id IS NOT NULL THEN cs.is_online
            ELSE true
        END
    ) AS all_available,
    c.updated_at
FROM carts c
JOIN merchants m ON m.id = c.merchant_id
LEFT JOIN merchant_payment_configs mpc ON mpc.merchant_id = m.id
LEFT JOIN cart_items ci ON ci.cart_id = c.id
LEFT JOIN dishes d ON d.id = ci.dish_id
LEFT JOIN combo_sets cs ON cs.id = ci.combo_id
WHERE c.user_id = $1
GROUP BY c.id, c.merchant_id, m.id, mpc.sub_mch_id
HAVING COUNT(ci.id) > 0  -- 只返回有商品的购物车
ORDER BY c.updated_at DESC
`

type GetUserCartsWithDetailsRow struct {
	CartID       int64       `json:"cart_id"`
	MerchantID   int64       `json:"merchant_id"`
	MerchantName string      `json:"merchant_name"`
	MerchantLogo pgtype.Text `json:"merchant_logo"`
	SubMchid     pgtype.Text `json:"sub_mchid"`
	ItemCount    int32       `json:"item_count"`
	Subtotal     int64       `json:"subtotal"`
	AllAvailable bool        `json:"all_available"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

// 获取用户所有购物车及其商品详情（用于合单结算）
func (q *Queries) GetUserCartsWithDetails(ctx context.Context, userID int64) ([]GetUserCartsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getUserCartsWithDetails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCartsWithDetailsRow{}
	for rows.Next() {
		var i GetUserCartsWithDetailsRow
		if err := rows.Scan(
			&i.CartID,
			&i.MerchantID,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.SubMchid,
			&i.ItemCount,
			&i.Subtotal,
			&i.AllAvailable,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCartItems = `-- name: ListCartItems :many
SELECT 
    ci.id, ci.cart_id, ci.dish_id, ci.combo_id, ci.quantity, ci.customizations, ci.created_at, ci.updated_at,
    d.name AS dish_name,
    d.image_url AS dish_image_url,
    d.price AS dish_price,
    d.member_price AS dish_member_price,
    d.is_available AS dish_is_available,
    cs.name AS combo_name,
    cs.image_url AS combo_image_url,
    cs.original_price AS combo_original_price,
    cs.combo_price AS combo_price,
    cs.is_online AS combo_is_available
FROM cart_items ci
LEFT JOIN dishes d ON d.id = ci.dish_id
LEFT JOIN combo_sets cs ON cs.id = ci.combo_id
WHERE ci.cart_id = $1
ORDER BY ci.created_at
`

type ListCartItemsRow struct {
	ID                 int64       `json:"id"`
	CartID             int64       `json:"cart_id"`
	DishID             pgtype.Int8 `json:"dish_id"`
	ComboID            pgtype.Int8 `json:"combo_id"`
	Quantity           int16       `json:"quantity"`
	Customizations     []byte      `json:"customizations"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	DishName           pgtype.Text `json:"dish_name"`
	DishImageUrl       pgtype.Text `json:"dish_image_url"`
	DishPrice          pgtype.Int8 `json:"dish_price"`
	DishMemberPrice    pgtype.Int8 `json:"dish_member_price"`
	DishIsAvailable    pgtype.Bool `json:"dish_is_available"`
	ComboName          pgtype.Text `json:"combo_name"`
	ComboImageUrl      pgtype.Text `json:"combo_image_url"`
	ComboOriginalPrice pgtype.Int8 `json:"combo_original_price"`
	ComboPrice         pgtype.Int8 `json:"combo_price"`
	ComboIsAvailable   pgtype.Bool `json:"combo_is_available"`
}

func (q *Queries) ListCartItems(ctx context.Context, cartID int64) ([]ListCartItemsRow, error) {
	rows, err := q.db.Query(ctx, listCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCartItemsRow{}
	for rows.Next() {
		var i ListCartItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.DishID,
			&i.ComboID,
			&i.Quantity,
			&i.Customizations,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DishName,
			&i.DishImageUrl,
			&i.DishPrice,
			&i.DishMemberPrice,
			&i.DishIsAvailable,
			&i.ComboName,
			&i.ComboImageUrl,
			&i.ComboOriginalPrice,
			&i.ComboPrice,
			&i.ComboIsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCartItemsForCheckout = `-- name: ListCartItemsForCheckout :many
SELECT 
    ci.id, ci.cart_id, ci.dish_id, ci.combo_id, ci.quantity, ci.customizations, ci.created_at, ci.updated_at,
    d.name AS dish_name,
    d.image_url AS dish_image_url,
    d.price AS dish_price,
    d.member_price AS dish_member_price,
    d.is_available AS dish_is_available,
    d.is_online AS dish_is_online,
    d.merchant_id AS dish_merchant_id,
    cs.name AS combo_name,
    cs.image_url AS combo_image_url,
    cs.combo_price AS combo_price,
    cs.is_online AS combo_is_online,
    cs.merchant_id AS combo_merchant_id
FROM cart_items ci
LEFT JOIN dishes d ON d.id = ci.dish_id
LEFT JOIN combo_sets cs ON cs.id = ci.combo_id
WHERE ci.cart_id = ANY($1::bigint[])
ORDER BY ci.cart_id, ci.created_at
`

type ListCartItemsForCheckoutRow struct {
	ID              int64       `json:"id"`
	CartID          int64       `json:"cart_id"`
	DishID          pgtype.Int8 `json:"dish_id"`
	ComboID         pgtype.Int8 `json:"combo_id"`
	Quantity        int16       `json:"quantity"`
	Customizations  []byte      `json:"customizations"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	DishName        pgtype.Text `json:"dish_name"`
	DishImageUrl    pgtype.Text `json:"dish_image_url"`
	DishPrice       pgtype.Int8 `json:"dish_price"`
	DishMemberPrice pgtype.Int8 `json:"dish_member_price"`
	DishIsAvailable pgtype.Bool `json:"dish_is_available"`
	DishIsOnline    pgtype.Bool `json:"dish_is_online"`
	DishMerchantID  pgtype.Int8 `json:"dish_merchant_id"`
	ComboName       pgtype.Text `json:"combo_name"`
	ComboImageUrl   pgtype.Text `json:"combo_image_url"`
	ComboPrice      pgtype.Int8 `json:"combo_price"`
	ComboIsOnline   pgtype.Bool `json:"combo_is_online"`
	ComboMerchantID pgtype.Int8 `json:"combo_merchant_id"`
}

// 获取购物车商品详情（用于结算时校验价格和可用性）
func (q *Queries) ListCartItemsForCheckout(ctx context.Context, dollar_1 []int64) ([]ListCartItemsForCheckoutRow, error) {
	rows, err := q.db.Query(ctx, listCartItemsForCheckout, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCartItemsForCheckoutRow{}
	for rows.Next() {
		var i ListCartItemsForCheckoutRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.DishID,
			&i.ComboID,
			&i.Quantity,
			&i.Customizations,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DishName,
			&i.DishImageUrl,
			&i.DishPrice,
			&i.DishMemberPrice,
			&i.DishIsAvailable,
			&i.DishIsOnline,
			&i.DishMerchantID,
			&i.ComboName,
			&i.ComboImageUrl,
			&i.ComboPrice,
			&i.ComboIsOnline,
			&i.ComboMerchantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCartItem = `-- name: UpdateCartItem :one
UPDATE cart_items
SET 
    quantity = COALESCE($2, quantity),
    customizations = COALESCE($3, customizations),
    updated_at = now()
WHERE id = $1
RETURNING id, cart_id, dish_id, combo_id, quantity, customizations, created_at, updated_at
`

type UpdateCartItemParams struct {
	ID             int64       `json:"id"`
	Quantity       pgtype.Int2 `json:"quantity"`
	Customizations []byte      `json:"customizations"`
}

func (q *Queries) UpdateCartItem(ctx context.Context, arg UpdateCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, updateCartItem, arg.ID, arg.Quantity, arg.Customizations)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.DishID,
		&i.ComboID,
		&i.Quantity,
		&i.Customizations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
