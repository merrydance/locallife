// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: favorite.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFavoriteDish = `-- name: AddFavoriteDish :one
INSERT INTO favorites (user_id, favorite_type, dish_id)
VALUES ($1, 'dish', $2)
ON CONFLICT (user_id, favorite_type, dish_id) WHERE dish_id IS NOT NULL 
DO NOTHING
RETURNING id, user_id, favorite_type, merchant_id, dish_id, created_at
`

type AddFavoriteDishParams struct {
	UserID int64       `json:"user_id"`
	DishID pgtype.Int8 `json:"dish_id"`
}

func (q *Queries) AddFavoriteDish(ctx context.Context, arg AddFavoriteDishParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, addFavoriteDish, arg.UserID, arg.DishID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FavoriteType,
		&i.MerchantID,
		&i.DishID,
		&i.CreatedAt,
	)
	return i, err
}

const addFavoriteMerchant = `-- name: AddFavoriteMerchant :one
INSERT INTO favorites (user_id, favorite_type, merchant_id)
VALUES ($1, 'merchant', $2)
ON CONFLICT (user_id, favorite_type, merchant_id) WHERE merchant_id IS NOT NULL 
DO NOTHING
RETURNING id, user_id, favorite_type, merchant_id, dish_id, created_at
`

type AddFavoriteMerchantParams struct {
	UserID     int64       `json:"user_id"`
	MerchantID pgtype.Int8 `json:"merchant_id"`
}

func (q *Queries) AddFavoriteMerchant(ctx context.Context, arg AddFavoriteMerchantParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, addFavoriteMerchant, arg.UserID, arg.MerchantID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FavoriteType,
		&i.MerchantID,
		&i.DishID,
		&i.CreatedAt,
	)
	return i, err
}

const countFavoriteDishes = `-- name: CountFavoriteDishes :one
SELECT COUNT(*) FROM favorites
WHERE user_id = $1 AND favorite_type = 'dish'
`

func (q *Queries) CountFavoriteDishes(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countFavoriteDishes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFavoriteMerchants = `-- name: CountFavoriteMerchants :one
SELECT COUNT(*) FROM favorites
WHERE user_id = $1 AND favorite_type = 'merchant'
`

func (q *Queries) CountFavoriteMerchants(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countFavoriteMerchants, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isDishFavorited = `-- name: IsDishFavorited :one
SELECT EXISTS(
    SELECT 1 FROM favorites
    WHERE user_id = $1 AND favorite_type = 'dish' AND dish_id = $2
) AS is_favorited
`

type IsDishFavoritedParams struct {
	UserID int64       `json:"user_id"`
	DishID pgtype.Int8 `json:"dish_id"`
}

func (q *Queries) IsDishFavorited(ctx context.Context, arg IsDishFavoritedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isDishFavorited, arg.UserID, arg.DishID)
	var is_favorited bool
	err := row.Scan(&is_favorited)
	return is_favorited, err
}

const isMerchantFavorited = `-- name: IsMerchantFavorited :one
SELECT EXISTS(
    SELECT 1 FROM favorites
    WHERE user_id = $1 AND favorite_type = 'merchant' AND merchant_id = $2
) AS is_favorited
`

type IsMerchantFavoritedParams struct {
	UserID     int64       `json:"user_id"`
	MerchantID pgtype.Int8 `json:"merchant_id"`
}

func (q *Queries) IsMerchantFavorited(ctx context.Context, arg IsMerchantFavoritedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMerchantFavorited, arg.UserID, arg.MerchantID)
	var is_favorited bool
	err := row.Scan(&is_favorited)
	return is_favorited, err
}

const listFavoriteDishes = `-- name: ListFavoriteDishes :many
SELECT 
    f.id,
    f.created_at,
    d.id AS dish_id,
    d.name AS dish_name,
    d.description AS dish_description,
    d.image_url AS dish_image_url,
    d.price AS dish_price,
    d.member_price AS dish_member_price,
    d.is_available AS dish_is_available,
    d.is_online AS dish_is_online,
    m.id AS merchant_id,
    m.name AS merchant_name
FROM favorites f
JOIN dishes d ON d.id = f.dish_id
JOIN merchants m ON m.id = d.merchant_id
WHERE f.user_id = $1 AND f.favorite_type = 'dish'
ORDER BY f.created_at DESC
LIMIT $2 OFFSET $3
`

type ListFavoriteDishesParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFavoriteDishesRow struct {
	ID              int64       `json:"id"`
	CreatedAt       time.Time   `json:"created_at"`
	DishID          int64       `json:"dish_id"`
	DishName        string      `json:"dish_name"`
	DishDescription pgtype.Text `json:"dish_description"`
	DishImageUrl    pgtype.Text `json:"dish_image_url"`
	DishPrice       int64       `json:"dish_price"`
	DishMemberPrice pgtype.Int8 `json:"dish_member_price"`
	DishIsAvailable bool        `json:"dish_is_available"`
	DishIsOnline    bool        `json:"dish_is_online"`
	MerchantID      int64       `json:"merchant_id"`
	MerchantName    string      `json:"merchant_name"`
}

func (q *Queries) ListFavoriteDishes(ctx context.Context, arg ListFavoriteDishesParams) ([]ListFavoriteDishesRow, error) {
	rows, err := q.db.Query(ctx, listFavoriteDishes, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFavoriteDishesRow{}
	for rows.Next() {
		var i ListFavoriteDishesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.DishID,
			&i.DishName,
			&i.DishDescription,
			&i.DishImageUrl,
			&i.DishPrice,
			&i.DishMemberPrice,
			&i.DishIsAvailable,
			&i.DishIsOnline,
			&i.MerchantID,
			&i.MerchantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoriteMerchants = `-- name: ListFavoriteMerchants :many
SELECT 
    f.id,
    f.created_at,
    m.id AS merchant_id,
    m.name AS merchant_name,
    m.logo_url AS merchant_logo,
    m.address AS merchant_address,
    m.status AS merchant_status
FROM favorites f
JOIN merchants m ON m.id = f.merchant_id
WHERE f.user_id = $1 AND f.favorite_type = 'merchant'
ORDER BY f.created_at DESC
LIMIT $2 OFFSET $3
`

type ListFavoriteMerchantsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFavoriteMerchantsRow struct {
	ID              int64       `json:"id"`
	CreatedAt       time.Time   `json:"created_at"`
	MerchantID      int64       `json:"merchant_id"`
	MerchantName    string      `json:"merchant_name"`
	MerchantLogo    pgtype.Text `json:"merchant_logo"`
	MerchantAddress string      `json:"merchant_address"`
	MerchantStatus  string      `json:"merchant_status"`
}

func (q *Queries) ListFavoriteMerchants(ctx context.Context, arg ListFavoriteMerchantsParams) ([]ListFavoriteMerchantsRow, error) {
	rows, err := q.db.Query(ctx, listFavoriteMerchants, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFavoriteMerchantsRow{}
	for rows.Next() {
		var i ListFavoriteMerchantsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.MerchantID,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantAddress,
			&i.MerchantStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavoriteDish = `-- name: RemoveFavoriteDish :exec
DELETE FROM favorites
WHERE user_id = $1 AND favorite_type = 'dish' AND dish_id = $2
`

type RemoveFavoriteDishParams struct {
	UserID int64       `json:"user_id"`
	DishID pgtype.Int8 `json:"dish_id"`
}

func (q *Queries) RemoveFavoriteDish(ctx context.Context, arg RemoveFavoriteDishParams) error {
	_, err := q.db.Exec(ctx, removeFavoriteDish, arg.UserID, arg.DishID)
	return err
}

const removeFavoriteMerchant = `-- name: RemoveFavoriteMerchant :exec
DELETE FROM favorites
WHERE user_id = $1 AND favorite_type = 'merchant' AND merchant_id = $2
`

type RemoveFavoriteMerchantParams struct {
	UserID     int64       `json:"user_id"`
	MerchantID pgtype.Int8 `json:"merchant_id"`
}

func (q *Queries) RemoveFavoriteMerchant(ctx context.Context, arg RemoveFavoriteMerchantParams) error {
	_, err := q.db.Exec(ctx, removeFavoriteMerchant, arg.UserID, arg.MerchantID)
	return err
}
