// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMerchantOrdersByStatusAfterTime = `-- name: CountMerchantOrdersByStatusAfterTime :one
SELECT COUNT(*) FROM orders
WHERE merchant_id = $1 
  AND status = $2 
  AND created_at >= $3
`

type CountMerchantOrdersByStatusAfterTimeParams struct {
	MerchantID int64     `json:"merchant_id"`
	Status     string    `json:"status"`
	CreatedAt  time.Time `json:"created_at"`
}

// 统计商户在某时间后特定状态的订单数
func (q *Queries) CountMerchantOrdersByStatusAfterTime(ctx context.Context, arg CountMerchantOrdersByStatusAfterTimeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantOrdersByStatusAfterTime, arg.MerchantID, arg.Status, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMerchantPromotionOrders = `-- name: CountMerchantPromotionOrders :one
SELECT COUNT(*)::bigint
FROM orders
WHERE merchant_id = $1
  AND delivery_fee_discount > 0
  AND status IN ('delivered', 'completed')
  AND created_at >= $2 AND created_at <= $3
`

type CountMerchantPromotionOrdersParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) CountMerchantPromotionOrders(ctx context.Context, arg CountMerchantPromotionOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantPromotionOrders, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countOrderUrges = `-- name: CountOrderUrges :one
SELECT COUNT(*)::bigint FROM order_status_logs
WHERE order_id = $1 AND notes LIKE '%催单%'
`

// 统计订单被催单次数（从状态日志表查询催单记录）
func (q *Queries) CountOrderUrges(ctx context.Context, orderID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countOrderUrges, orderID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countOrdersByMerchant = `-- name: CountOrdersByMerchant :one
SELECT COUNT(*) FROM orders
WHERE merchant_id = $1
`

func (q *Queries) CountOrdersByMerchant(ctx context.Context, merchantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByMerchant, merchantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByMerchantAndStatus = `-- name: CountOrdersByMerchantAndStatus :one
SELECT COUNT(*) FROM orders
WHERE merchant_id = $1 AND status = $2
`

type CountOrdersByMerchantAndStatusParams struct {
	MerchantID int64  `json:"merchant_id"`
	Status     string `json:"status"`
}

func (q *Queries) CountOrdersByMerchantAndStatus(ctx context.Context, arg CountOrdersByMerchantAndStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByMerchantAndStatus, arg.MerchantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    order_no,
    user_id,
    merchant_id,
    order_type,
    address_id,
    delivery_fee,
    delivery_distance,
    table_id,
    reservation_id,
    subtotal,
    discount_amount,
    delivery_fee_discount,
    total_amount,
    status,
    notes,
    user_voucher_id,
    voucher_amount,
    balance_paid,
    membership_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) RETURNING id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id
`

type CreateOrderParams struct {
	OrderNo             string      `json:"order_no"`
	UserID              int64       `json:"user_id"`
	MerchantID          int64       `json:"merchant_id"`
	OrderType           string      `json:"order_type"`
	AddressID           pgtype.Int8 `json:"address_id"`
	DeliveryFee         int64       `json:"delivery_fee"`
	DeliveryDistance    pgtype.Int4 `json:"delivery_distance"`
	TableID             pgtype.Int8 `json:"table_id"`
	ReservationID       pgtype.Int8 `json:"reservation_id"`
	Subtotal            int64       `json:"subtotal"`
	DiscountAmount      int64       `json:"discount_amount"`
	DeliveryFeeDiscount int64       `json:"delivery_fee_discount"`
	TotalAmount         int64       `json:"total_amount"`
	Status              string      `json:"status"`
	Notes               pgtype.Text `json:"notes"`
	UserVoucherID       pgtype.Int8 `json:"user_voucher_id"`
	VoucherAmount       int64       `json:"voucher_amount"`
	BalancePaid         int64       `json:"balance_paid"`
	MembershipID        pgtype.Int8 `json:"membership_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrderNo,
		arg.UserID,
		arg.MerchantID,
		arg.OrderType,
		arg.AddressID,
		arg.DeliveryFee,
		arg.DeliveryDistance,
		arg.TableID,
		arg.ReservationID,
		arg.Subtotal,
		arg.DiscountAmount,
		arg.DeliveryFeeDiscount,
		arg.TotalAmount,
		arg.Status,
		arg.Notes,
		arg.UserVoucherID,
		arg.VoucherAmount,
		arg.BalancePaid,
		arg.MembershipID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const getMerchantAvgPrepareTime = `-- name: GetMerchantAvgPrepareTime :one
SELECT COALESCE(
    ROUND(AVG(
        EXTRACT(EPOCH FROM (osl.created_at - o.paid_at)) / 60
    )),
    0
)::bigint as avg_prepare_minutes
FROM orders o
INNER JOIN order_status_logs osl ON o.id = osl.order_id
WHERE o.merchant_id = $1
  AND o.paid_at IS NOT NULL
  AND osl.to_status = 'ready'
  AND o.created_at >= $2
`

type GetMerchantAvgPrepareTimeParams struct {
	MerchantID int64     `json:"merchant_id"`
	CreatedAt  time.Time `json:"created_at"`
}

// 计算商户近N天的平均出餐时间（分钟）
// 通过订单支付时间到状态变为ready的时间差计算
func (q *Queries) GetMerchantAvgPrepareTime(ctx context.Context, arg GetMerchantAvgPrepareTimeParams) (int64, error) {
	row := q.db.QueryRow(ctx, getMerchantAvgPrepareTime, arg.MerchantID, arg.CreatedAt)
	var avg_prepare_minutes int64
	err := row.Scan(&avg_prepare_minutes)
	return avg_prepare_minutes, err
}

const getMerchantDailyPromotionExpenses = `-- name: GetMerchantDailyPromotionExpenses :many
SELECT 
    DATE(created_at) AS date,
    COUNT(*) as order_count,
    COALESCE(SUM(delivery_fee_discount), 0)::bigint as promotion_amount
FROM orders
WHERE merchant_id = $1
  AND delivery_fee_discount > 0
  AND status IN ('delivered', 'completed')
  AND created_at >= $2 AND created_at <= $3
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetMerchantDailyPromotionExpensesParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantDailyPromotionExpensesRow struct {
	Date            pgtype.Date `json:"date"`
	OrderCount      int64       `json:"order_count"`
	PromotionAmount int64       `json:"promotion_amount"`
}

// 商户每日满返支出汇总
func (q *Queries) GetMerchantDailyPromotionExpenses(ctx context.Context, arg GetMerchantDailyPromotionExpensesParams) ([]GetMerchantDailyPromotionExpensesRow, error) {
	rows, err := q.db.Query(ctx, getMerchantDailyPromotionExpenses, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantDailyPromotionExpensesRow{}
	for rows.Next() {
		var i GetMerchantDailyPromotionExpensesRow
		if err := rows.Scan(&i.Date, &i.OrderCount, &i.PromotionAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantPromotionExpenses = `-- name: GetMerchantPromotionExpenses :one

SELECT 
    COUNT(*) FILTER (WHERE delivery_fee_discount > 0) as promo_order_count,
    COALESCE(SUM(delivery_fee_discount), 0)::bigint as total_discount
FROM orders
WHERE merchant_id = $1
  AND status IN ('delivered', 'completed')
  AND created_at >= $2 AND created_at <= $3
`

type GetMerchantPromotionExpensesParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantPromotionExpensesRow struct {
	PromoOrderCount int64 `json:"promo_order_count"`
	TotalDiscount   int64 `json:"total_discount"`
}

// ==================== 商户财务相关查询 ====================
// 统计商户满返运费支出
func (q *Queries) GetMerchantPromotionExpenses(ctx context.Context, arg GetMerchantPromotionExpensesParams) (GetMerchantPromotionExpensesRow, error) {
	row := q.db.QueryRow(ctx, getMerchantPromotionExpenses, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetMerchantPromotionExpensesRow
	err := row.Scan(&i.PromoOrderCount, &i.TotalDiscount)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const getOrderByOrderNo = `-- name: GetOrderByOrderNo :one
SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE order_no = $1 LIMIT 1
`

func (q *Queries) GetOrderByOrderNo(ctx context.Context, orderNo string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByOrderNo, orderNo)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetOrderForUpdate(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const getOrderStats = `-- name: GetOrderStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'paid') as paid_count,
    COUNT(*) FILTER (WHERE status = 'preparing') as preparing_count,
    COUNT(*) FILTER (WHERE status = 'ready') as ready_count,
    COUNT(*) FILTER (WHERE status = 'delivering') as delivering_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_count
FROM orders
WHERE merchant_id = $1 AND created_at >= $2 AND created_at <= $3
`

type GetOrderStatsParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetOrderStatsRow struct {
	PendingCount    int64 `json:"pending_count"`
	PaidCount       int64 `json:"paid_count"`
	PreparingCount  int64 `json:"preparing_count"`
	ReadyCount      int64 `json:"ready_count"`
	DeliveringCount int64 `json:"delivering_count"`
	CompletedCount  int64 `json:"completed_count"`
	CancelledCount  int64 `json:"cancelled_count"`
}

func (q *Queries) GetOrderStats(ctx context.Context, arg GetOrderStatsParams) (GetOrderStatsRow, error) {
	row := q.db.QueryRow(ctx, getOrderStats, arg.MerchantID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetOrderStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.PaidCount,
		&i.PreparingCount,
		&i.ReadyCount,
		&i.DeliveringCount,
		&i.CompletedCount,
		&i.CancelledCount,
	)
	return i, err
}

const getOrderWithDetails = `-- name: GetOrderWithDetails :one
SELECT 
    o.id, o.order_no, o.user_id, o.merchant_id, o.order_type, o.address_id, o.delivery_fee, o.delivery_distance, o.table_id, o.reservation_id, o.subtotal, o.discount_amount, o.delivery_fee_discount, o.total_amount, o.status, o.payment_method, o.paid_at, o.notes, o.created_at, o.updated_at, o.completed_at, o.cancelled_at, o.cancel_reason, o.final_amount, o.platform_commission, o.user_voucher_id, o.voucher_amount, o.balance_paid, o.membership_id,
    m.name as merchant_name,
    m.phone as merchant_phone,
    m.address as merchant_address,
    ua.contact_name as delivery_contact_name,
    ua.contact_phone as delivery_contact_phone,
    ua.detail_address as delivery_address
FROM orders o
INNER JOIN merchants m ON o.merchant_id = m.id
LEFT JOIN user_addresses ua ON o.address_id = ua.id
WHERE o.id = $1
`

type GetOrderWithDetailsRow struct {
	ID                   int64              `json:"id"`
	OrderNo              string             `json:"order_no"`
	UserID               int64              `json:"user_id"`
	MerchantID           int64              `json:"merchant_id"`
	OrderType            string             `json:"order_type"`
	AddressID            pgtype.Int8        `json:"address_id"`
	DeliveryFee          int64              `json:"delivery_fee"`
	DeliveryDistance     pgtype.Int4        `json:"delivery_distance"`
	TableID              pgtype.Int8        `json:"table_id"`
	ReservationID        pgtype.Int8        `json:"reservation_id"`
	Subtotal             int64              `json:"subtotal"`
	DiscountAmount       int64              `json:"discount_amount"`
	DeliveryFeeDiscount  int64              `json:"delivery_fee_discount"`
	TotalAmount          int64              `json:"total_amount"`
	Status               string             `json:"status"`
	PaymentMethod        pgtype.Text        `json:"payment_method"`
	PaidAt               pgtype.Timestamptz `json:"paid_at"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CompletedAt          pgtype.Timestamptz `json:"completed_at"`
	CancelledAt          pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason         pgtype.Text        `json:"cancel_reason"`
	FinalAmount          pgtype.Int8        `json:"final_amount"`
	PlatformCommission   pgtype.Int8        `json:"platform_commission"`
	UserVoucherID        pgtype.Int8        `json:"user_voucher_id"`
	VoucherAmount        int64              `json:"voucher_amount"`
	BalancePaid          int64              `json:"balance_paid"`
	MembershipID         pgtype.Int8        `json:"membership_id"`
	MerchantName         string             `json:"merchant_name"`
	MerchantPhone        string             `json:"merchant_phone"`
	MerchantAddress      string             `json:"merchant_address"`
	DeliveryContactName  pgtype.Text        `json:"delivery_contact_name"`
	DeliveryContactPhone pgtype.Text        `json:"delivery_contact_phone"`
	DeliveryAddress      pgtype.Text        `json:"delivery_address"`
}

func (q *Queries) GetOrderWithDetails(ctx context.Context, id int64) (GetOrderWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithDetails, id)
	var i GetOrderWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
		&i.MerchantName,
		&i.MerchantPhone,
		&i.MerchantAddress,
		&i.DeliveryContactName,
		&i.DeliveryContactPhone,
		&i.DeliveryAddress,
	)
	return i, err
}

const listMerchantOrdersByStatus = `-- name: ListMerchantOrdersByStatus :many

SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE merchant_id = $1 AND status = $2
ORDER BY created_at ASC
LIMIT $3 OFFSET $4
`

type ListMerchantOrdersByStatusParams struct {
	MerchantID int64  `json:"merchant_id"`
	Status     string `json:"status"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

// ==================== KDS 厨房显示系统查询 ====================
// 根据商户ID和状态查询订单（用于厨房显示）
func (q *Queries) ListMerchantOrdersByStatus(ctx context.Context, arg ListMerchantOrdersByStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listMerchantOrdersByStatus,
		arg.MerchantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.MerchantID,
			&i.OrderType,
			&i.AddressID,
			&i.DeliveryFee,
			&i.DeliveryDistance,
			&i.TableID,
			&i.ReservationID,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.FinalAmount,
			&i.PlatformCommission,
			&i.UserVoucherID,
			&i.VoucherAmount,
			&i.BalancePaid,
			&i.MembershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantPromotionOrders = `-- name: ListMerchantPromotionOrders :many
SELECT 
    id,
    order_no,
    order_type,
    subtotal,
    delivery_fee,
    delivery_fee_discount,
    total_amount,
    created_at,
    completed_at
FROM orders
WHERE merchant_id = $1
  AND delivery_fee_discount > 0
  AND status IN ('delivered', 'completed')
  AND created_at >= $2 AND created_at <= $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListMerchantPromotionOrdersParams struct {
	MerchantID  int64     `json:"merchant_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListMerchantPromotionOrdersRow struct {
	ID                  int64              `json:"id"`
	OrderNo             string             `json:"order_no"`
	OrderType           string             `json:"order_type"`
	Subtotal            int64              `json:"subtotal"`
	DeliveryFee         int64              `json:"delivery_fee"`
	DeliveryFeeDiscount int64              `json:"delivery_fee_discount"`
	TotalAmount         int64              `json:"total_amount"`
	CreatedAt           time.Time          `json:"created_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
}

// 商户满返支出明细
func (q *Queries) ListMerchantPromotionOrders(ctx context.Context, arg ListMerchantPromotionOrdersParams) ([]ListMerchantPromotionOrdersRow, error) {
	rows, err := q.db.Query(ctx, listMerchantPromotionOrders,
		arg.MerchantID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMerchantPromotionOrdersRow{}
	for rows.Next() {
		var i ListMerchantPromotionOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.OrderType,
			&i.Subtotal,
			&i.DeliveryFee,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByMerchant = `-- name: ListOrdersByMerchant :many
SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByMerchantParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListOrdersByMerchant(ctx context.Context, arg ListOrdersByMerchantParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByMerchant, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.MerchantID,
			&i.OrderType,
			&i.AddressID,
			&i.DeliveryFee,
			&i.DeliveryDistance,
			&i.TableID,
			&i.ReservationID,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.FinalAmount,
			&i.PlatformCommission,
			&i.UserVoucherID,
			&i.VoucherAmount,
			&i.BalancePaid,
			&i.MembershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByMerchantAndStatus = `-- name: ListOrdersByMerchantAndStatus :many
SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE merchant_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersByMerchantAndStatusParams struct {
	MerchantID int64  `json:"merchant_id"`
	Status     string `json:"status"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListOrdersByMerchantAndStatus(ctx context.Context, arg ListOrdersByMerchantAndStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByMerchantAndStatus,
		arg.MerchantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.MerchantID,
			&i.OrderType,
			&i.AddressID,
			&i.DeliveryFee,
			&i.DeliveryDistance,
			&i.TableID,
			&i.ReservationID,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.FinalAmount,
			&i.PlatformCommission,
			&i.UserVoucherID,
			&i.VoucherAmount,
			&i.BalancePaid,
			&i.MembershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByMerchantAndStatuses = `-- name: ListOrdersByMerchantAndStatuses :many
SELECT id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id FROM orders
WHERE merchant_id = $1 AND status = ANY($2::text[])
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersByMerchantAndStatusesParams struct {
	MerchantID int64    `json:"merchant_id"`
	Column2    []string `json:"column_2"`
	Limit      int32    `json:"limit"`
	Offset     int32    `json:"offset"`
}

func (q *Queries) ListOrdersByMerchantAndStatuses(ctx context.Context, arg ListOrdersByMerchantAndStatusesParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByMerchantAndStatuses,
		arg.MerchantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.MerchantID,
			&i.OrderType,
			&i.AddressID,
			&i.DeliveryFee,
			&i.DeliveryDistance,
			&i.TableID,
			&i.ReservationID,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.FinalAmount,
			&i.PlatformCommission,
			&i.UserVoucherID,
			&i.VoucherAmount,
			&i.BalancePaid,
			&i.MembershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT 
    o.id, o.order_no, o.user_id, o.merchant_id, o.order_type, o.address_id, o.delivery_fee, o.delivery_distance, o.table_id, o.reservation_id, o.subtotal, o.discount_amount, o.delivery_fee_discount, o.total_amount, o.status, o.payment_method, o.paid_at, o.notes, o.created_at, o.updated_at, o.completed_at, o.cancelled_at, o.cancel_reason, o.final_amount, o.platform_commission, o.user_voucher_id, o.voucher_amount, o.balance_paid, o.membership_id,
    m.name as merchant_name
FROM orders o
INNER JOIN merchants m ON o.merchant_id = m.id
WHERE o.user_id = $1
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListOrdersByUserRow struct {
	ID                  int64              `json:"id"`
	OrderNo             string             `json:"order_no"`
	UserID              int64              `json:"user_id"`
	MerchantID          int64              `json:"merchant_id"`
	OrderType           string             `json:"order_type"`
	AddressID           pgtype.Int8        `json:"address_id"`
	DeliveryFee         int64              `json:"delivery_fee"`
	DeliveryDistance    pgtype.Int4        `json:"delivery_distance"`
	TableID             pgtype.Int8        `json:"table_id"`
	ReservationID       pgtype.Int8        `json:"reservation_id"`
	Subtotal            int64              `json:"subtotal"`
	DiscountAmount      int64              `json:"discount_amount"`
	DeliveryFeeDiscount int64              `json:"delivery_fee_discount"`
	TotalAmount         int64              `json:"total_amount"`
	Status              string             `json:"status"`
	PaymentMethod       pgtype.Text        `json:"payment_method"`
	PaidAt              pgtype.Timestamptz `json:"paid_at"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	CancelledAt         pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason        pgtype.Text        `json:"cancel_reason"`
	FinalAmount         pgtype.Int8        `json:"final_amount"`
	PlatformCommission  pgtype.Int8        `json:"platform_commission"`
	UserVoucherID       pgtype.Int8        `json:"user_voucher_id"`
	VoucherAmount       int64              `json:"voucher_amount"`
	BalancePaid         int64              `json:"balance_paid"`
	MembershipID        pgtype.Int8        `json:"membership_id"`
	MerchantName        string             `json:"merchant_name"`
}

func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]ListOrdersByUserRow, error) {
	rows, err := q.db.Query(ctx, listOrdersByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersByUserRow{}
	for rows.Next() {
		var i ListOrdersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.MerchantID,
			&i.OrderType,
			&i.AddressID,
			&i.DeliveryFee,
			&i.DeliveryDistance,
			&i.TableID,
			&i.ReservationID,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.FinalAmount,
			&i.PlatformCommission,
			&i.UserVoucherID,
			&i.VoucherAmount,
			&i.BalancePaid,
			&i.MembershipID,
			&i.MerchantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUserAndStatus = `-- name: ListOrdersByUserAndStatus :many
SELECT 
    o.id, o.order_no, o.user_id, o.merchant_id, o.order_type, o.address_id, o.delivery_fee, o.delivery_distance, o.table_id, o.reservation_id, o.subtotal, o.discount_amount, o.delivery_fee_discount, o.total_amount, o.status, o.payment_method, o.paid_at, o.notes, o.created_at, o.updated_at, o.completed_at, o.cancelled_at, o.cancel_reason, o.final_amount, o.platform_commission, o.user_voucher_id, o.voucher_amount, o.balance_paid, o.membership_id,
    m.name as merchant_name
FROM orders o
INNER JOIN merchants m ON o.merchant_id = m.id
WHERE o.user_id = $1 AND o.status = $2
ORDER BY o.created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersByUserAndStatusParams struct {
	UserID int64  `json:"user_id"`
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListOrdersByUserAndStatusRow struct {
	ID                  int64              `json:"id"`
	OrderNo             string             `json:"order_no"`
	UserID              int64              `json:"user_id"`
	MerchantID          int64              `json:"merchant_id"`
	OrderType           string             `json:"order_type"`
	AddressID           pgtype.Int8        `json:"address_id"`
	DeliveryFee         int64              `json:"delivery_fee"`
	DeliveryDistance    pgtype.Int4        `json:"delivery_distance"`
	TableID             pgtype.Int8        `json:"table_id"`
	ReservationID       pgtype.Int8        `json:"reservation_id"`
	Subtotal            int64              `json:"subtotal"`
	DiscountAmount      int64              `json:"discount_amount"`
	DeliveryFeeDiscount int64              `json:"delivery_fee_discount"`
	TotalAmount         int64              `json:"total_amount"`
	Status              string             `json:"status"`
	PaymentMethod       pgtype.Text        `json:"payment_method"`
	PaidAt              pgtype.Timestamptz `json:"paid_at"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	CancelledAt         pgtype.Timestamptz `json:"cancelled_at"`
	CancelReason        pgtype.Text        `json:"cancel_reason"`
	FinalAmount         pgtype.Int8        `json:"final_amount"`
	PlatformCommission  pgtype.Int8        `json:"platform_commission"`
	UserVoucherID       pgtype.Int8        `json:"user_voucher_id"`
	VoucherAmount       int64              `json:"voucher_amount"`
	BalancePaid         int64              `json:"balance_paid"`
	MembershipID        pgtype.Int8        `json:"membership_id"`
	MerchantName        string             `json:"merchant_name"`
}

func (q *Queries) ListOrdersByUserAndStatus(ctx context.Context, arg ListOrdersByUserAndStatusParams) ([]ListOrdersByUserAndStatusRow, error) {
	rows, err := q.db.Query(ctx, listOrdersByUserAndStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersByUserAndStatusRow{}
	for rows.Next() {
		var i ListOrdersByUserAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.MerchantID,
			&i.OrderType,
			&i.AddressID,
			&i.DeliveryFee,
			&i.DeliveryDistance,
			&i.TableID,
			&i.ReservationID,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.DeliveryFeeDiscount,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.FinalAmount,
			&i.PlatformCommission,
			&i.UserVoucherID,
			&i.VoucherAmount,
			&i.BalancePaid,
			&i.MembershipID,
			&i.MerchantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET 
    status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id
`

type UpdateOrderStatusParams struct {
	ID     int64  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const updateOrderToCancelled = `-- name: UpdateOrderToCancelled :one
UPDATE orders
SET 
    status = 'cancelled',
    cancelled_at = now(),
    cancel_reason = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id
`

type UpdateOrderToCancelledParams struct {
	ID           int64       `json:"id"`
	CancelReason pgtype.Text `json:"cancel_reason"`
}

func (q *Queries) UpdateOrderToCancelled(ctx context.Context, arg UpdateOrderToCancelledParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderToCancelled, arg.ID, arg.CancelReason)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const updateOrderToCompleted = `-- name: UpdateOrderToCompleted :one
UPDATE orders
SET 
    status = 'completed',
    completed_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id
`

func (q *Queries) UpdateOrderToCompleted(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderToCompleted, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}

const updateOrderToPaid = `-- name: UpdateOrderToPaid :one
UPDATE orders
SET 
    status = 'paid',
    payment_method = $2,
    paid_at = now(),
    updated_at = now()
WHERE id = $1 AND status = 'pending'
RETURNING id, order_no, user_id, merchant_id, order_type, address_id, delivery_fee, delivery_distance, table_id, reservation_id, subtotal, discount_amount, delivery_fee_discount, total_amount, status, payment_method, paid_at, notes, created_at, updated_at, completed_at, cancelled_at, cancel_reason, final_amount, platform_commission, user_voucher_id, voucher_amount, balance_paid, membership_id
`

type UpdateOrderToPaidParams struct {
	ID            int64       `json:"id"`
	PaymentMethod pgtype.Text `json:"payment_method"`
}

func (q *Queries) UpdateOrderToPaid(ctx context.Context, arg UpdateOrderToPaidParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderToPaid, arg.ID, arg.PaymentMethod)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.MerchantID,
		&i.OrderType,
		&i.AddressID,
		&i.DeliveryFee,
		&i.DeliveryDistance,
		&i.TableID,
		&i.ReservationID,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.DeliveryFeeDiscount,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.FinalAmount,
		&i.PlatformCommission,
		&i.UserVoucherID,
		&i.VoucherAmount,
		&i.BalancePaid,
		&i.MembershipID,
	)
	return i, err
}
