// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trust_score.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const blacklistUser = `-- name: BlacklistUser :exec
UPDATE user_profiles
SET is_blacklisted = true,
    blacklist_reason = $3,
    blacklisted_at = NOW(),
    updated_at = NOW()
WHERE user_id = $1 AND role = $2
`

type BlacklistUserParams struct {
	UserID          int64       `json:"user_id"`
	Role            string      `json:"role"`
	BlacklistReason pgtype.Text `json:"blacklist_reason"`
}

func (q *Queries) BlacklistUser(ctx context.Context, arg BlacklistUserParams) error {
	_, err := q.db.Exec(ctx, blacklistUser, arg.UserID, arg.Role, arg.BlacklistReason)
	return err
}

const confirmFraudPattern = `-- name: ConfirmFraudPattern :exec
UPDATE fraud_patterns
SET is_confirmed = true,
    action_taken = $2,
    confirmed_at = NOW()
WHERE id = $1
`

type ConfirmFraudPatternParams struct {
	ID          int64       `json:"id"`
	ActionTaken pgtype.Text `json:"action_taken"`
}

func (q *Queries) ConfirmFraudPattern(ctx context.Context, arg ConfirmFraudPatternParams) error {
	_, err := q.db.Exec(ctx, confirmFraudPattern, arg.ID, arg.ActionTaken)
	return err
}

const countDistinctUsersInClaimWindow = `-- name: CountDistinctUsersInClaimWindow :one
SELECT COUNT(DISTINCT user_id) as user_count
FROM claims
WHERE created_at >= $1
  AND created_at <= $2
`

type CountDistinctUsersInClaimWindowParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

// 统计时间窗口内发起索赔的不同用户数
func (q *Queries) CountDistinctUsersInClaimWindow(ctx context.Context, arg CountDistinctUsersInClaimWindowParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDistinctUsersInClaimWindow, arg.CreatedAt, arg.CreatedAt_2)
	var user_count int64
	err := row.Scan(&user_count)
	return user_count, err
}

const countMerchantClaimsByType = `-- name: CountMerchantClaimsByType :one

SELECT COUNT(*) as total
FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE o.merchant_id = $1
  AND c.claim_type = $2
  AND c.created_at >= $3
`

type CountMerchantClaimsByTypeParams struct {
	MerchantID int64     `json:"merchant_id"`
	ClaimType  string    `json:"claim_type"`
	CreatedAt  time.Time `json:"created_at"`
}

// ==========================================
// 商户异物索赔追踪查询
// ==========================================
// 统计商户在指定时间窗口内特定类型的索赔数量
func (q *Queries) CountMerchantClaimsByType(ctx context.Context, arg CountMerchantClaimsByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantClaimsByType, arg.MerchantID, arg.ClaimType, arg.CreatedAt)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countRecentClaimsByUsers = `-- name: CountRecentClaimsByUsers :one
SELECT COUNT(*) as claim_count
FROM claims
WHERE user_id = ANY($1::bigint[])
  AND created_at >= NOW() - INTERVAL '1 day' * $2
`

type CountRecentClaimsByUsersParams struct {
	Column1 []int64     `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

// 统计多个用户最近N天的索赔总数
func (q *Queries) CountRecentClaimsByUsers(ctx context.Context, arg CountRecentClaimsByUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentClaimsByUsers, arg.Column1, arg.Column2)
	var claim_count int64
	err := row.Scan(&claim_count)
	return claim_count, err
}

const countRegionPendingClaims = `-- name: CountRegionPendingClaims :one
SELECT COUNT(*) as total
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN merchants m ON o.merchant_id = m.id
WHERE m.region_id = $1
  AND c.status = 'manual-review'
`

// 统计运营商区域内待人工审核的索赔数量
func (q *Queries) CountRegionPendingClaims(ctx context.Context, regionID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countRegionPendingClaims, regionID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countRiderDamageClaims = `-- name: CountRiderDamageClaims :one

SELECT COUNT(*) as total
FROM claims c
JOIN deliveries d ON c.order_id = d.order_id
WHERE d.rider_id = $1
  AND c.claim_type = $2
  AND c.created_at >= $3
`

type CountRiderDamageClaimsParams struct {
	RiderID   pgtype.Int8 `json:"rider_id"`
	ClaimType string      `json:"claim_type"`
	CreatedAt time.Time   `json:"created_at"`
}

// ==========================================
// 骑手统计查询（保留用于统计展示）
// ==========================================
// 统计骑手在指定时间窗口内的餐损索赔次数
func (q *Queries) CountRiderDamageClaims(ctx context.Context, arg CountRiderDamageClaimsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRiderDamageClaims, arg.RiderID, arg.ClaimType, arg.CreatedAt)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUserClaimsInPeriod = `-- name: CountUserClaimsInPeriod :one
SELECT COUNT(*) FROM claims
WHERE user_id = $1
  AND created_at >= $2
`

type CountUserClaimsInPeriodParams struct {
	UserID    int64     `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CountUserClaimsInPeriod(ctx context.Context, arg CountUserClaimsInPeriodParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserClaimsInPeriod, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserRecentClaims = `-- name: CountUserRecentClaims :one
SELECT COUNT(*) as total
FROM claims
WHERE user_id = $1
  AND created_at >= NOW() - ($2 || ' days')::INTERVAL
`

type CountUserRecentClaimsParams struct {
	UserID  int64       `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
}

// 统计用户近N天的索赔次数（用于行为回溯）
func (q *Queries) CountUserRecentClaims(ctx context.Context, arg CountUserRecentClaimsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserRecentClaims, arg.UserID, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUserRecentTakeoutOrders = `-- name: CountUserRecentTakeoutOrders :one

SELECT COUNT(*) as total
FROM orders
WHERE user_id = $1
  AND order_type = 'takeout'
  AND created_at >= NOW() - ($2 || ' days')::INTERVAL
`

type CountUserRecentTakeoutOrdersParams struct {
	UserID  int64       `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
}

// ==========================================
// 用户索赔行为回溯查询（新设计）
// ==========================================
// 统计用户近N天的外卖订单数（用于行为回溯）
func (q *Queries) CountUserRecentTakeoutOrders(ctx context.Context, arg CountUserRecentTakeoutOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserRecentTakeoutOrders, arg.UserID, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createClaim = `-- name: CreateClaim :one

INSERT INTO claims (
    order_id,
    user_id,
    claim_type,
    description,
    evidence_urls,
    claim_amount,
    approved_amount,
    status,
    approval_type,
    trust_score_snapshot,
    is_malicious,
    lookback_result,
    auto_approval_reason,
    rejection_reason,
    reviewer_id,
    review_notes,
    created_at,
    reviewed_at,
    paid_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) RETURNING id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at
`

type CreateClaimParams struct {
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
}

// ==========================================
// claims（索赔记录）
// ==========================================
func (q *Queries) CreateClaim(ctx context.Context, arg CreateClaimParams) (Claim, error) {
	row := q.db.QueryRow(ctx, createClaim,
		arg.OrderID,
		arg.UserID,
		arg.ClaimType,
		arg.Description,
		arg.EvidenceUrls,
		arg.ClaimAmount,
		arg.ApprovedAmount,
		arg.Status,
		arg.ApprovalType,
		arg.TrustScoreSnapshot,
		arg.IsMalicious,
		arg.LookbackResult,
		arg.AutoApprovalReason,
		arg.RejectionReason,
		arg.ReviewerID,
		arg.ReviewNotes,
		arg.CreatedAt,
		arg.ReviewedAt,
		arg.PaidAt,
	)
	var i Claim
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
	)
	return i, err
}

const createFoodSafetyIncident = `-- name: CreateFoodSafetyIncident :one

INSERT INTO food_safety_incidents (
    order_id,
    merchant_id,
    user_id,
    incident_type,
    description,
    evidence_urls,
    order_snapshot,
    merchant_snapshot,
    rider_snapshot,
    status,
    investigation_report,
    resolution,
    created_at,
    resolved_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, order_id, merchant_id, user_id, incident_type, description, evidence_urls, order_snapshot, merchant_snapshot, rider_snapshot, status, investigation_report, resolution, created_at, resolved_at
`

type CreateFoodSafetyIncidentParams struct {
	OrderID             int64              `json:"order_id"`
	MerchantID          int64              `json:"merchant_id"`
	UserID              int64              `json:"user_id"`
	IncidentType        string             `json:"incident_type"`
	Description         string             `json:"description"`
	EvidenceUrls        []string           `json:"evidence_urls"`
	OrderSnapshot       []byte             `json:"order_snapshot"`
	MerchantSnapshot    []byte             `json:"merchant_snapshot"`
	RiderSnapshot       []byte             `json:"rider_snapshot"`
	Status              string             `json:"status"`
	InvestigationReport pgtype.Text        `json:"investigation_report"`
	Resolution          pgtype.Text        `json:"resolution"`
	CreatedAt           time.Time          `json:"created_at"`
	ResolvedAt          pgtype.Timestamptz `json:"resolved_at"`
}

// ==========================================
// food_safety_incidents（食品安全事件）
// ==========================================
func (q *Queries) CreateFoodSafetyIncident(ctx context.Context, arg CreateFoodSafetyIncidentParams) (FoodSafetyIncident, error) {
	row := q.db.QueryRow(ctx, createFoodSafetyIncident,
		arg.OrderID,
		arg.MerchantID,
		arg.UserID,
		arg.IncidentType,
		arg.Description,
		arg.EvidenceUrls,
		arg.OrderSnapshot,
		arg.MerchantSnapshot,
		arg.RiderSnapshot,
		arg.Status,
		arg.InvestigationReport,
		arg.Resolution,
		arg.CreatedAt,
		arg.ResolvedAt,
	)
	var i FoodSafetyIncident
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.MerchantID,
		&i.UserID,
		&i.IncidentType,
		&i.Description,
		&i.EvidenceUrls,
		&i.OrderSnapshot,
		&i.MerchantSnapshot,
		&i.RiderSnapshot,
		&i.Status,
		&i.InvestigationReport,
		&i.Resolution,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const createFraudPattern = `-- name: CreateFraudPattern :one

INSERT INTO fraud_patterns (
    pattern_type,
    related_user_ids,
    related_order_ids,
    related_claim_ids,
    device_fingerprints,
    address_ids,
    ip_addresses,
    pattern_description,
    match_count,
    is_confirmed,
    reviewer_id,
    review_notes,
    action_taken,
    detected_at,
    reviewed_at,
    confirmed_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, pattern_type, related_user_ids, related_order_ids, related_claim_ids, device_fingerprints, address_ids, ip_addresses, pattern_description, match_count, is_confirmed, reviewer_id, review_notes, action_taken, detected_at, reviewed_at, confirmed_at
`

type CreateFraudPatternParams struct {
	PatternType        string             `json:"pattern_type"`
	RelatedUserIds     []int64            `json:"related_user_ids"`
	RelatedOrderIds    []int64            `json:"related_order_ids"`
	RelatedClaimIds    []int64            `json:"related_claim_ids"`
	DeviceFingerprints []string           `json:"device_fingerprints"`
	AddressIds         []int64            `json:"address_ids"`
	IpAddresses        []string           `json:"ip_addresses"`
	PatternDescription pgtype.Text        `json:"pattern_description"`
	MatchCount         int16              `json:"match_count"`
	IsConfirmed        bool               `json:"is_confirmed"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	ActionTaken        pgtype.Text        `json:"action_taken"`
	DetectedAt         time.Time          `json:"detected_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	ConfirmedAt        pgtype.Timestamptz `json:"confirmed_at"`
}

// ==========================================
// fraud_patterns（欺诈模式检测）
// ==========================================
func (q *Queries) CreateFraudPattern(ctx context.Context, arg CreateFraudPatternParams) (FraudPattern, error) {
	row := q.db.QueryRow(ctx, createFraudPattern,
		arg.PatternType,
		arg.RelatedUserIds,
		arg.RelatedOrderIds,
		arg.RelatedClaimIds,
		arg.DeviceFingerprints,
		arg.AddressIds,
		arg.IpAddresses,
		arg.PatternDescription,
		arg.MatchCount,
		arg.IsConfirmed,
		arg.ReviewerID,
		arg.ReviewNotes,
		arg.ActionTaken,
		arg.DetectedAt,
		arg.ReviewedAt,
		arg.ConfirmedAt,
	)
	var i FraudPattern
	err := row.Scan(
		&i.ID,
		&i.PatternType,
		&i.RelatedUserIds,
		&i.RelatedOrderIds,
		&i.RelatedClaimIds,
		&i.DeviceFingerprints,
		&i.AddressIds,
		&i.IpAddresses,
		&i.PatternDescription,
		&i.MatchCount,
		&i.IsConfirmed,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ActionTaken,
		&i.DetectedAt,
		&i.ReviewedAt,
		&i.ConfirmedAt,
	)
	return i, err
}

const createMerchantProfile = `-- name: CreateMerchantProfile :one

INSERT INTO merchant_profiles (
    merchant_id,
    trust_score
) VALUES (
    $1, $2
) RETURNING id, merchant_id, trust_score, total_orders, total_sales, completed_orders, total_claims, foreign_object_claims, food_safety_incidents, timeout_count, refuse_order_count, recent_7d_claims, recent_7d_incidents, recent_30d_claims, recent_30d_incidents, recent_30d_timeouts, recent_90d_claims, recent_90d_incidents, is_suspended, suspend_reason, suspended_at, suspend_until, updated_at
`

type CreateMerchantProfileParams struct {
	MerchantID int64 `json:"merchant_id"`
	TrustScore int16 `json:"trust_score"`
}

// ==========================================
// merchant_profiles（商户信任画像）
// ==========================================
func (q *Queries) CreateMerchantProfile(ctx context.Context, arg CreateMerchantProfileParams) (MerchantProfile, error) {
	row := q.db.QueryRow(ctx, createMerchantProfile, arg.MerchantID, arg.TrustScore)
	var i MerchantProfile
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TrustScore,
		&i.TotalOrders,
		&i.TotalSales,
		&i.CompletedOrders,
		&i.TotalClaims,
		&i.ForeignObjectClaims,
		&i.FoodSafetyIncidents,
		&i.TimeoutCount,
		&i.RefuseOrderCount,
		&i.Recent7dClaims,
		&i.Recent7dIncidents,
		&i.Recent30dClaims,
		&i.Recent30dIncidents,
		&i.Recent30dTimeouts,
		&i.Recent90dClaims,
		&i.Recent90dIncidents,
		&i.IsSuspended,
		&i.SuspendReason,
		&i.SuspendedAt,
		&i.SuspendUntil,
		&i.UpdatedAt,
	)
	return i, err
}

const createRiderProfile = `-- name: CreateRiderProfile :one

INSERT INTO rider_profiles (
    rider_id,
    trust_score
) VALUES (
    $1, $2
) RETURNING id, rider_id, trust_score, total_deliveries, completed_deliveries, on_time_deliveries, delayed_deliveries, cancelled_deliveries, total_damage_incidents, customer_complaints, timeout_incidents, recent_7d_damages, recent_7d_delays, recent_30d_damages, recent_30d_delays, recent_30d_complaints, recent_90d_damages, recent_90d_delays, total_online_hours, is_suspended, suspend_reason, suspended_at, suspend_until, updated_at, premium_score
`

type CreateRiderProfileParams struct {
	RiderID    int64 `json:"rider_id"`
	TrustScore int16 `json:"trust_score"`
}

// ==========================================
// rider_profiles（骑手信任画像）
// ==========================================
func (q *Queries) CreateRiderProfile(ctx context.Context, arg CreateRiderProfileParams) (RiderProfile, error) {
	row := q.db.QueryRow(ctx, createRiderProfile, arg.RiderID, arg.TrustScore)
	var i RiderProfile
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TrustScore,
		&i.TotalDeliveries,
		&i.CompletedDeliveries,
		&i.OnTimeDeliveries,
		&i.DelayedDeliveries,
		&i.CancelledDeliveries,
		&i.TotalDamageIncidents,
		&i.CustomerComplaints,
		&i.TimeoutIncidents,
		&i.Recent7dDamages,
		&i.Recent7dDelays,
		&i.Recent30dDamages,
		&i.Recent30dDelays,
		&i.Recent30dComplaints,
		&i.Recent90dDamages,
		&i.Recent90dDelays,
		&i.TotalOnlineHours,
		&i.IsSuspended,
		&i.SuspendReason,
		&i.SuspendedAt,
		&i.SuspendUntil,
		&i.UpdatedAt,
		&i.PremiumScore,
	)
	return i, err
}

const createTrustScoreChange = `-- name: CreateTrustScoreChange :one

INSERT INTO trust_score_changes (
    entity_type,
    entity_id,
    old_score,
    new_score,
    score_change,
    reason_type,
    reason_description,
    related_type,
    related_id,
    is_auto,
    operator_id,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, entity_type, entity_id, old_score, new_score, score_change, reason_type, reason_description, related_type, related_id, is_auto, operator_id, created_at
`

type CreateTrustScoreChangeParams struct {
	EntityType        string      `json:"entity_type"`
	EntityID          int64       `json:"entity_id"`
	OldScore          int16       `json:"old_score"`
	NewScore          int16       `json:"new_score"`
	ScoreChange       int16       `json:"score_change"`
	ReasonType        string      `json:"reason_type"`
	ReasonDescription string      `json:"reason_description"`
	RelatedType       pgtype.Text `json:"related_type"`
	RelatedID         pgtype.Int8 `json:"related_id"`
	IsAuto            bool        `json:"is_auto"`
	OperatorID        pgtype.Int8 `json:"operator_id"`
	CreatedAt         time.Time   `json:"created_at"`
}

// ==========================================
// trust_score_changes（信任分变更日志）
// ==========================================
func (q *Queries) CreateTrustScoreChange(ctx context.Context, arg CreateTrustScoreChangeParams) (TrustScoreChange, error) {
	row := q.db.QueryRow(ctx, createTrustScoreChange,
		arg.EntityType,
		arg.EntityID,
		arg.OldScore,
		arg.NewScore,
		arg.ScoreChange,
		arg.ReasonType,
		arg.ReasonDescription,
		arg.RelatedType,
		arg.RelatedID,
		arg.IsAuto,
		arg.OperatorID,
		arg.CreatedAt,
	)
	var i TrustScoreChange
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.OldScore,
		&i.NewScore,
		&i.ScoreChange,
		&i.ReasonType,
		&i.ReasonDescription,
		&i.RelatedType,
		&i.RelatedID,
		&i.IsAuto,
		&i.OperatorID,
		&i.CreatedAt,
	)
	return i, err
}

const createUserClaimWarning = `-- name: CreateUserClaimWarning :one
INSERT INTO user_claim_warnings (
    user_id,
    warning_count,
    last_warning_at,
    last_warning_reason,
    requires_evidence,
    platform_pay_count,
    created_at,
    updated_at
) VALUES (
    $1, 1, NOW(), $2, $3, 0, NOW(), NOW()
) RETURNING id, user_id, warning_count, last_warning_at, last_warning_reason, requires_evidence, platform_pay_count, created_at, updated_at
`

type CreateUserClaimWarningParams struct {
	UserID            int64       `json:"user_id"`
	LastWarningReason pgtype.Text `json:"last_warning_reason"`
	RequiresEvidence  bool        `json:"requires_evidence"`
}

// 创建用户索赔警告记录
func (q *Queries) CreateUserClaimWarning(ctx context.Context, arg CreateUserClaimWarningParams) (UserClaimWarning, error) {
	row := q.db.QueryRow(ctx, createUserClaimWarning, arg.UserID, arg.LastWarningReason, arg.RequiresEvidence)
	var i UserClaimWarning
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WarningCount,
		&i.LastWarningAt,
		&i.LastWarningReason,
		&i.RequiresEvidence,
		&i.PlatformPayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserProfile = `-- name: CreateUserProfile :one


INSERT INTO user_profiles (
    user_id,
    role,
    trust_score,
    total_orders,
    completed_orders,
    cancelled_orders,
    total_claims,
    malicious_claims,
    food_safety_reports,
    verified_violations,
    recent_7d_claims,
    recent_7d_orders,
    recent_30d_claims,
    recent_30d_orders,
    recent_30d_cancels,
    recent_90d_claims,
    recent_90d_orders,
    is_blacklisted,
    blacklist_reason,
    blacklisted_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
) RETURNING id, user_id, role, trust_score, total_orders, completed_orders, cancelled_orders, total_claims, malicious_claims, food_safety_reports, verified_violations, recent_7d_claims, recent_7d_orders, recent_30d_claims, recent_30d_orders, recent_30d_cancels, recent_90d_claims, recent_90d_orders, is_blacklisted, blacklist_reason, blacklisted_at, updated_at
`

type CreateUserProfileParams struct {
	UserID             int64              `json:"user_id"`
	Role               string             `json:"role"`
	TrustScore         int16              `json:"trust_score"`
	TotalOrders        int32              `json:"total_orders"`
	CompletedOrders    int32              `json:"completed_orders"`
	CancelledOrders    int32              `json:"cancelled_orders"`
	TotalClaims        int32              `json:"total_claims"`
	MaliciousClaims    int32              `json:"malicious_claims"`
	FoodSafetyReports  int32              `json:"food_safety_reports"`
	VerifiedViolations int32              `json:"verified_violations"`
	Recent7dClaims     int32              `json:"recent_7d_claims"`
	Recent7dOrders     int32              `json:"recent_7d_orders"`
	Recent30dClaims    int32              `json:"recent_30d_claims"`
	Recent30dOrders    int32              `json:"recent_30d_orders"`
	Recent30dCancels   int32              `json:"recent_30d_cancels"`
	Recent90dClaims    int32              `json:"recent_90d_claims"`
	Recent90dOrders    int32              `json:"recent_90d_orders"`
	IsBlacklisted      bool               `json:"is_blacklisted"`
	BlacklistReason    pgtype.Text        `json:"blacklist_reason"`
	BlacklistedAt      pgtype.Timestamptz `json:"blacklisted_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
}

// M9: TrustScore信任分系统查询
// 设计理念：信用驱动，非证据驱动
// ==========================================
// user_profiles（顾客信任画像）
// ==========================================
func (q *Queries) CreateUserProfile(ctx context.Context, arg CreateUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, createUserProfile,
		arg.UserID,
		arg.Role,
		arg.TrustScore,
		arg.TotalOrders,
		arg.CompletedOrders,
		arg.CancelledOrders,
		arg.TotalClaims,
		arg.MaliciousClaims,
		arg.FoodSafetyReports,
		arg.VerifiedViolations,
		arg.Recent7dClaims,
		arg.Recent7dOrders,
		arg.Recent30dClaims,
		arg.Recent30dOrders,
		arg.Recent30dCancels,
		arg.Recent90dClaims,
		arg.Recent90dOrders,
		arg.IsBlacklisted,
		arg.BlacklistReason,
		arg.BlacklistedAt,
		arg.UpdatedAt,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Role,
		&i.TrustScore,
		&i.TotalOrders,
		&i.CompletedOrders,
		&i.CancelledOrders,
		&i.TotalClaims,
		&i.MaliciousClaims,
		&i.FoodSafetyReports,
		&i.VerifiedViolations,
		&i.Recent7dClaims,
		&i.Recent7dOrders,
		&i.Recent30dClaims,
		&i.Recent30dOrders,
		&i.Recent30dCancels,
		&i.Recent90dClaims,
		&i.Recent90dOrders,
		&i.IsBlacklisted,
		&i.BlacklistReason,
		&i.BlacklistedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveFoodSafetyIncidents = `-- name: GetActiveFoodSafetyIncidents :many
SELECT id, order_id, merchant_id, user_id, incident_type, description, evidence_urls, order_snapshot, merchant_snapshot, rider_snapshot, status, investigation_report, resolution, created_at, resolved_at FROM food_safety_incidents
WHERE status IN ('reported', 'investigating', 'merchant-suspended')
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetActiveFoodSafetyIncidents(ctx context.Context, limit int32) ([]FoodSafetyIncident, error) {
	rows, err := q.db.Query(ctx, getActiveFoodSafetyIncidents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FoodSafetyIncident{}
	for rows.Next() {
		var i FoodSafetyIncident
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.MerchantID,
			&i.UserID,
			&i.IncidentType,
			&i.Description,
			&i.EvidenceUrls,
			&i.OrderSnapshot,
			&i.MerchantSnapshot,
			&i.RiderSnapshot,
			&i.Status,
			&i.InvestigationReport,
			&i.Resolution,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaim = `-- name: GetClaim :one
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetClaim(ctx context.Context, id int64) (Claim, error) {
	row := q.db.QueryRow(ctx, getClaim, id)
	var i Claim
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
	)
	return i, err
}

const getClaimForUpdate = `-- name: GetClaimForUpdate :one
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE id = $1
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetClaimForUpdate(ctx context.Context, id int64) (Claim, error) {
	row := q.db.QueryRow(ctx, getClaimForUpdate, id)
	var i Claim
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
	)
	return i, err
}

const getClaimWithDetails = `-- name: GetClaimWithDetails :one
SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at,
       o.order_no,
       o.merchant_id,
       o.total_amount as order_amount,
       o.status as order_status,
       o.created_at as order_created_at,
       m.name as merchant_name,
       m.region_id,
       u.phone as user_phone,
       u.full_name as user_name
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN merchants m ON o.merchant_id = m.id
JOIN users u ON c.user_id = u.id
WHERE c.id = $1
LIMIT 1
`

type GetClaimWithDetailsRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	OrderNo            string             `json:"order_no"`
	MerchantID         int64              `json:"merchant_id"`
	OrderAmount        int64              `json:"order_amount"`
	OrderStatus        string             `json:"order_status"`
	OrderCreatedAt     time.Time          `json:"order_created_at"`
	MerchantName       string             `json:"merchant_name"`
	RegionID           int64              `json:"region_id"`
	UserPhone          pgtype.Text        `json:"user_phone"`
	UserName           string             `json:"user_name"`
}

// 获取索赔详情（包含订单、商户、用户信息）
func (q *Queries) GetClaimWithDetails(ctx context.Context, id int64) (GetClaimWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getClaimWithDetails, id)
	var i GetClaimWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.ClaimType,
		&i.Description,
		&i.EvidenceUrls,
		&i.ClaimAmount,
		&i.ApprovedAmount,
		&i.Status,
		&i.ApprovalType,
		&i.TrustScoreSnapshot,
		&i.IsMalicious,
		&i.LookbackResult,
		&i.AutoApprovalReason,
		&i.RejectionReason,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.PaidAt,
		&i.OrderNo,
		&i.MerchantID,
		&i.OrderAmount,
		&i.OrderStatus,
		&i.OrderCreatedAt,
		&i.MerchantName,
		&i.RegionID,
		&i.UserPhone,
		&i.UserName,
	)
	return i, err
}

const getClaimsByFraudPattern = `-- name: GetClaimsByFraudPattern :many

SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at, o.merchant_id, d.rider_id
FROM claims c
JOIN orders o ON c.order_id = o.id
LEFT JOIN deliveries d ON o.id = d.order_id
WHERE c.id = ANY($1::bigint[])
ORDER BY c.created_at
`

type GetClaimsByFraudPatternRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	MerchantID         int64              `json:"merchant_id"`
	RiderID            pgtype.Int8        `json:"rider_id"`
}

// ==========================================
// 欺诈处理：损失返还
// ==========================================
// 获取欺诈模式关联的所有索赔详情
func (q *Queries) GetClaimsByFraudPattern(ctx context.Context, dollar_1 []int64) ([]GetClaimsByFraudPatternRow, error) {
	rows, err := q.db.Query(ctx, getClaimsByFraudPattern, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClaimsByFraudPatternRow{}
	for rows.Next() {
		var i GetClaimsByFraudPatternRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
			&i.MerchantID,
			&i.RiderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimsWithSameAddress = `-- name: GetClaimsWithSameAddress :many
SELECT DISTINCT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at, c.user_id
FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE o.address_id = $1
  AND c.created_at >= $2
  AND c.id != $3
ORDER BY c.created_at DESC
`

type GetClaimsWithSameAddressParams struct {
	AddressID pgtype.Int8 `json:"address_id"`
	CreatedAt time.Time   `json:"created_at"`
	ID        int64       `json:"id"`
}

type GetClaimsWithSameAddressRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	UserID_2           int64              `json:"user_id_2"`
}

// 查询使用相同配送地址的索赔
func (q *Queries) GetClaimsWithSameAddress(ctx context.Context, arg GetClaimsWithSameAddressParams) ([]GetClaimsWithSameAddressRow, error) {
	rows, err := q.db.Query(ctx, getClaimsWithSameAddress, arg.AddressID, arg.CreatedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClaimsWithSameAddressRow{}
	for rows.Next() {
		var i GetClaimsWithSameAddressRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
			&i.UserID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevicesByUserID = `-- name: GetDevicesByUserID :many
SELECT id, user_id, device_id, device_type, device_model, os_version, app_version, user_agent, ip_address, last_login_at, created_at, first_seen, last_seen, updated_at
FROM user_devices
WHERE user_id = $1
ORDER BY last_seen DESC
`

func (q *Queries) GetDevicesByUserID(ctx context.Context, userID int64) ([]UserDevice, error) {
	rows, err := q.db.Query(ctx, getDevicesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserDevice{}
	for rows.Next() {
		var i UserDevice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.DeviceType,
			&i.DeviceModel,
			&i.OsVersion,
			&i.AppVersion,
			&i.UserAgent,
			&i.IpAddress,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.FirstSeen,
			&i.LastSeen,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoodSafetyIncident = `-- name: GetFoodSafetyIncident :one
SELECT id, order_id, merchant_id, user_id, incident_type, description, evidence_urls, order_snapshot, merchant_snapshot, rider_snapshot, status, investigation_report, resolution, created_at, resolved_at FROM food_safety_incidents
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetFoodSafetyIncident(ctx context.Context, id int64) (FoodSafetyIncident, error) {
	row := q.db.QueryRow(ctx, getFoodSafetyIncident, id)
	var i FoodSafetyIncident
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.MerchantID,
		&i.UserID,
		&i.IncidentType,
		&i.Description,
		&i.EvidenceUrls,
		&i.OrderSnapshot,
		&i.MerchantSnapshot,
		&i.RiderSnapshot,
		&i.Status,
		&i.InvestigationReport,
		&i.Resolution,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getFraudPattern = `-- name: GetFraudPattern :one
SELECT id, pattern_type, related_user_ids, related_order_ids, related_claim_ids, device_fingerprints, address_ids, ip_addresses, pattern_description, match_count, is_confirmed, reviewer_id, review_notes, action_taken, detected_at, reviewed_at, confirmed_at FROM fraud_patterns
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetFraudPattern(ctx context.Context, id int64) (FraudPattern, error) {
	row := q.db.QueryRow(ctx, getFraudPattern, id)
	var i FraudPattern
	err := row.Scan(
		&i.ID,
		&i.PatternType,
		&i.RelatedUserIds,
		&i.RelatedOrderIds,
		&i.RelatedClaimIds,
		&i.DeviceFingerprints,
		&i.AddressIds,
		&i.IpAddresses,
		&i.PatternDescription,
		&i.MatchCount,
		&i.IsConfirmed,
		&i.ReviewerID,
		&i.ReviewNotes,
		&i.ActionTaken,
		&i.DetectedAt,
		&i.ReviewedAt,
		&i.ConfirmedAt,
	)
	return i, err
}

const getFraudPatternsByDevice = `-- name: GetFraudPatternsByDevice :many
SELECT id, pattern_type, related_user_ids, related_order_ids, related_claim_ids, device_fingerprints, address_ids, ip_addresses, pattern_description, match_count, is_confirmed, reviewer_id, review_notes, action_taken, detected_at, reviewed_at, confirmed_at FROM fraud_patterns
WHERE device_fingerprints && $1::text[]
  AND detected_at >= $2
ORDER BY detected_at DESC
`

type GetFraudPatternsByDeviceParams struct {
	Column1    []string  `json:"column_1"`
	DetectedAt time.Time `json:"detected_at"`
}

func (q *Queries) GetFraudPatternsByDevice(ctx context.Context, arg GetFraudPatternsByDeviceParams) ([]FraudPattern, error) {
	rows, err := q.db.Query(ctx, getFraudPatternsByDevice, arg.Column1, arg.DetectedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FraudPattern{}
	for rows.Next() {
		var i FraudPattern
		if err := rows.Scan(
			&i.ID,
			&i.PatternType,
			&i.RelatedUserIds,
			&i.RelatedOrderIds,
			&i.RelatedClaimIds,
			&i.DeviceFingerprints,
			&i.AddressIds,
			&i.IpAddresses,
			&i.PatternDescription,
			&i.MatchCount,
			&i.IsConfirmed,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ActionTaken,
			&i.DetectedAt,
			&i.ReviewedAt,
			&i.ConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFraudPatternsByUsers = `-- name: GetFraudPatternsByUsers :many
SELECT id, pattern_type, related_user_ids, related_order_ids, related_claim_ids, device_fingerprints, address_ids, ip_addresses, pattern_description, match_count, is_confirmed, reviewer_id, review_notes, action_taken, detected_at, reviewed_at, confirmed_at FROM fraud_patterns
WHERE related_user_ids && $1::bigint[]
ORDER BY detected_at DESC
`

func (q *Queries) GetFraudPatternsByUsers(ctx context.Context, dollar_1 []int64) ([]FraudPattern, error) {
	rows, err := q.db.Query(ctx, getFraudPatternsByUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FraudPattern{}
	for rows.Next() {
		var i FraudPattern
		if err := rows.Scan(
			&i.ID,
			&i.PatternType,
			&i.RelatedUserIds,
			&i.RelatedOrderIds,
			&i.RelatedClaimIds,
			&i.DeviceFingerprints,
			&i.AddressIds,
			&i.IpAddresses,
			&i.PatternDescription,
			&i.MatchCount,
			&i.IsConfirmed,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ActionTaken,
			&i.DetectedAt,
			&i.ReviewedAt,
			&i.ConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaliciousClaims = `-- name: GetMaliciousClaims :many
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE is_malicious = true
  AND created_at >= $1
ORDER BY created_at DESC
`

func (q *Queries) GetMaliciousClaims(ctx context.Context, createdAt time.Time) ([]Claim, error) {
	rows, err := q.db.Query(ctx, getMaliciousClaims, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantProfile = `-- name: GetMerchantProfile :one
SELECT id, merchant_id, trust_score, total_orders, total_sales, completed_orders, total_claims, foreign_object_claims, food_safety_incidents, timeout_count, refuse_order_count, recent_7d_claims, recent_7d_incidents, recent_30d_claims, recent_30d_incidents, recent_30d_timeouts, recent_90d_claims, recent_90d_incidents, is_suspended, suspend_reason, suspended_at, suspend_until, updated_at FROM merchant_profiles
WHERE merchant_id = $1
LIMIT 1
`

func (q *Queries) GetMerchantProfile(ctx context.Context, merchantID int64) (MerchantProfile, error) {
	row := q.db.QueryRow(ctx, getMerchantProfile, merchantID)
	var i MerchantProfile
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TrustScore,
		&i.TotalOrders,
		&i.TotalSales,
		&i.CompletedOrders,
		&i.TotalClaims,
		&i.ForeignObjectClaims,
		&i.FoodSafetyIncidents,
		&i.TimeoutCount,
		&i.RefuseOrderCount,
		&i.Recent7dClaims,
		&i.Recent7dIncidents,
		&i.Recent30dClaims,
		&i.Recent30dIncidents,
		&i.Recent30dTimeouts,
		&i.Recent90dClaims,
		&i.Recent90dIncidents,
		&i.IsSuspended,
		&i.SuspendReason,
		&i.SuspendedAt,
		&i.SuspendUntil,
		&i.UpdatedAt,
	)
	return i, err
}

const getMerchantProfileForUpdate = `-- name: GetMerchantProfileForUpdate :one
SELECT id, merchant_id, trust_score, total_orders, total_sales, completed_orders, total_claims, foreign_object_claims, food_safety_incidents, timeout_count, refuse_order_count, recent_7d_claims, recent_7d_incidents, recent_30d_claims, recent_30d_incidents, recent_30d_timeouts, recent_90d_claims, recent_90d_incidents, is_suspended, suspend_reason, suspended_at, suspend_until, updated_at FROM merchant_profiles
WHERE merchant_id = $1
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetMerchantProfileForUpdate(ctx context.Context, merchantID int64) (MerchantProfile, error) {
	row := q.db.QueryRow(ctx, getMerchantProfileForUpdate, merchantID)
	var i MerchantProfile
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.TrustScore,
		&i.TotalOrders,
		&i.TotalSales,
		&i.CompletedOrders,
		&i.TotalClaims,
		&i.ForeignObjectClaims,
		&i.FoodSafetyIncidents,
		&i.TimeoutCount,
		&i.RefuseOrderCount,
		&i.Recent7dClaims,
		&i.Recent7dIncidents,
		&i.Recent30dClaims,
		&i.Recent30dIncidents,
		&i.Recent30dTimeouts,
		&i.Recent90dClaims,
		&i.Recent90dIncidents,
		&i.IsSuspended,
		&i.SuspendReason,
		&i.SuspendedAt,
		&i.SuspendUntil,
		&i.UpdatedAt,
	)
	return i, err
}

const getMerchantRecentFoodSafetyReports = `-- name: GetMerchantRecentFoodSafetyReports :many
SELECT id, order_id, merchant_id, user_id, incident_type, description, evidence_urls, order_snapshot, merchant_snapshot, rider_snapshot, status, investigation_report, resolution, created_at, resolved_at FROM food_safety_incidents
WHERE merchant_id = $1
  AND created_at >= NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC
`

func (q *Queries) GetMerchantRecentFoodSafetyReports(ctx context.Context, merchantID int64) ([]FoodSafetyIncident, error) {
	rows, err := q.db.Query(ctx, getMerchantRecentFoodSafetyReports, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FoodSafetyIncident{}
	for rows.Next() {
		var i FoodSafetyIncident
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.MerchantID,
			&i.UserID,
			&i.IncidentType,
			&i.Description,
			&i.EvidenceUrls,
			&i.OrderSnapshot,
			&i.MerchantSnapshot,
			&i.RiderSnapshot,
			&i.Status,
			&i.InvestigationReport,
			&i.Resolution,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersMerchantAndRider = `-- name: GetOrdersMerchantAndRider :many

SELECT o.id as order_id, o.merchant_id, d.rider_id
FROM orders o
LEFT JOIN deliveries d ON o.id = d.order_id
WHERE o.id = ANY($1::bigint[])
`

type GetOrdersMerchantAndRiderRow struct {
	OrderID    int64       `json:"order_id"`
	MerchantID int64       `json:"merchant_id"`
	RiderID    pgtype.Int8 `json:"rider_id"`
}

// ==========================================
// 回溯检查专用查询
// ==========================================
func (q *Queries) GetOrdersMerchantAndRider(ctx context.Context, dollar_1 []int64) ([]GetOrdersMerchantAndRiderRow, error) {
	rows, err := q.db.Query(ctx, getOrdersMerchantAndRider, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersMerchantAndRiderRow{}
	for rows.Next() {
		var i GetOrdersMerchantAndRiderRow
		if err := rows.Scan(&i.OrderID, &i.MerchantID, &i.RiderID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingClaims = `-- name: GetPendingClaims :many
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingClaims(ctx context.Context, limit int32) ([]Claim, error) {
	rows, err := q.db.Query(ctx, getPendingClaims, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTrustScoreChanges = `-- name: GetRecentTrustScoreChanges :many
SELECT id, entity_type, entity_id, old_score, new_score, score_change, reason_type, reason_description, related_type, related_id, is_auto, operator_id, created_at FROM trust_score_changes
WHERE entity_type = $1 AND entity_id = $2
  AND created_at >= $3
ORDER BY created_at DESC
`

type GetRecentTrustScoreChangesParams struct {
	EntityType string    `json:"entity_type"`
	EntityID   int64     `json:"entity_id"`
	CreatedAt  time.Time `json:"created_at"`
}

func (q *Queries) GetRecentTrustScoreChanges(ctx context.Context, arg GetRecentTrustScoreChangesParams) ([]TrustScoreChange, error) {
	rows, err := q.db.Query(ctx, getRecentTrustScoreChanges, arg.EntityType, arg.EntityID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrustScoreChange{}
	for rows.Next() {
		var i TrustScoreChange
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.OldScore,
			&i.NewScore,
			&i.ScoreChange,
			&i.ReasonType,
			&i.ReasonDescription,
			&i.RelatedType,
			&i.RelatedID,
			&i.IsAuto,
			&i.OperatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRiderDeliveryStats = `-- name: GetRiderDeliveryStats :one
SELECT 
    COUNT(*) as total_orders,
    COUNT(*) FILTER (WHERE status = 'delivered') as completed_orders,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_orders,
    COUNT(*) FILTER (WHERE is_delayed = true) as timeout_orders
FROM deliveries
WHERE rider_id = $1
  AND created_at >= $2
`

type GetRiderDeliveryStatsParams struct {
	RiderID   pgtype.Int8 `json:"rider_id"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetRiderDeliveryStatsRow struct {
	TotalOrders     int64 `json:"total_orders"`
	CompletedOrders int64 `json:"completed_orders"`
	CancelledOrders int64 `json:"cancelled_orders"`
	TimeoutOrders   int64 `json:"timeout_orders"`
}

// 获取骑手在指定时间窗口内的配送统计
func (q *Queries) GetRiderDeliveryStats(ctx context.Context, arg GetRiderDeliveryStatsParams) (GetRiderDeliveryStatsRow, error) {
	row := q.db.QueryRow(ctx, getRiderDeliveryStats, arg.RiderID, arg.CreatedAt)
	var i GetRiderDeliveryStatsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.CompletedOrders,
		&i.CancelledOrders,
		&i.TimeoutOrders,
	)
	return i, err
}

const getRiderProfile = `-- name: GetRiderProfile :one
SELECT id, rider_id, trust_score, total_deliveries, completed_deliveries, on_time_deliveries, delayed_deliveries, cancelled_deliveries, total_damage_incidents, customer_complaints, timeout_incidents, recent_7d_damages, recent_7d_delays, recent_30d_damages, recent_30d_delays, recent_30d_complaints, recent_90d_damages, recent_90d_delays, total_online_hours, is_suspended, suspend_reason, suspended_at, suspend_until, updated_at, premium_score FROM rider_profiles
WHERE rider_id = $1
LIMIT 1
`

func (q *Queries) GetRiderProfile(ctx context.Context, riderID int64) (RiderProfile, error) {
	row := q.db.QueryRow(ctx, getRiderProfile, riderID)
	var i RiderProfile
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TrustScore,
		&i.TotalDeliveries,
		&i.CompletedDeliveries,
		&i.OnTimeDeliveries,
		&i.DelayedDeliveries,
		&i.CancelledDeliveries,
		&i.TotalDamageIncidents,
		&i.CustomerComplaints,
		&i.TimeoutIncidents,
		&i.Recent7dDamages,
		&i.Recent7dDelays,
		&i.Recent30dDamages,
		&i.Recent30dDelays,
		&i.Recent30dComplaints,
		&i.Recent90dDamages,
		&i.Recent90dDelays,
		&i.TotalOnlineHours,
		&i.IsSuspended,
		&i.SuspendReason,
		&i.SuspendedAt,
		&i.SuspendUntil,
		&i.UpdatedAt,
		&i.PremiumScore,
	)
	return i, err
}

const getRiderProfileForUpdate = `-- name: GetRiderProfileForUpdate :one
SELECT id, rider_id, trust_score, total_deliveries, completed_deliveries, on_time_deliveries, delayed_deliveries, cancelled_deliveries, total_damage_incidents, customer_complaints, timeout_incidents, recent_7d_damages, recent_7d_delays, recent_30d_damages, recent_30d_delays, recent_30d_complaints, recent_90d_damages, recent_90d_delays, total_online_hours, is_suspended, suspend_reason, suspended_at, suspend_until, updated_at, premium_score FROM rider_profiles
WHERE rider_id = $1
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetRiderProfileForUpdate(ctx context.Context, riderID int64) (RiderProfile, error) {
	row := q.db.QueryRow(ctx, getRiderProfileForUpdate, riderID)
	var i RiderProfile
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TrustScore,
		&i.TotalDeliveries,
		&i.CompletedDeliveries,
		&i.OnTimeDeliveries,
		&i.DelayedDeliveries,
		&i.CancelledDeliveries,
		&i.TotalDamageIncidents,
		&i.CustomerComplaints,
		&i.TimeoutIncidents,
		&i.Recent7dDamages,
		&i.Recent7dDelays,
		&i.Recent30dDamages,
		&i.Recent30dDelays,
		&i.Recent30dComplaints,
		&i.Recent90dDamages,
		&i.Recent90dDelays,
		&i.TotalOnlineHours,
		&i.IsSuspended,
		&i.SuspendReason,
		&i.SuspendedAt,
		&i.SuspendUntil,
		&i.UpdatedAt,
		&i.PremiumScore,
	)
	return i, err
}

const getTotalScoreChangeByReason = `-- name: GetTotalScoreChangeByReason :one
SELECT COALESCE(SUM(score_change), 0) as total_change
FROM trust_score_changes
WHERE entity_type = $1 AND entity_id = $2
  AND reason_type = $3
`

type GetTotalScoreChangeByReasonParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	ReasonType string `json:"reason_type"`
}

func (q *Queries) GetTotalScoreChangeByReason(ctx context.Context, arg GetTotalScoreChangeByReasonParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTotalScoreChangeByReason, arg.EntityType, arg.EntityID, arg.ReasonType)
	var total_change interface{}
	err := row.Scan(&total_change)
	return total_change, err
}

const getTrustScoreChange = `-- name: GetTrustScoreChange :one
SELECT id, entity_type, entity_id, old_score, new_score, score_change, reason_type, reason_description, related_type, related_id, is_auto, operator_id, created_at FROM trust_score_changes
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTrustScoreChange(ctx context.Context, id int64) (TrustScoreChange, error) {
	row := q.db.QueryRow(ctx, getTrustScoreChange, id)
	var i TrustScoreChange
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.OldScore,
		&i.NewScore,
		&i.ScoreChange,
		&i.ReasonType,
		&i.ReasonDescription,
		&i.RelatedType,
		&i.RelatedID,
		&i.IsAuto,
		&i.OperatorID,
		&i.CreatedAt,
	)
	return i, err
}

const getTrustScoreChangesByReason = `-- name: GetTrustScoreChangesByReason :many
SELECT id, entity_type, entity_id, old_score, new_score, score_change, reason_type, reason_description, related_type, related_id, is_auto, operator_id, created_at FROM trust_score_changes
WHERE entity_type = $1 AND entity_id = $2
  AND reason_type = $3
ORDER BY created_at DESC
LIMIT $4
`

type GetTrustScoreChangesByReasonParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	ReasonType string `json:"reason_type"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) GetTrustScoreChangesByReason(ctx context.Context, arg GetTrustScoreChangesByReasonParams) ([]TrustScoreChange, error) {
	rows, err := q.db.Query(ctx, getTrustScoreChangesByReason,
		arg.EntityType,
		arg.EntityID,
		arg.ReasonType,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrustScoreChange{}
	for rows.Next() {
		var i TrustScoreChange
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.OldScore,
			&i.NewScore,
			&i.ScoreChange,
			&i.ReasonType,
			&i.ReasonDescription,
			&i.RelatedType,
			&i.RelatedID,
			&i.IsAuto,
			&i.OperatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnconfirmedFraudPatterns = `-- name: GetUnconfirmedFraudPatterns :many
SELECT id, pattern_type, related_user_ids, related_order_ids, related_claim_ids, device_fingerprints, address_ids, ip_addresses, pattern_description, match_count, is_confirmed, reviewer_id, review_notes, action_taken, detected_at, reviewed_at, confirmed_at FROM fraud_patterns
WHERE is_confirmed = false
ORDER BY match_count DESC, detected_at DESC
LIMIT $1
`

func (q *Queries) GetUnconfirmedFraudPatterns(ctx context.Context, limit int32) ([]FraudPattern, error) {
	rows, err := q.db.Query(ctx, getUnconfirmedFraudPatterns, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FraudPattern{}
	for rows.Next() {
		var i FraudPattern
		if err := rows.Scan(
			&i.ID,
			&i.PatternType,
			&i.RelatedUserIds,
			&i.RelatedOrderIds,
			&i.RelatedClaimIds,
			&i.DeviceFingerprints,
			&i.AddressIds,
			&i.IpAddresses,
			&i.PatternDescription,
			&i.MatchCount,
			&i.IsConfirmed,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ActionTaken,
			&i.DetectedAt,
			&i.ReviewedAt,
			&i.ConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBehaviorStats = `-- name: GetUserBehaviorStats :one
SELECT 
    (SELECT COUNT(*) FROM orders o WHERE o.user_id = $1 AND o.order_type = 'takeout' 
     AND o.created_at >= NOW() - INTERVAL '90 days')::INT as takeout_orders_90d,
    (SELECT COUNT(*) FROM claims c WHERE c.user_id = $1 
     AND c.created_at >= NOW() - INTERVAL '90 days')::INT as claims_90d,
    COALESCE(w.warning_count, 0)::INT as warning_count,
    COALESCE(w.requires_evidence, false) as requires_evidence,
    COALESCE(w.platform_pay_count, 0)::INT as platform_pay_count
FROM (SELECT 1) as dummy
LEFT JOIN user_claim_warnings w ON w.user_id = $1
`

type GetUserBehaviorStatsRow struct {
	TakeoutOrders90d int32 `json:"takeout_orders_90d"`
	Claims90d        int32 `json:"claims_90d"`
	WarningCount     int32 `json:"warning_count"`
	RequiresEvidence bool  `json:"requires_evidence"`
	PlatformPayCount int32 `json:"platform_pay_count"`
}

// 获取用户行为统计（用于索赔判定）
func (q *Queries) GetUserBehaviorStats(ctx context.Context, userID int64) (GetUserBehaviorStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserBehaviorStats, userID)
	var i GetUserBehaviorStatsRow
	err := row.Scan(
		&i.TakeoutOrders90d,
		&i.Claims90d,
		&i.WarningCount,
		&i.RequiresEvidence,
		&i.PlatformPayCount,
	)
	return i, err
}

const getUserClaimWarningStatus = `-- name: GetUserClaimWarningStatus :one
SELECT id, user_id, warning_count, last_warning_at, last_warning_reason, requires_evidence, platform_pay_count, created_at, updated_at FROM user_claim_warnings
WHERE user_id = $1
LIMIT 1
`

// 获取用户索赔警告状态
func (q *Queries) GetUserClaimWarningStatus(ctx context.Context, userID int64) (UserClaimWarning, error) {
	row := q.db.QueryRow(ctx, getUserClaimWarningStatus, userID)
	var i UserClaimWarning
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WarningCount,
		&i.LastWarningAt,
		&i.LastWarningReason,
		&i.RequiresEvidence,
		&i.PlatformPayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT id, user_id, role, trust_score, total_orders, completed_orders, cancelled_orders, total_claims, malicious_claims, food_safety_reports, verified_violations, recent_7d_claims, recent_7d_orders, recent_30d_claims, recent_30d_orders, recent_30d_cancels, recent_90d_claims, recent_90d_orders, is_blacklisted, blacklist_reason, blacklisted_at, updated_at FROM user_profiles
WHERE user_id = $1 AND role = $2
LIMIT 1
`

type GetUserProfileParams struct {
	UserID int64  `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) GetUserProfile(ctx context.Context, arg GetUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, getUserProfile, arg.UserID, arg.Role)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Role,
		&i.TrustScore,
		&i.TotalOrders,
		&i.CompletedOrders,
		&i.CancelledOrders,
		&i.TotalClaims,
		&i.MaliciousClaims,
		&i.FoodSafetyReports,
		&i.VerifiedViolations,
		&i.Recent7dClaims,
		&i.Recent7dOrders,
		&i.Recent30dClaims,
		&i.Recent30dOrders,
		&i.Recent30dCancels,
		&i.Recent90dClaims,
		&i.Recent90dOrders,
		&i.IsBlacklisted,
		&i.BlacklistReason,
		&i.BlacklistedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserProfileForUpdate = `-- name: GetUserProfileForUpdate :one
SELECT id, user_id, role, trust_score, total_orders, completed_orders, cancelled_orders, total_claims, malicious_claims, food_safety_reports, verified_violations, recent_7d_claims, recent_7d_orders, recent_30d_claims, recent_30d_orders, recent_30d_cancels, recent_90d_claims, recent_90d_orders, is_blacklisted, blacklist_reason, blacklisted_at, updated_at FROM user_profiles
WHERE user_id = $1 AND role = $2
LIMIT 1
FOR UPDATE
`

type GetUserProfileForUpdateParams struct {
	UserID int64  `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) GetUserProfileForUpdate(ctx context.Context, arg GetUserProfileForUpdateParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, getUserProfileForUpdate, arg.UserID, arg.Role)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Role,
		&i.TrustScore,
		&i.TotalOrders,
		&i.CompletedOrders,
		&i.CancelledOrders,
		&i.TotalClaims,
		&i.MaliciousClaims,
		&i.FoodSafetyReports,
		&i.VerifiedViolations,
		&i.Recent7dClaims,
		&i.Recent7dOrders,
		&i.Recent30dClaims,
		&i.Recent30dOrders,
		&i.Recent30dCancels,
		&i.Recent90dClaims,
		&i.Recent90dOrders,
		&i.IsBlacklisted,
		&i.BlacklistReason,
		&i.BlacklistedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRecentClaims = `-- name: GetUserRecentClaims :many
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE user_id = $1
  AND created_at >= NOW() - INTERVAL '30 days'
ORDER BY created_at DESC
LIMIT 5
`

func (q *Queries) GetUserRecentClaims(ctx context.Context, userID int64) ([]Claim, error) {
	rows, err := q.db.Query(ctx, getUserRecentClaims, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByAddressID = `-- name: GetUsersByAddressID :many

SELECT DISTINCT o.user_id, COUNT(DISTINCT o.id) as order_count
FROM orders o
INNER JOIN user_addresses ua ON o.address_id = ua.id
WHERE ua.id = $1
GROUP BY o.user_id
ORDER BY order_count DESC
`

type GetUsersByAddressIDRow struct {
	UserID     int64 `json:"user_id"`
	OrderCount int64 `json:"order_count"`
}

// ==========================================
// 地址聚类查询（M9欺诈检测）
// ==========================================
// 查询使用相同地址ID的用户
func (q *Queries) GetUsersByAddressID(ctx context.Context, id int64) ([]GetUsersByAddressIDRow, error) {
	rows, err := q.db.Query(ctx, getUsersByAddressID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByAddressIDRow{}
	for rows.Next() {
		var i GetUsersByAddressIDRow
		if err := rows.Scan(&i.UserID, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByDeviceID = `-- name: GetUsersByDeviceID :many
SELECT DISTINCT user_id
FROM user_devices
WHERE device_id = $1
ORDER BY last_seen DESC
`

func (q *Queries) GetUsersByDeviceID(ctx context.Context, deviceID string) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersByDeviceID, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersBySimilarAddress = `-- name: GetUsersBySimilarAddress :many
SELECT DISTINCT ua.user_id, ua.id as address_id, ua.detail_address, COUNT(o.id) as order_count
FROM user_addresses ua
LEFT JOIN orders o ON o.address_id = ua.id
WHERE ua.region_id = $1
  AND ua.detail_address LIKE '%' || $2 || '%'
  AND ua.user_id != $3  -- 排除当前用户
GROUP BY ua.user_id, ua.id, ua.detail_address
HAVING COUNT(o.id) > 0
ORDER BY order_count DESC
LIMIT 50
`

type GetUsersBySimilarAddressParams struct {
	RegionID int64       `json:"region_id"`
	Column2  pgtype.Text `json:"column_2"`
	UserID   int64       `json:"user_id"`
}

type GetUsersBySimilarAddressRow struct {
	UserID        int64  `json:"user_id"`
	AddressID     int64  `json:"address_id"`
	DetailAddress string `json:"detail_address"`
	OrderCount    int64  `json:"order_count"`
}

// 查询地址高度相似的用户（基于region_id和详细地址模糊匹配）
func (q *Queries) GetUsersBySimilarAddress(ctx context.Context, arg GetUsersBySimilarAddressParams) ([]GetUsersBySimilarAddressRow, error) {
	rows, err := q.db.Query(ctx, getUsersBySimilarAddress, arg.RegionID, arg.Column2, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersBySimilarAddressRow{}
	for rows.Next() {
		var i GetUsersBySimilarAddressRow
		if err := rows.Scan(
			&i.UserID,
			&i.AddressID,
			&i.DetailAddress,
			&i.OrderCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRecentClaims = `-- name: GetUsersWithRecentClaims :many
SELECT DISTINCT c.user_id
FROM claims c
WHERE c.user_id = ANY($1::bigint[])
  AND c.created_at >= NOW() - INTERVAL '1 day' * $2
ORDER BY c.created_at DESC
`

type GetUsersWithRecentClaimsParams struct {
	Column1 []int64     `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

// 查询最近N天内有索赔记录的用户（设备欺诈检测）
func (q *Queries) GetUsersWithRecentClaims(ctx context.Context, arg GetUsersWithRecentClaimsParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersWithRecentClaims, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementMerchantForeignObjectClaim = `-- name: IncrementMerchantForeignObjectClaim :exec
UPDATE merchant_profiles
SET foreign_object_claims = foreign_object_claims + 1,
    total_claims = total_claims + 1,
    recent_7d_claims = recent_7d_claims + 1,
    recent_30d_claims = recent_30d_claims + 1,
    recent_90d_claims = recent_90d_claims + 1,
    updated_at = NOW()
WHERE merchant_id = $1
`

func (q *Queries) IncrementMerchantForeignObjectClaim(ctx context.Context, merchantID int64) error {
	_, err := q.db.Exec(ctx, incrementMerchantForeignObjectClaim, merchantID)
	return err
}

const incrementRiderDamageIncident = `-- name: IncrementRiderDamageIncident :exec
UPDATE rider_profiles
SET total_damage_incidents = total_damage_incidents + 1,
    recent_7d_damages = recent_7d_damages + 1,
    recent_30d_damages = recent_30d_damages + 1,
    recent_90d_damages = recent_90d_damages + 1,
    updated_at = NOW()
WHERE rider_id = $1
`

func (q *Queries) IncrementRiderDamageIncident(ctx context.Context, riderID int64) error {
	_, err := q.db.Exec(ctx, incrementRiderDamageIncident, riderID)
	return err
}

const incrementUserClaimCount = `-- name: IncrementUserClaimCount :exec
UPDATE user_profiles
SET total_claims = total_claims + 1,
    recent_7d_claims = recent_7d_claims + 1,
    recent_30d_claims = recent_30d_claims + 1,
    recent_90d_claims = recent_90d_claims + 1,
    updated_at = NOW()
WHERE user_id = $1 AND role = $2
`

type IncrementUserClaimCountParams struct {
	UserID int64  `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) IncrementUserClaimCount(ctx context.Context, arg IncrementUserClaimCountParams) error {
	_, err := q.db.Exec(ctx, incrementUserClaimCount, arg.UserID, arg.Role)
	return err
}

const incrementUserClaimWarning = `-- name: IncrementUserClaimWarning :exec
UPDATE user_claim_warnings
SET warning_count = warning_count + 1,
    last_warning_at = NOW(),
    last_warning_reason = $2,
    requires_evidence = $3,
    updated_at = NOW()
WHERE user_id = $1
`

type IncrementUserClaimWarningParams struct {
	UserID            int64       `json:"user_id"`
	LastWarningReason pgtype.Text `json:"last_warning_reason"`
	RequiresEvidence  bool        `json:"requires_evidence"`
}

// 增加用户警告次数
func (q *Queries) IncrementUserClaimWarning(ctx context.Context, arg IncrementUserClaimWarningParams) error {
	_, err := q.db.Exec(ctx, incrementUserClaimWarning, arg.UserID, arg.LastWarningReason, arg.RequiresEvidence)
	return err
}

const incrementUserPlatformPayCount = `-- name: IncrementUserPlatformPayCount :exec
UPDATE user_claim_warnings
SET platform_pay_count = platform_pay_count + 1,
    last_warning_at = NOW(),
    last_warning_reason = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type IncrementUserPlatformPayCountParams struct {
	UserID            int64       `json:"user_id"`
	LastWarningReason pgtype.Text `json:"last_warning_reason"`
}

// 增加平台垫付次数
func (q *Queries) IncrementUserPlatformPayCount(ctx context.Context, arg IncrementUserPlatformPayCountParams) error {
	_, err := q.db.Exec(ctx, incrementUserPlatformPayCount, arg.UserID, arg.LastWarningReason)
	return err
}

const listClaimsByTimeWindow = `-- name: ListClaimsByTimeWindow :many

SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at, o.address_id
FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE c.created_at >= $1
  AND c.created_at <= $2
  AND c.id != $3  -- 排除当前索赔
ORDER BY c.created_at DESC
`

type ListClaimsByTimeWindowParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	ID          int64     `json:"id"`
}

type ListClaimsByTimeWindowRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	AddressID          pgtype.Int8        `json:"address_id"`
}

// ==========================================
// 欺诈检测：时间窗口查询
// ==========================================
// 查询指定时间窗口内的索赔（用于协同欺诈检测）
func (q *Queries) ListClaimsByTimeWindow(ctx context.Context, arg ListClaimsByTimeWindowParams) ([]ListClaimsByTimeWindowRow, error) {
	rows, err := q.db.Query(ctx, listClaimsByTimeWindow, arg.CreatedAt, arg.CreatedAt_2, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListClaimsByTimeWindowRow{}
	for rows.Next() {
		var i ListClaimsByTimeWindowRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
			&i.AddressID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntityTrustScoreChanges = `-- name: ListEntityTrustScoreChanges :many
SELECT id, entity_type, entity_id, old_score, new_score, score_change, reason_type, reason_description, related_type, related_id, is_auto, operator_id, created_at FROM trust_score_changes
WHERE entity_type = $1 AND entity_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListEntityTrustScoreChangesParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListEntityTrustScoreChanges(ctx context.Context, arg ListEntityTrustScoreChangesParams) ([]TrustScoreChange, error) {
	rows, err := q.db.Query(ctx, listEntityTrustScoreChanges,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrustScoreChange{}
	for rows.Next() {
		var i TrustScoreChange
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.OldScore,
			&i.NewScore,
			&i.ScoreChange,
			&i.ReasonType,
			&i.ReasonDescription,
			&i.RelatedType,
			&i.RelatedID,
			&i.IsAuto,
			&i.OperatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFraudPatterns = `-- name: ListFraudPatterns :many
SELECT id, pattern_type, related_user_ids, related_order_ids, related_claim_ids, device_fingerprints, address_ids, ip_addresses, pattern_description, match_count, is_confirmed, reviewer_id, review_notes, action_taken, detected_at, reviewed_at, confirmed_at FROM fraud_patterns
WHERE pattern_type = $3
  AND detected_at >= $4
ORDER BY detected_at DESC
LIMIT $1 OFFSET $2
`

type ListFraudPatternsParams struct {
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
	PatternType pgtype.Text        `json:"pattern_type"`
	FromDate    pgtype.Timestamptz `json:"from_date"`
}

func (q *Queries) ListFraudPatterns(ctx context.Context, arg ListFraudPatternsParams) ([]FraudPattern, error) {
	rows, err := q.db.Query(ctx, listFraudPatterns,
		arg.Limit,
		arg.Offset,
		arg.PatternType,
		arg.FromDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FraudPattern{}
	for rows.Next() {
		var i FraudPattern
		if err := rows.Scan(
			&i.ID,
			&i.PatternType,
			&i.RelatedUserIds,
			&i.RelatedOrderIds,
			&i.RelatedClaimIds,
			&i.DeviceFingerprints,
			&i.AddressIds,
			&i.IpAddresses,
			&i.PatternDescription,
			&i.MatchCount,
			&i.IsConfirmed,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.ActionTaken,
			&i.DetectedAt,
			&i.ReviewedAt,
			&i.ConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantClaims = `-- name: ListMerchantClaims :many
SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE o.merchant_id = $1
  AND c.created_at >= $2
ORDER BY c.created_at DESC
`

type ListMerchantClaimsParams struct {
	MerchantID int64     `json:"merchant_id"`
	CreatedAt  time.Time `json:"created_at"`
}

func (q *Queries) ListMerchantClaims(ctx context.Context, arg ListMerchantClaimsParams) ([]Claim, error) {
	rows, err := q.db.Query(ctx, listMerchantClaims, arg.MerchantID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantClaimsByTypeInPeriod = `-- name: ListMerchantClaimsByTypeInPeriod :many
SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at
FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE o.merchant_id = $1
  AND c.claim_type = $2
  AND c.created_at >= $3
ORDER BY c.created_at DESC
`

type ListMerchantClaimsByTypeInPeriodParams struct {
	MerchantID int64     `json:"merchant_id"`
	ClaimType  string    `json:"claim_type"`
	CreatedAt  time.Time `json:"created_at"`
}

// 获取商户在指定时间窗口内特定类型的索赔列表
func (q *Queries) ListMerchantClaimsByTypeInPeriod(ctx context.Context, arg ListMerchantClaimsByTypeInPeriodParams) ([]Claim, error) {
	rows, err := q.db.Query(ctx, listMerchantClaimsByTypeInPeriod, arg.MerchantID, arg.ClaimType, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantFoodSafetyIncidents = `-- name: ListMerchantFoodSafetyIncidents :many
SELECT id, order_id, merchant_id, user_id, incident_type, description, evidence_urls, order_snapshot, merchant_snapshot, rider_snapshot, status, investigation_report, resolution, created_at, resolved_at FROM food_safety_incidents
WHERE merchant_id = $1
  AND created_at >= $2
ORDER BY created_at DESC
`

type ListMerchantFoodSafetyIncidentsParams struct {
	MerchantID int64     `json:"merchant_id"`
	CreatedAt  time.Time `json:"created_at"`
}

func (q *Queries) ListMerchantFoodSafetyIncidents(ctx context.Context, arg ListMerchantFoodSafetyIncidentsParams) ([]FoodSafetyIncident, error) {
	rows, err := q.db.Query(ctx, listMerchantFoodSafetyIncidents, arg.MerchantID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FoodSafetyIncident{}
	for rows.Next() {
		var i FoodSafetyIncident
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.MerchantID,
			&i.UserID,
			&i.IncidentType,
			&i.Description,
			&i.EvidenceUrls,
			&i.OrderSnapshot,
			&i.MerchantSnapshot,
			&i.RiderSnapshot,
			&i.Status,
			&i.InvestigationReport,
			&i.Resolution,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegionPendingClaims = `-- name: ListRegionPendingClaims :many

SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at, 
       o.order_no,
       o.merchant_id,
       m.name as merchant_name,
       u.phone as user_phone,
       m.region_id
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN merchants m ON o.merchant_id = m.id
JOIN users u ON c.user_id = u.id
WHERE m.region_id = $1
  AND c.status = 'manual-review'
ORDER BY c.created_at ASC
LIMIT $2 OFFSET $3
`

type ListRegionPendingClaimsParams struct {
	RegionID int64 `json:"region_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListRegionPendingClaimsRow struct {
	ID                 int64              `json:"id"`
	OrderID            int64              `json:"order_id"`
	UserID             int64              `json:"user_id"`
	ClaimType          string             `json:"claim_type"`
	Description        string             `json:"description"`
	EvidenceUrls       []string           `json:"evidence_urls"`
	ClaimAmount        int64              `json:"claim_amount"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	TrustScoreSnapshot pgtype.Int2        `json:"trust_score_snapshot"`
	IsMalicious        bool               `json:"is_malicious"`
	LookbackResult     []byte             `json:"lookback_result"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	CreatedAt          time.Time          `json:"created_at"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	OrderNo            string             `json:"order_no"`
	MerchantID         int64              `json:"merchant_id"`
	MerchantName       string             `json:"merchant_name"`
	UserPhone          pgtype.Text        `json:"user_phone"`
	RegionID           int64              `json:"region_id"`
}

// ==========================================
// 运营商索赔管理（区域内待审核索赔）
// ==========================================
// 获取运营商区域内待人工审核的索赔列表
func (q *Queries) ListRegionPendingClaims(ctx context.Context, arg ListRegionPendingClaimsParams) ([]ListRegionPendingClaimsRow, error) {
	rows, err := q.db.Query(ctx, listRegionPendingClaims, arg.RegionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRegionPendingClaimsRow{}
	for rows.Next() {
		var i ListRegionPendingClaimsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
			&i.OrderNo,
			&i.MerchantID,
			&i.MerchantName,
			&i.UserPhone,
			&i.RegionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderClaims = `-- name: ListRiderClaims :many
SELECT c.id, c.order_id, c.user_id, c.claim_type, c.description, c.evidence_urls, c.claim_amount, c.approved_amount, c.status, c.approval_type, c.trust_score_snapshot, c.is_malicious, c.lookback_result, c.auto_approval_reason, c.rejection_reason, c.reviewer_id, c.review_notes, c.created_at, c.reviewed_at, c.paid_at FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN deliveries d ON o.id = d.order_id
WHERE d.rider_id = $1
  AND c.created_at >= $2
ORDER BY c.created_at DESC
`

type ListRiderClaimsParams struct {
	RiderID   pgtype.Int8 `json:"rider_id"`
	CreatedAt time.Time   `json:"created_at"`
}

func (q *Queries) ListRiderClaims(ctx context.Context, arg ListRiderClaimsParams) ([]Claim, error) {
	rows, err := q.db.Query(ctx, listRiderClaims, arg.RiderID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserClaims = `-- name: ListUserClaims :many
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserClaimsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserClaims(ctx context.Context, arg ListUserClaimsParams) ([]Claim, error) {
	rows, err := q.db.Query(ctx, listUserClaims, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserClaimsInPeriod = `-- name: ListUserClaimsInPeriod :many
SELECT id, order_id, user_id, claim_type, description, evidence_urls, claim_amount, approved_amount, status, approval_type, trust_score_snapshot, is_malicious, lookback_result, auto_approval_reason, rejection_reason, reviewer_id, review_notes, created_at, reviewed_at, paid_at FROM claims
WHERE user_id = $1
  AND created_at >= $2
ORDER BY created_at DESC
`

type ListUserClaimsInPeriodParams struct {
	UserID    int64     `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) ListUserClaimsInPeriod(ctx context.Context, arg ListUserClaimsInPeriodParams) ([]Claim, error) {
	rows, err := q.db.Query(ctx, listUserClaimsInPeriod, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Claim{}
	for rows.Next() {
		var i Claim
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.ClaimType,
			&i.Description,
			&i.EvidenceUrls,
			&i.ClaimAmount,
			&i.ApprovedAmount,
			&i.Status,
			&i.ApprovalType,
			&i.TrustScoreSnapshot,
			&i.IsMalicious,
			&i.LookbackResult,
			&i.AutoApprovalReason,
			&i.RejectionReason,
			&i.ReviewerID,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRecentOrders = `-- name: ListUserRecentOrders :many
SELECT id, address_id
FROM orders
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListUserRecentOrdersParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type ListUserRecentOrdersRow struct {
	ID        int64       `json:"id"`
	AddressID pgtype.Int8 `json:"address_id"`
}

// 获取用户最近的订单（用于食安恶作剧检测）
func (q *Queries) ListUserRecentOrders(ctx context.Context, arg ListUserRecentOrdersParams) ([]ListUserRecentOrdersRow, error) {
	rows, err := q.db.Query(ctx, listUserRecentOrders, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserRecentOrdersRow{}
	for rows.Next() {
		var i ListUserRecentOrdersRow
		if err := rows.Scan(&i.ID, &i.AddressID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reviewClaim = `-- name: ReviewClaim :exec
UPDATE claims
SET status = $2,
    approved_amount = $3,
    reviewer_id = $4,
    review_notes = $5,
    reviewed_at = NOW()
WHERE id = $1
`

type ReviewClaimParams struct {
	ID             int64       `json:"id"`
	Status         string      `json:"status"`
	ApprovedAmount pgtype.Int8 `json:"approved_amount"`
	ReviewerID     pgtype.Int8 `json:"reviewer_id"`
	ReviewNotes    pgtype.Text `json:"review_notes"`
}

// 运营商审核索赔
func (q *Queries) ReviewClaim(ctx context.Context, arg ReviewClaimParams) error {
	_, err := q.db.Exec(ctx, reviewClaim,
		arg.ID,
		arg.Status,
		arg.ApprovedAmount,
		arg.ReviewerID,
		arg.ReviewNotes,
	)
	return err
}

const setUserRequiresEvidence = `-- name: SetUserRequiresEvidence :exec
UPDATE user_claim_warnings
SET requires_evidence = true,
    last_warning_reason = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type SetUserRequiresEvidenceParams struct {
	UserID            int64       `json:"user_id"`
	LastWarningReason pgtype.Text `json:"last_warning_reason"`
}

// 设置用户需要提交证据
func (q *Queries) SetUserRequiresEvidence(ctx context.Context, arg SetUserRequiresEvidenceParams) error {
	_, err := q.db.Exec(ctx, setUserRequiresEvidence, arg.UserID, arg.LastWarningReason)
	return err
}

const sumClaimAmountsByMerchant = `-- name: SumClaimAmountsByMerchant :many
SELECT o.merchant_id, SUM(c.approved_amount)::bigint as total_loss
FROM claims c
JOIN orders o ON c.order_id = o.id
WHERE c.id = ANY($1::bigint[])
  AND c.approved_amount IS NOT NULL
GROUP BY o.merchant_id
`

type SumClaimAmountsByMerchantRow struct {
	MerchantID int64 `json:"merchant_id"`
	TotalLoss  int64 `json:"total_loss"`
}

// 按商户统计索赔损失金额
func (q *Queries) SumClaimAmountsByMerchant(ctx context.Context, dollar_1 []int64) ([]SumClaimAmountsByMerchantRow, error) {
	rows, err := q.db.Query(ctx, sumClaimAmountsByMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumClaimAmountsByMerchantRow{}
	for rows.Next() {
		var i SumClaimAmountsByMerchantRow
		if err := rows.Scan(&i.MerchantID, &i.TotalLoss); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumClaimAmountsByRider = `-- name: SumClaimAmountsByRider :many
SELECT d.rider_id, SUM(c.approved_amount)::bigint as total_loss
FROM claims c
JOIN orders o ON c.order_id = o.id
JOIN deliveries d ON o.id = d.order_id
WHERE c.id = ANY($1::bigint[])
  AND c.claim_type = 'damage'
  AND c.approved_amount IS NOT NULL
  AND d.rider_id IS NOT NULL
GROUP BY d.rider_id
`

type SumClaimAmountsByRiderRow struct {
	RiderID   pgtype.Int8 `json:"rider_id"`
	TotalLoss int64       `json:"total_loss"`
}

// 按骑手统计索赔损失金额（餐损类型）
func (q *Queries) SumClaimAmountsByRider(ctx context.Context, dollar_1 []int64) ([]SumClaimAmountsByRiderRow, error) {
	rows, err := q.db.Query(ctx, sumClaimAmountsByRider, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumClaimAmountsByRiderRow{}
	for rows.Next() {
		var i SumClaimAmountsByRiderRow
		if err := rows.Scan(&i.RiderID, &i.TotalLoss); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const suspendMerchant = `-- name: SuspendMerchant :exec
UPDATE merchant_profiles
SET is_suspended = true,
    suspend_reason = $2,
    suspended_at = NOW(),
    suspend_until = $3,
    updated_at = NOW()
WHERE merchant_id = $1
`

type SuspendMerchantParams struct {
	MerchantID    int64              `json:"merchant_id"`
	SuspendReason pgtype.Text        `json:"suspend_reason"`
	SuspendUntil  pgtype.Timestamptz `json:"suspend_until"`
}

func (q *Queries) SuspendMerchant(ctx context.Context, arg SuspendMerchantParams) error {
	_, err := q.db.Exec(ctx, suspendMerchant, arg.MerchantID, arg.SuspendReason, arg.SuspendUntil)
	return err
}

const suspendRider = `-- name: SuspendRider :exec
UPDATE rider_profiles
SET is_suspended = true,
    suspend_reason = $2,
    suspended_at = NOW(),
    suspend_until = $3,
    updated_at = NOW()
WHERE rider_id = $1
`

type SuspendRiderParams struct {
	RiderID       int64              `json:"rider_id"`
	SuspendReason pgtype.Text        `json:"suspend_reason"`
	SuspendUntil  pgtype.Timestamptz `json:"suspend_until"`
}

func (q *Queries) SuspendRider(ctx context.Context, arg SuspendRiderParams) error {
	_, err := q.db.Exec(ctx, suspendRider, arg.RiderID, arg.SuspendReason, arg.SuspendUntil)
	return err
}

const unblacklistUser = `-- name: UnblacklistUser :exec
UPDATE user_profiles
SET is_blacklisted = false,
    blacklist_reason = NULL,
    blacklisted_at = NULL,
    updated_at = NOW()
WHERE user_id = $1 AND role = $2
`

type UnblacklistUserParams struct {
	UserID int64  `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) UnblacklistUser(ctx context.Context, arg UnblacklistUserParams) error {
	_, err := q.db.Exec(ctx, unblacklistUser, arg.UserID, arg.Role)
	return err
}

const unsuspendMerchant = `-- name: UnsuspendMerchant :exec
UPDATE merchant_profiles
SET is_suspended = false,
    suspend_reason = NULL,
    suspended_at = NULL,
    suspend_until = NULL,
    updated_at = NOW()
WHERE merchant_id = $1
`

func (q *Queries) UnsuspendMerchant(ctx context.Context, merchantID int64) error {
	_, err := q.db.Exec(ctx, unsuspendMerchant, merchantID)
	return err
}

const unsuspendRider = `-- name: UnsuspendRider :exec
UPDATE rider_profiles
SET is_suspended = false,
    suspend_reason = NULL,
    suspended_at = NULL,
    suspend_until = NULL,
    updated_at = NOW()
WHERE rider_id = $1
`

func (q *Queries) UnsuspendRider(ctx context.Context, riderID int64) error {
	_, err := q.db.Exec(ctx, unsuspendRider, riderID)
	return err
}

const updateClaimLookbackResult = `-- name: UpdateClaimLookbackResult :exec
UPDATE claims
SET lookback_result = $2
WHERE id = $1
`

type UpdateClaimLookbackResultParams struct {
	ID             int64  `json:"id"`
	LookbackResult []byte `json:"lookback_result"`
}

func (q *Queries) UpdateClaimLookbackResult(ctx context.Context, arg UpdateClaimLookbackResultParams) error {
	_, err := q.db.Exec(ctx, updateClaimLookbackResult, arg.ID, arg.LookbackResult)
	return err
}

const updateClaimStatus = `-- name: UpdateClaimStatus :exec
UPDATE claims
SET status = $2,
    approval_type = COALESCE($3, approval_type),
    approved_amount = COALESCE($4, approved_amount),
    is_malicious = COALESCE($5, is_malicious),
    auto_approval_reason = COALESCE($6, auto_approval_reason),
    rejection_reason = COALESCE($7, rejection_reason),
    reviewer_id = COALESCE($8, reviewer_id),
    review_notes = COALESCE($9, review_notes),
    reviewed_at = COALESCE($10, reviewed_at),
    paid_at = COALESCE($11, paid_at)
WHERE id = $1
`

type UpdateClaimStatusParams struct {
	ID                 int64              `json:"id"`
	Status             string             `json:"status"`
	ApprovalType       pgtype.Text        `json:"approval_type"`
	ApprovedAmount     pgtype.Int8        `json:"approved_amount"`
	IsMalicious        pgtype.Bool        `json:"is_malicious"`
	AutoApprovalReason pgtype.Text        `json:"auto_approval_reason"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	ReviewerID         pgtype.Int8        `json:"reviewer_id"`
	ReviewNotes        pgtype.Text        `json:"review_notes"`
	ReviewedAt         pgtype.Timestamptz `json:"reviewed_at"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
}

func (q *Queries) UpdateClaimStatus(ctx context.Context, arg UpdateClaimStatusParams) error {
	_, err := q.db.Exec(ctx, updateClaimStatus,
		arg.ID,
		arg.Status,
		arg.ApprovalType,
		arg.ApprovedAmount,
		arg.IsMalicious,
		arg.AutoApprovalReason,
		arg.RejectionReason,
		arg.ReviewerID,
		arg.ReviewNotes,
		arg.ReviewedAt,
		arg.PaidAt,
	)
	return err
}

const updateFoodSafetyIncidentStatus = `-- name: UpdateFoodSafetyIncidentStatus :exec
UPDATE food_safety_incidents
SET status = $2,
    investigation_report = COALESCE($3, investigation_report),
    resolution = COALESCE($4, resolution),
    resolved_at = COALESCE($5, resolved_at)
WHERE id = $1
`

type UpdateFoodSafetyIncidentStatusParams struct {
	ID                  int64              `json:"id"`
	Status              string             `json:"status"`
	InvestigationReport pgtype.Text        `json:"investigation_report"`
	Resolution          pgtype.Text        `json:"resolution"`
	ResolvedAt          pgtype.Timestamptz `json:"resolved_at"`
}

func (q *Queries) UpdateFoodSafetyIncidentStatus(ctx context.Context, arg UpdateFoodSafetyIncidentStatusParams) error {
	_, err := q.db.Exec(ctx, updateFoodSafetyIncidentStatus,
		arg.ID,
		arg.Status,
		arg.InvestigationReport,
		arg.Resolution,
		arg.ResolvedAt,
	)
	return err
}

const updateFraudPatternReview = `-- name: UpdateFraudPatternReview :exec
UPDATE fraud_patterns
SET reviewer_id = $2,
    review_notes = $3,
    reviewed_at = NOW()
WHERE id = $1
`

type UpdateFraudPatternReviewParams struct {
	ID          int64       `json:"id"`
	ReviewerID  pgtype.Int8 `json:"reviewer_id"`
	ReviewNotes pgtype.Text `json:"review_notes"`
}

func (q *Queries) UpdateFraudPatternReview(ctx context.Context, arg UpdateFraudPatternReviewParams) error {
	_, err := q.db.Exec(ctx, updateFraudPatternReview, arg.ID, arg.ReviewerID, arg.ReviewNotes)
	return err
}

const updateMerchantProfile = `-- name: UpdateMerchantProfile :exec
UPDATE merchant_profiles
SET trust_score = COALESCE($2, trust_score),
    total_orders = COALESCE($3, total_orders),
    total_sales = COALESCE($4, total_sales),
    completed_orders = COALESCE($5, completed_orders),
    total_claims = COALESCE($6, total_claims),
    foreign_object_claims = COALESCE($7, foreign_object_claims),
    food_safety_incidents = COALESCE($8, food_safety_incidents),
    timeout_count = COALESCE($9, timeout_count),
    refuse_order_count = COALESCE($10, refuse_order_count),
    recent_7d_claims = COALESCE($11, recent_7d_claims),
    recent_7d_incidents = COALESCE($12, recent_7d_incidents),
    recent_30d_claims = COALESCE($13, recent_30d_claims),
    recent_30d_incidents = COALESCE($14, recent_30d_incidents),
    recent_30d_timeouts = COALESCE($15, recent_30d_timeouts),
    recent_90d_claims = COALESCE($16, recent_90d_claims),
    recent_90d_incidents = COALESCE($17, recent_90d_incidents),
    is_suspended = COALESCE($18, is_suspended),
    suspend_reason = COALESCE($19, suspend_reason),
    suspended_at = COALESCE($20, suspended_at),
    suspend_until = COALESCE($21, suspend_until),
    updated_at = NOW()
WHERE merchant_id = $1
`

type UpdateMerchantProfileParams struct {
	MerchantID          int64              `json:"merchant_id"`
	TrustScore          pgtype.Int2        `json:"trust_score"`
	TotalOrders         pgtype.Int4        `json:"total_orders"`
	TotalSales          pgtype.Int8        `json:"total_sales"`
	CompletedOrders     pgtype.Int4        `json:"completed_orders"`
	TotalClaims         pgtype.Int4        `json:"total_claims"`
	ForeignObjectClaims pgtype.Int4        `json:"foreign_object_claims"`
	FoodSafetyIncidents pgtype.Int4        `json:"food_safety_incidents"`
	TimeoutCount        pgtype.Int4        `json:"timeout_count"`
	RefuseOrderCount    pgtype.Int4        `json:"refuse_order_count"`
	Recent7dClaims      pgtype.Int4        `json:"recent_7d_claims"`
	Recent7dIncidents   pgtype.Int4        `json:"recent_7d_incidents"`
	Recent30dClaims     pgtype.Int4        `json:"recent_30d_claims"`
	Recent30dIncidents  pgtype.Int4        `json:"recent_30d_incidents"`
	Recent30dTimeouts   pgtype.Int4        `json:"recent_30d_timeouts"`
	Recent90dClaims     pgtype.Int4        `json:"recent_90d_claims"`
	Recent90dIncidents  pgtype.Int4        `json:"recent_90d_incidents"`
	IsSuspended         pgtype.Bool        `json:"is_suspended"`
	SuspendReason       pgtype.Text        `json:"suspend_reason"`
	SuspendedAt         pgtype.Timestamptz `json:"suspended_at"`
	SuspendUntil        pgtype.Timestamptz `json:"suspend_until"`
}

func (q *Queries) UpdateMerchantProfile(ctx context.Context, arg UpdateMerchantProfileParams) error {
	_, err := q.db.Exec(ctx, updateMerchantProfile,
		arg.MerchantID,
		arg.TrustScore,
		arg.TotalOrders,
		arg.TotalSales,
		arg.CompletedOrders,
		arg.TotalClaims,
		arg.ForeignObjectClaims,
		arg.FoodSafetyIncidents,
		arg.TimeoutCount,
		arg.RefuseOrderCount,
		arg.Recent7dClaims,
		arg.Recent7dIncidents,
		arg.Recent30dClaims,
		arg.Recent30dIncidents,
		arg.Recent30dTimeouts,
		arg.Recent90dClaims,
		arg.Recent90dIncidents,
		arg.IsSuspended,
		arg.SuspendReason,
		arg.SuspendedAt,
		arg.SuspendUntil,
	)
	return err
}

const updateMerchantTrustScore = `-- name: UpdateMerchantTrustScore :exec
UPDATE merchant_profiles
SET trust_score = $2,
    updated_at = NOW()
WHERE merchant_id = $1
`

type UpdateMerchantTrustScoreParams struct {
	MerchantID int64 `json:"merchant_id"`
	TrustScore int16 `json:"trust_score"`
}

func (q *Queries) UpdateMerchantTrustScore(ctx context.Context, arg UpdateMerchantTrustScoreParams) error {
	_, err := q.db.Exec(ctx, updateMerchantTrustScore, arg.MerchantID, arg.TrustScore)
	return err
}

const updateRiderProfile = `-- name: UpdateRiderProfile :exec
UPDATE rider_profiles
SET trust_score = COALESCE($2, trust_score),
    total_deliveries = COALESCE($3, total_deliveries),
    completed_deliveries = COALESCE($4, completed_deliveries),
    on_time_deliveries = COALESCE($5, on_time_deliveries),
    delayed_deliveries = COALESCE($6, delayed_deliveries),
    cancelled_deliveries = COALESCE($7, cancelled_deliveries),
    total_damage_incidents = COALESCE($8, total_damage_incidents),
    customer_complaints = COALESCE($9, customer_complaints),
    timeout_incidents = COALESCE($10, timeout_incidents),
    recent_7d_damages = COALESCE($11, recent_7d_damages),
    recent_7d_delays = COALESCE($12, recent_7d_delays),
    recent_30d_damages = COALESCE($13, recent_30d_damages),
    recent_30d_delays = COALESCE($14, recent_30d_delays),
    recent_30d_complaints = COALESCE($15, recent_30d_complaints),
    recent_90d_damages = COALESCE($16, recent_90d_damages),
    recent_90d_delays = COALESCE($17, recent_90d_delays),
    total_online_hours = COALESCE($18, total_online_hours),
    is_suspended = COALESCE($19, is_suspended),
    suspend_reason = COALESCE($20, suspend_reason),
    suspended_at = COALESCE($21, suspended_at),
    suspend_until = COALESCE($22, suspend_until),
    updated_at = NOW()
WHERE rider_id = $1
`

type UpdateRiderProfileParams struct {
	RiderID              int64              `json:"rider_id"`
	TrustScore           pgtype.Int2        `json:"trust_score"`
	TotalDeliveries      pgtype.Int4        `json:"total_deliveries"`
	CompletedDeliveries  pgtype.Int4        `json:"completed_deliveries"`
	OnTimeDeliveries     pgtype.Int4        `json:"on_time_deliveries"`
	DelayedDeliveries    pgtype.Int4        `json:"delayed_deliveries"`
	CancelledDeliveries  pgtype.Int4        `json:"cancelled_deliveries"`
	TotalDamageIncidents pgtype.Int4        `json:"total_damage_incidents"`
	CustomerComplaints   pgtype.Int4        `json:"customer_complaints"`
	TimeoutIncidents     pgtype.Int4        `json:"timeout_incidents"`
	Recent7dDamages      pgtype.Int4        `json:"recent_7d_damages"`
	Recent7dDelays       pgtype.Int4        `json:"recent_7d_delays"`
	Recent30dDamages     pgtype.Int4        `json:"recent_30d_damages"`
	Recent30dDelays      pgtype.Int4        `json:"recent_30d_delays"`
	Recent30dComplaints  pgtype.Int4        `json:"recent_30d_complaints"`
	Recent90dDamages     pgtype.Int4        `json:"recent_90d_damages"`
	Recent90dDelays      pgtype.Int4        `json:"recent_90d_delays"`
	TotalOnlineHours     pgtype.Int4        `json:"total_online_hours"`
	IsSuspended          pgtype.Bool        `json:"is_suspended"`
	SuspendReason        pgtype.Text        `json:"suspend_reason"`
	SuspendedAt          pgtype.Timestamptz `json:"suspended_at"`
	SuspendUntil         pgtype.Timestamptz `json:"suspend_until"`
}

func (q *Queries) UpdateRiderProfile(ctx context.Context, arg UpdateRiderProfileParams) error {
	_, err := q.db.Exec(ctx, updateRiderProfile,
		arg.RiderID,
		arg.TrustScore,
		arg.TotalDeliveries,
		arg.CompletedDeliveries,
		arg.OnTimeDeliveries,
		arg.DelayedDeliveries,
		arg.CancelledDeliveries,
		arg.TotalDamageIncidents,
		arg.CustomerComplaints,
		arg.TimeoutIncidents,
		arg.Recent7dDamages,
		arg.Recent7dDelays,
		arg.Recent30dDamages,
		arg.Recent30dDelays,
		arg.Recent30dComplaints,
		arg.Recent90dDamages,
		arg.Recent90dDelays,
		arg.TotalOnlineHours,
		arg.IsSuspended,
		arg.SuspendReason,
		arg.SuspendedAt,
		arg.SuspendUntil,
	)
	return err
}

const updateRiderTrustScore = `-- name: UpdateRiderTrustScore :exec
UPDATE rider_profiles
SET trust_score = $2,
    updated_at = NOW()
WHERE rider_id = $1
`

type UpdateRiderTrustScoreParams struct {
	RiderID    int64 `json:"rider_id"`
	TrustScore int16 `json:"trust_score"`
}

func (q *Queries) UpdateRiderTrustScore(ctx context.Context, arg UpdateRiderTrustScoreParams) error {
	_, err := q.db.Exec(ctx, updateRiderTrustScore, arg.RiderID, arg.TrustScore)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE user_profiles
SET trust_score = COALESCE($3, trust_score),
    total_orders = COALESCE($4, total_orders),
    completed_orders = COALESCE($5, completed_orders),
    cancelled_orders = COALESCE($6, cancelled_orders),
    total_claims = COALESCE($7, total_claims),
    malicious_claims = COALESCE($8, malicious_claims),
    food_safety_reports = COALESCE($9, food_safety_reports),
    verified_violations = COALESCE($10, verified_violations),
    recent_7d_claims = COALESCE($11, recent_7d_claims),
    recent_7d_orders = COALESCE($12, recent_7d_orders),
    recent_30d_claims = COALESCE($13, recent_30d_claims),
    recent_30d_orders = COALESCE($14, recent_30d_orders),
    recent_30d_cancels = COALESCE($15, recent_30d_cancels),
    recent_90d_claims = COALESCE($16, recent_90d_claims),
    recent_90d_orders = COALESCE($17, recent_90d_orders),
    is_blacklisted = COALESCE($18, is_blacklisted),
    blacklist_reason = COALESCE($19, blacklist_reason),
    blacklisted_at = COALESCE($20, blacklisted_at),
    updated_at = NOW()
WHERE user_id = $1 AND role = $2
`

type UpdateUserProfileParams struct {
	UserID             int64              `json:"user_id"`
	Role               string             `json:"role"`
	TrustScore         pgtype.Int2        `json:"trust_score"`
	TotalOrders        pgtype.Int4        `json:"total_orders"`
	CompletedOrders    pgtype.Int4        `json:"completed_orders"`
	CancelledOrders    pgtype.Int4        `json:"cancelled_orders"`
	TotalClaims        pgtype.Int4        `json:"total_claims"`
	MaliciousClaims    pgtype.Int4        `json:"malicious_claims"`
	FoodSafetyReports  pgtype.Int4        `json:"food_safety_reports"`
	VerifiedViolations pgtype.Int4        `json:"verified_violations"`
	Recent7dClaims     pgtype.Int4        `json:"recent_7d_claims"`
	Recent7dOrders     pgtype.Int4        `json:"recent_7d_orders"`
	Recent30dClaims    pgtype.Int4        `json:"recent_30d_claims"`
	Recent30dOrders    pgtype.Int4        `json:"recent_30d_orders"`
	Recent30dCancels   pgtype.Int4        `json:"recent_30d_cancels"`
	Recent90dClaims    pgtype.Int4        `json:"recent_90d_claims"`
	Recent90dOrders    pgtype.Int4        `json:"recent_90d_orders"`
	IsBlacklisted      pgtype.Bool        `json:"is_blacklisted"`
	BlacklistReason    pgtype.Text        `json:"blacklist_reason"`
	BlacklistedAt      pgtype.Timestamptz `json:"blacklisted_at"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile,
		arg.UserID,
		arg.Role,
		arg.TrustScore,
		arg.TotalOrders,
		arg.CompletedOrders,
		arg.CancelledOrders,
		arg.TotalClaims,
		arg.MaliciousClaims,
		arg.FoodSafetyReports,
		arg.VerifiedViolations,
		arg.Recent7dClaims,
		arg.Recent7dOrders,
		arg.Recent30dClaims,
		arg.Recent30dOrders,
		arg.Recent30dCancels,
		arg.Recent90dClaims,
		arg.Recent90dOrders,
		arg.IsBlacklisted,
		arg.BlacklistReason,
		arg.BlacklistedAt,
	)
	return err
}

const updateUserTrustScore = `-- name: UpdateUserTrustScore :exec
UPDATE user_profiles
SET trust_score = $3,
    updated_at = NOW()
WHERE user_id = $1 AND role = $2
`

type UpdateUserTrustScoreParams struct {
	UserID     int64  `json:"user_id"`
	Role       string `json:"role"`
	TrustScore int16  `json:"trust_score"`
}

func (q *Queries) UpdateUserTrustScore(ctx context.Context, arg UpdateUserTrustScoreParams) error {
	_, err := q.db.Exec(ctx, updateUserTrustScore, arg.UserID, arg.Role, arg.TrustScore)
	return err
}

const upsertUserDevice = `-- name: UpsertUserDevice :one

INSERT INTO user_devices (
    user_id,
    device_id,
    device_type,
    first_seen,
    last_seen
) VALUES (
    $1, $2, $3, NOW(), NOW()
) ON CONFLICT (user_id, device_id)
DO UPDATE SET
    last_seen = NOW(),
    updated_at = NOW()
RETURNING id, user_id, device_id, device_type, device_model, os_version, app_version, user_agent, ip_address, last_login_at, created_at, first_seen, last_seen, updated_at
`

type UpsertUserDeviceParams struct {
	UserID     int64  `json:"user_id"`
	DeviceID   string `json:"device_id"`
	DeviceType string `json:"device_type"`
}

// ==========================================
// 设备指纹查询（M9欺诈检测）
// ==========================================
func (q *Queries) UpsertUserDevice(ctx context.Context, arg UpsertUserDeviceParams) (UserDevice, error) {
	row := q.db.QueryRow(ctx, upsertUserDevice, arg.UserID, arg.DeviceID, arg.DeviceType)
	var i UserDevice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsVersion,
		&i.AppVersion,
		&i.UserAgent,
		&i.IpAddress,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.FirstSeen,
		&i.LastSeen,
		&i.UpdatedAt,
	)
	return i, err
}
