// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: voucher.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserVoucherExists = `-- name: CheckUserVoucherExists :one
SELECT COUNT(*) > 0 as exists
FROM user_vouchers
WHERE voucher_id = $1 AND user_id = $2
`

type CheckUserVoucherExistsParams struct {
	VoucherID int64 `json:"voucher_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) CheckUserVoucherExists(ctx context.Context, arg CheckUserVoucherExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserVoucherExists, arg.VoucherID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countUnusedVouchersByVoucherID = `-- name: CountUnusedVouchersByVoucherID :one
SELECT COUNT(*) FROM user_vouchers
WHERE voucher_id = $1 AND status = 'unused' AND expires_at > NOW()
`

func (q *Queries) CountUnusedVouchersByVoucherID(ctx context.Context, voucherID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnusedVouchersByVoucherID, voucherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserVouchersByStatus = `-- name: CountUserVouchersByStatus :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'unused' AND expires_at > NOW()) as available_count,
    COUNT(*) FILTER (WHERE status = 'used') as used_count,
    COUNT(*) FILTER (WHERE status = 'expired' OR (status = 'unused' AND expires_at <= NOW())) as expired_count
FROM user_vouchers
WHERE user_id = $1
`

type CountUserVouchersByStatusRow struct {
	AvailableCount int64 `json:"available_count"`
	UsedCount      int64 `json:"used_count"`
	ExpiredCount   int64 `json:"expired_count"`
}

func (q *Queries) CountUserVouchersByStatus(ctx context.Context, userID int64) (CountUserVouchersByStatusRow, error) {
	row := q.db.QueryRow(ctx, countUserVouchersByStatus, userID)
	var i CountUserVouchersByStatusRow
	err := row.Scan(&i.AvailableCount, &i.UsedCount, &i.ExpiredCount)
	return i, err
}

const createUserVoucher = `-- name: CreateUserVoucher :one

INSERT INTO user_vouchers (
    voucher_id,
    user_id,
    expires_at
) VALUES (
    $1, $2, $3
) RETURNING id, voucher_id, user_id, status, order_id, used_at, obtained_at, expires_at
`

type CreateUserVoucherParams struct {
	VoucherID int64     `json:"voucher_id"`
	UserID    int64     `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

// User Vouchers (用户已领取的代金券)
func (q *Queries) CreateUserVoucher(ctx context.Context, arg CreateUserVoucherParams) (UserVoucher, error) {
	row := q.db.QueryRow(ctx, createUserVoucher, arg.VoucherID, arg.UserID, arg.ExpiresAt)
	var i UserVoucher
	err := row.Scan(
		&i.ID,
		&i.VoucherID,
		&i.UserID,
		&i.Status,
		&i.OrderID,
		&i.UsedAt,
		&i.ObtainedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createVoucher = `-- name: CreateVoucher :one

INSERT INTO vouchers (
    merchant_id,
    code,
    name,
    description,
    amount,
    min_order_amount,
    total_quantity,
    valid_from,
    valid_until,
    is_active,
    allowed_order_types
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at
`

type CreateVoucherParams struct {
	MerchantID        int64       `json:"merchant_id"`
	Code              string      `json:"code"`
	Name              string      `json:"name"`
	Description       pgtype.Text `json:"description"`
	Amount            int64       `json:"amount"`
	MinOrderAmount    int64       `json:"min_order_amount"`
	TotalQuantity     int32       `json:"total_quantity"`
	ValidFrom         time.Time   `json:"valid_from"`
	ValidUntil        time.Time   `json:"valid_until"`
	IsActive          bool        `json:"is_active"`
	AllowedOrderTypes []string    `json:"allowed_order_types"`
}

// Vouchers (代金券模板)
func (q *Queries) CreateVoucher(ctx context.Context, arg CreateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, createVoucher,
		arg.MerchantID,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.Amount,
		arg.MinOrderAmount,
		arg.TotalQuantity,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
		arg.AllowedOrderTypes,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}

const deleteVoucher = `-- name: DeleteVoucher :exec
UPDATE vouchers SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

// 软删除代金券模板
func (q *Queries) DeleteVoucher(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteVoucher, id)
	return err
}

const getUserVoucher = `-- name: GetUserVoucher :one
SELECT uv.id, uv.voucher_id, uv.user_id, uv.status, uv.order_id, uv.used_at, uv.obtained_at, uv.expires_at, v.merchant_id, v.code, v.name, v.amount, v.min_order_amount, v.allowed_order_types
FROM user_vouchers uv
JOIN vouchers v ON v.id = uv.voucher_id
WHERE uv.id = $1 LIMIT 1
`

type GetUserVoucherRow struct {
	ID                int64              `json:"id"`
	VoucherID         int64              `json:"voucher_id"`
	UserID            int64              `json:"user_id"`
	Status            string             `json:"status"`
	OrderID           pgtype.Int8        `json:"order_id"`
	UsedAt            pgtype.Timestamptz `json:"used_at"`
	ObtainedAt        time.Time          `json:"obtained_at"`
	ExpiresAt         time.Time          `json:"expires_at"`
	MerchantID        int64              `json:"merchant_id"`
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Amount            int64              `json:"amount"`
	MinOrderAmount    int64              `json:"min_order_amount"`
	AllowedOrderTypes []string           `json:"allowed_order_types"`
}

func (q *Queries) GetUserVoucher(ctx context.Context, id int64) (GetUserVoucherRow, error) {
	row := q.db.QueryRow(ctx, getUserVoucher, id)
	var i GetUserVoucherRow
	err := row.Scan(
		&i.ID,
		&i.VoucherID,
		&i.UserID,
		&i.Status,
		&i.OrderID,
		&i.UsedAt,
		&i.ObtainedAt,
		&i.ExpiresAt,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Amount,
		&i.MinOrderAmount,
		&i.AllowedOrderTypes,
	)
	return i, err
}

const getUserVoucherForUpdate = `-- name: GetUserVoucherForUpdate :one
SELECT id, voucher_id, user_id, status, order_id, used_at, obtained_at, expires_at FROM user_vouchers
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetUserVoucherForUpdate(ctx context.Context, id int64) (UserVoucher, error) {
	row := q.db.QueryRow(ctx, getUserVoucherForUpdate, id)
	var i UserVoucher
	err := row.Scan(
		&i.ID,
		&i.VoucherID,
		&i.UserID,
		&i.Status,
		&i.OrderID,
		&i.UsedAt,
		&i.ObtainedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getVoucher = `-- name: GetVoucher :one
SELECT id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at FROM vouchers
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetVoucher(ctx context.Context, id int64) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucher, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}

const getVoucherByCode = `-- name: GetVoucherByCode :one
SELECT id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at FROM vouchers
WHERE code = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetVoucherByCode(ctx context.Context, code string) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucherByCode, code)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}

const getVoucherForUpdate = `-- name: GetVoucherForUpdate :one
SELECT id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at FROM vouchers
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
FOR UPDATE
`

func (q *Queries) GetVoucherForUpdate(ctx context.Context, id int64) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucherForUpdate, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}

const getVoucherUsageStats = `-- name: GetVoucherUsageStats :one
SELECT 
    v.total_quantity,
    v.claimed_quantity,
    v.used_quantity,
    COUNT(CASE WHEN uv.status = 'unused' AND uv.expires_at > NOW() THEN 1 END) as active_count,
    COUNT(CASE WHEN uv.status = 'used' THEN 1 END) as used_count_verified,
    COUNT(CASE WHEN uv.status = 'expired' OR (uv.status = 'unused' AND uv.expires_at <= NOW()) THEN 1 END) as expired_count
FROM vouchers v
LEFT JOIN user_vouchers uv ON uv.voucher_id = v.id
WHERE v.id = $1
GROUP BY v.id, v.total_quantity, v.claimed_quantity, v.used_quantity
`

type GetVoucherUsageStatsRow struct {
	TotalQuantity     int32 `json:"total_quantity"`
	ClaimedQuantity   int32 `json:"claimed_quantity"`
	UsedQuantity      int32 `json:"used_quantity"`
	ActiveCount       int64 `json:"active_count"`
	UsedCountVerified int64 `json:"used_count_verified"`
	ExpiredCount      int64 `json:"expired_count"`
}

func (q *Queries) GetVoucherUsageStats(ctx context.Context, id int64) (GetVoucherUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, getVoucherUsageStats, id)
	var i GetVoucherUsageStatsRow
	err := row.Scan(
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ActiveCount,
		&i.UsedCountVerified,
		&i.ExpiredCount,
	)
	return i, err
}

const incrementVoucherClaimedQuantity = `-- name: IncrementVoucherClaimedQuantity :one
UPDATE vouchers
SET 
    claimed_quantity = claimed_quantity + 1,
    updated_at = NOW()
WHERE id = $1 
    AND claimed_quantity < total_quantity
RETURNING id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at
`

func (q *Queries) IncrementVoucherClaimedQuantity(ctx context.Context, id int64) (Voucher, error) {
	row := q.db.QueryRow(ctx, incrementVoucherClaimedQuantity, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}

const incrementVoucherUsedQuantity = `-- name: IncrementVoucherUsedQuantity :one
UPDATE vouchers
SET 
    used_quantity = used_quantity + 1,
    updated_at = NOW()
WHERE id = $1
RETURNING id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at
`

func (q *Queries) IncrementVoucherUsedQuantity(ctx context.Context, id int64) (Voucher, error) {
	row := q.db.QueryRow(ctx, incrementVoucherUsedQuantity, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveVouchers = `-- name: ListActiveVouchers :many
SELECT id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at FROM vouchers
WHERE merchant_id = $1 
    AND deleted_at IS NULL
    AND is_active = TRUE
    AND valid_from <= NOW()
    AND valid_until >= NOW()
    AND claimed_quantity < total_quantity
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActiveVouchersParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListActiveVouchers(ctx context.Context, arg ListActiveVouchersParams) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, listActiveVouchers, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.MinOrderAmount,
			&i.TotalQuantity,
			&i.ClaimedQuantity,
			&i.UsedQuantity,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AllowedOrderTypes,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMerchantVouchers = `-- name: ListMerchantVouchers :many
SELECT id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at FROM vouchers
WHERE merchant_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMerchantVouchersParams struct {
	MerchantID int64 `json:"merchant_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListMerchantVouchers(ctx context.Context, arg ListMerchantVouchersParams) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, listMerchantVouchers, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.MinOrderAmount,
			&i.TotalQuantity,
			&i.ClaimedQuantity,
			&i.UsedQuantity,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AllowedOrderTypes,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAvailableVouchers = `-- name: ListUserAvailableVouchers :many
SELECT uv.id, uv.voucher_id, uv.user_id, uv.status, uv.order_id, uv.used_at, uv.obtained_at, uv.expires_at, v.merchant_id, v.code, v.name, v.amount, v.min_order_amount, v.allowed_order_types, m.name as merchant_name
FROM user_vouchers uv
JOIN vouchers v ON v.id = uv.voucher_id
JOIN merchants m ON m.id = v.merchant_id
WHERE uv.user_id = $1 
    AND uv.status = 'unused'
    AND uv.expires_at > NOW()
ORDER BY v.amount DESC
LIMIT $2 OFFSET $3
`

type ListUserAvailableVouchersParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUserAvailableVouchersRow struct {
	ID                int64              `json:"id"`
	VoucherID         int64              `json:"voucher_id"`
	UserID            int64              `json:"user_id"`
	Status            string             `json:"status"`
	OrderID           pgtype.Int8        `json:"order_id"`
	UsedAt            pgtype.Timestamptz `json:"used_at"`
	ObtainedAt        time.Time          `json:"obtained_at"`
	ExpiresAt         time.Time          `json:"expires_at"`
	MerchantID        int64              `json:"merchant_id"`
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Amount            int64              `json:"amount"`
	MinOrderAmount    int64              `json:"min_order_amount"`
	AllowedOrderTypes []string           `json:"allowed_order_types"`
	MerchantName      string             `json:"merchant_name"`
}

func (q *Queries) ListUserAvailableVouchers(ctx context.Context, arg ListUserAvailableVouchersParams) ([]ListUserAvailableVouchersRow, error) {
	rows, err := q.db.Query(ctx, listUserAvailableVouchers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserAvailableVouchersRow{}
	for rows.Next() {
		var i ListUserAvailableVouchersRow
		if err := rows.Scan(
			&i.ID,
			&i.VoucherID,
			&i.UserID,
			&i.Status,
			&i.OrderID,
			&i.UsedAt,
			&i.ObtainedAt,
			&i.ExpiresAt,
			&i.MerchantID,
			&i.Code,
			&i.Name,
			&i.Amount,
			&i.MinOrderAmount,
			&i.AllowedOrderTypes,
			&i.MerchantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAvailableVouchersForMerchant = `-- name: ListUserAvailableVouchersForMerchant :many
SELECT uv.id, uv.voucher_id, uv.user_id, uv.status, uv.order_id, uv.used_at, uv.obtained_at, uv.expires_at, v.code, v.name, v.amount, v.min_order_amount, v.allowed_order_types
FROM user_vouchers uv
JOIN vouchers v ON v.id = uv.voucher_id
WHERE uv.user_id = $1 
    AND v.merchant_id = $2
    AND uv.status = 'unused'
    AND uv.expires_at > NOW()
    AND v.min_order_amount <= $3
ORDER BY v.amount DESC
`

type ListUserAvailableVouchersForMerchantParams struct {
	UserID         int64 `json:"user_id"`
	MerchantID     int64 `json:"merchant_id"`
	MinOrderAmount int64 `json:"min_order_amount"`
}

type ListUserAvailableVouchersForMerchantRow struct {
	ID                int64              `json:"id"`
	VoucherID         int64              `json:"voucher_id"`
	UserID            int64              `json:"user_id"`
	Status            string             `json:"status"`
	OrderID           pgtype.Int8        `json:"order_id"`
	UsedAt            pgtype.Timestamptz `json:"used_at"`
	ObtainedAt        time.Time          `json:"obtained_at"`
	ExpiresAt         time.Time          `json:"expires_at"`
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Amount            int64              `json:"amount"`
	MinOrderAmount    int64              `json:"min_order_amount"`
	AllowedOrderTypes []string           `json:"allowed_order_types"`
}

func (q *Queries) ListUserAvailableVouchersForMerchant(ctx context.Context, arg ListUserAvailableVouchersForMerchantParams) ([]ListUserAvailableVouchersForMerchantRow, error) {
	rows, err := q.db.Query(ctx, listUserAvailableVouchersForMerchant, arg.UserID, arg.MerchantID, arg.MinOrderAmount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserAvailableVouchersForMerchantRow{}
	for rows.Next() {
		var i ListUserAvailableVouchersForMerchantRow
		if err := rows.Scan(
			&i.ID,
			&i.VoucherID,
			&i.UserID,
			&i.Status,
			&i.OrderID,
			&i.UsedAt,
			&i.ObtainedAt,
			&i.ExpiresAt,
			&i.Code,
			&i.Name,
			&i.Amount,
			&i.MinOrderAmount,
			&i.AllowedOrderTypes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserVouchers = `-- name: ListUserVouchers :many
SELECT uv.id, uv.voucher_id, uv.user_id, uv.status, uv.order_id, uv.used_at, uv.obtained_at, uv.expires_at, v.merchant_id, v.code, v.name, v.amount, v.min_order_amount, v.allowed_order_types, m.name as merchant_name
FROM user_vouchers uv
JOIN vouchers v ON v.id = uv.voucher_id
JOIN merchants m ON m.id = v.merchant_id
WHERE uv.user_id = $1
ORDER BY uv.obtained_at DESC
LIMIT $2 OFFSET $3
`

type ListUserVouchersParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUserVouchersRow struct {
	ID                int64              `json:"id"`
	VoucherID         int64              `json:"voucher_id"`
	UserID            int64              `json:"user_id"`
	Status            string             `json:"status"`
	OrderID           pgtype.Int8        `json:"order_id"`
	UsedAt            pgtype.Timestamptz `json:"used_at"`
	ObtainedAt        time.Time          `json:"obtained_at"`
	ExpiresAt         time.Time          `json:"expires_at"`
	MerchantID        int64              `json:"merchant_id"`
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Amount            int64              `json:"amount"`
	MinOrderAmount    int64              `json:"min_order_amount"`
	AllowedOrderTypes []string           `json:"allowed_order_types"`
	MerchantName      string             `json:"merchant_name"`
}

func (q *Queries) ListUserVouchers(ctx context.Context, arg ListUserVouchersParams) ([]ListUserVouchersRow, error) {
	rows, err := q.db.Query(ctx, listUserVouchers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserVouchersRow{}
	for rows.Next() {
		var i ListUserVouchersRow
		if err := rows.Scan(
			&i.ID,
			&i.VoucherID,
			&i.UserID,
			&i.Status,
			&i.OrderID,
			&i.UsedAt,
			&i.ObtainedAt,
			&i.ExpiresAt,
			&i.MerchantID,
			&i.Code,
			&i.Name,
			&i.Amount,
			&i.MinOrderAmount,
			&i.AllowedOrderTypes,
			&i.MerchantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpiredVouchers = `-- name: MarkExpiredVouchers :exec
UPDATE user_vouchers
SET status = 'expired'
WHERE status = 'unused' 
    AND expires_at <= NOW()
`

func (q *Queries) MarkExpiredVouchers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, markExpiredVouchers)
	return err
}

const markUserVoucherAsUsed = `-- name: MarkUserVoucherAsUsed :one
UPDATE user_vouchers
SET 
    status = 'used',
    order_id = $2,
    used_at = NOW()
WHERE id = $1 AND status = 'unused'
RETURNING id, voucher_id, user_id, status, order_id, used_at, obtained_at, expires_at
`

type MarkUserVoucherAsUsedParams struct {
	ID      int64       `json:"id"`
	OrderID pgtype.Int8 `json:"order_id"`
}

func (q *Queries) MarkUserVoucherAsUsed(ctx context.Context, arg MarkUserVoucherAsUsedParams) (UserVoucher, error) {
	row := q.db.QueryRow(ctx, markUserVoucherAsUsed, arg.ID, arg.OrderID)
	var i UserVoucher
	err := row.Scan(
		&i.ID,
		&i.VoucherID,
		&i.UserID,
		&i.Status,
		&i.OrderID,
		&i.UsedAt,
		&i.ObtainedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateVoucher = `-- name: UpdateVoucher :one
UPDATE vouchers
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    amount = COALESCE($3, amount),
    min_order_amount = COALESCE($4, min_order_amount),
    total_quantity = COALESCE($5, total_quantity),
    valid_from = COALESCE($6, valid_from),
    valid_until = COALESCE($7, valid_until),
    is_active = COALESCE($8, is_active),
    allowed_order_types = COALESCE($9, allowed_order_types),
    updated_at = NOW()
WHERE id = $10 AND deleted_at IS NULL
RETURNING id, merchant_id, code, name, description, amount, min_order_amount, total_quantity, claimed_quantity, used_quantity, valid_from, valid_until, is_active, created_at, updated_at, allowed_order_types, deleted_at
`

type UpdateVoucherParams struct {
	Name              pgtype.Text        `json:"name"`
	Description       pgtype.Text        `json:"description"`
	Amount            pgtype.Int8        `json:"amount"`
	MinOrderAmount    pgtype.Int8        `json:"min_order_amount"`
	TotalQuantity     pgtype.Int4        `json:"total_quantity"`
	ValidFrom         pgtype.Timestamptz `json:"valid_from"`
	ValidUntil        pgtype.Timestamptz `json:"valid_until"`
	IsActive          pgtype.Bool        `json:"is_active"`
	AllowedOrderTypes []string           `json:"allowed_order_types"`
	ID                int64              `json:"id"`
}

func (q *Queries) UpdateVoucher(ctx context.Context, arg UpdateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, updateVoucher,
		arg.Name,
		arg.Description,
		arg.Amount,
		arg.MinOrderAmount,
		arg.TotalQuantity,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
		arg.AllowedOrderTypes,
		arg.ID,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.MinOrderAmount,
		&i.TotalQuantity,
		&i.ClaimedQuantity,
		&i.UsedQuantity,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AllowedOrderTypes,
		&i.DeletedAt,
	)
	return i, err
}
