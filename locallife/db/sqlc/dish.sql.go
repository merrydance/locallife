// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dish.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDishIngredient = `-- name: AddDishIngredient :one

INSERT INTO dish_ingredients (
  dish_id,
  ingredient_id
) VALUES (
  $1, $2
) RETURNING id, dish_id, ingredient_id, created_at
`

type AddDishIngredientParams struct {
	DishID       int64 `json:"dish_id"`
	IngredientID int64 `json:"ingredient_id"`
}

// ============================================
// 菜品食材关联查询 (Dish Ingredient Queries)
// ============================================
func (q *Queries) AddDishIngredient(ctx context.Context, arg AddDishIngredientParams) (DishIngredient, error) {
	row := q.db.QueryRow(ctx, addDishIngredient, arg.DishID, arg.IngredientID)
	var i DishIngredient
	err := row.Scan(
		&i.ID,
		&i.DishID,
		&i.IngredientID,
		&i.CreatedAt,
	)
	return i, err
}

const addDishTag = `-- name: AddDishTag :one

INSERT INTO dish_tags (
  dish_id,
  tag_id
) VALUES (
  $1, $2
) RETURNING id, dish_id, tag_id, created_at
`

type AddDishTagParams struct {
	DishID int64 `json:"dish_id"`
	TagID  int64 `json:"tag_id"`
}

// ============================================
// 菜品标签关联查询 (Dish Tag Queries)
// ============================================
func (q *Queries) AddDishTag(ctx context.Context, arg AddDishTagParams) (DishTag, error) {
	row := q.db.QueryRow(ctx, addDishTag, arg.DishID, arg.TagID)
	var i DishTag
	err := row.Scan(
		&i.ID,
		&i.DishID,
		&i.TagID,
		&i.CreatedAt,
	)
	return i, err
}

const batchUpdateDishOnlineStatus = `-- name: BatchUpdateDishOnlineStatus :execrows
UPDATE dishes
SET is_online = $1, updated_at = NOW()
WHERE id = ANY($2::bigint[])
  AND merchant_id = $3
  AND deleted_at IS NULL
RETURNING id
`

type BatchUpdateDishOnlineStatusParams struct {
	IsOnline   bool    `json:"is_online"`
	Column2    []int64 `json:"column_2"`
	MerchantID int64   `json:"merchant_id"`
}

// 批量更新菜品上下架状态（只更新属于指定商户的菜品）
func (q *Queries) BatchUpdateDishOnlineStatus(ctx context.Context, arg BatchUpdateDishOnlineStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, batchUpdateDishOnlineStatus, arg.IsOnline, arg.Column2, arg.MerchantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const countDishesByMerchant = `-- name: CountDishesByMerchant :one
SELECT COUNT(*) FROM dishes
WHERE 
  merchant_id = $1
  AND deleted_at IS NULL
  AND ($2::boolean IS NULL OR is_online = $2)
`

type CountDishesByMerchantParams struct {
	MerchantID int64       `json:"merchant_id"`
	IsOnline   pgtype.Bool `json:"is_online"`
}

func (q *Queries) CountDishesByMerchant(ctx context.Context, arg CountDishesByMerchantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDishesByMerchant, arg.MerchantID, arg.IsOnline)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchDishesByName = `-- name: CountSearchDishesByName :one
SELECT COUNT(*) FROM dishes
WHERE 
  merchant_id = $1
  AND deleted_at IS NULL
  AND name ILIKE '%' || $2 || '%'
  AND is_online = true
`

type CountSearchDishesByNameParams struct {
	MerchantID int64       `json:"merchant_id"`
	Column2    pgtype.Text `json:"column_2"`
}

// 统计商户内菜品搜索结果总数
func (q *Queries) CountSearchDishesByName(ctx context.Context, arg CountSearchDishesByNameParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchDishesByName, arg.MerchantID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchDishesGlobal = `-- name: CountSearchDishesGlobal :one
SELECT COUNT(*) FROM dishes d
JOIN merchants m ON d.merchant_id = m.id
WHERE 
  m.status = 'active'
  AND m.deleted_at IS NULL
  AND d.deleted_at IS NULL
  AND d.is_online = true
  AND d.name ILIKE '%' || $1 || '%'
`

// 统计全局菜品搜索结果总数
func (q *Queries) CountSearchDishesGlobal(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchDishesGlobal, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDish = `-- name: CreateDish :one

INSERT INTO dishes (
  merchant_id,
  category_id,
  name,
  description,
  image_url,
  price,
  member_price,
  is_available,
  is_online,
  sort_order,
  prepare_time
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, merchant_id, category_id, name, description, image_url, price, member_price, is_available, is_online, sort_order, created_at, updated_at, prepare_time, deleted_at, monthly_sales, repurchase_rate
`

type CreateDishParams struct {
	MerchantID  int64       `json:"merchant_id"`
	CategoryID  pgtype.Int8 `json:"category_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Price       int64       `json:"price"`
	MemberPrice pgtype.Int8 `json:"member_price"`
	IsAvailable bool        `json:"is_available"`
	IsOnline    bool        `json:"is_online"`
	SortOrder   int16       `json:"sort_order"`
	PrepareTime int16       `json:"prepare_time"`
}

// ============================================
// 菜品查询 (Dish Queries)
// ============================================
func (q *Queries) CreateDish(ctx context.Context, arg CreateDishParams) (Dish, error) {
	row := q.db.QueryRow(ctx, createDish,
		arg.MerchantID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Price,
		arg.MemberPrice,
		arg.IsAvailable,
		arg.IsOnline,
		arg.SortOrder,
		arg.PrepareTime,
	)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.MemberPrice,
		&i.IsAvailable,
		&i.IsOnline,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrepareTime,
		&i.DeletedAt,
		&i.MonthlySales,
		&i.RepurchaseRate,
	)
	return i, err
}

const createDishCategory = `-- name: CreateDishCategory :one
INSERT INTO dish_categories (
  name
) VALUES (
  $1
) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, created_at, deleted_at
`

func (q *Queries) CreateDishCategory(ctx context.Context, name string) (DishCategory, error) {
	row := q.db.QueryRow(ctx, createDishCategory, name)
	var i DishCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createDishCustomizationGroup = `-- name: CreateDishCustomizationGroup :one

INSERT INTO dish_customization_groups (
  dish_id,
  name,
  is_required,
  sort_order
) VALUES (
  $1, $2, $3, $4
) RETURNING id, dish_id, name, is_required, sort_order, created_at
`

type CreateDishCustomizationGroupParams struct {
	DishID     int64  `json:"dish_id"`
	Name       string `json:"name"`
	IsRequired bool   `json:"is_required"`
	SortOrder  int16  `json:"sort_order"`
}

// ============================================
// 菜品定制选项查询 (Dish Customization Queries)
// ============================================
func (q *Queries) CreateDishCustomizationGroup(ctx context.Context, arg CreateDishCustomizationGroupParams) (DishCustomizationGroup, error) {
	row := q.db.QueryRow(ctx, createDishCustomizationGroup,
		arg.DishID,
		arg.Name,
		arg.IsRequired,
		arg.SortOrder,
	)
	var i DishCustomizationGroup
	err := row.Scan(
		&i.ID,
		&i.DishID,
		&i.Name,
		&i.IsRequired,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createDishCustomizationOption = `-- name: CreateDishCustomizationOption :one
INSERT INTO dish_customization_options (
  group_id,
  tag_id,
  extra_price,
  sort_order
) VALUES (
  $1, $2, $3, $4
) RETURNING id, group_id, tag_id, extra_price, sort_order
`

type CreateDishCustomizationOptionParams struct {
	GroupID    int64 `json:"group_id"`
	TagID      int64 `json:"tag_id"`
	ExtraPrice int64 `json:"extra_price"`
	SortOrder  int16 `json:"sort_order"`
}

func (q *Queries) CreateDishCustomizationOption(ctx context.Context, arg CreateDishCustomizationOptionParams) (DishCustomizationOption, error) {
	row := q.db.QueryRow(ctx, createDishCustomizationOption,
		arg.GroupID,
		arg.TagID,
		arg.ExtraPrice,
		arg.SortOrder,
	)
	var i DishCustomizationOption
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.TagID,
		&i.ExtraPrice,
		&i.SortOrder,
	)
	return i, err
}

const deleteAllDishCustomizationGroups = `-- name: DeleteAllDishCustomizationGroups :exec
DELETE FROM dish_customization_groups
WHERE dish_id = $1
`

func (q *Queries) DeleteAllDishCustomizationGroups(ctx context.Context, dishID int64) error {
	_, err := q.db.Exec(ctx, deleteAllDishCustomizationGroups, dishID)
	return err
}

const deleteDish = `-- name: DeleteDish :exec
UPDATE dishes SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

// 软删除菜品
func (q *Queries) DeleteDish(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDish, id)
	return err
}

const deleteDishCustomizationGroup = `-- name: DeleteDishCustomizationGroup :exec
DELETE FROM dish_customization_groups
WHERE id = $1
`

func (q *Queries) DeleteDishCustomizationGroup(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDishCustomizationGroup, id)
	return err
}

const deleteDishCustomizationOption = `-- name: DeleteDishCustomizationOption :exec
DELETE FROM dish_customization_options
WHERE id = $1
`

func (q *Queries) DeleteDishCustomizationOption(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDishCustomizationOption, id)
	return err
}

const getDish = `-- name: GetDish :one
SELECT id, merchant_id, category_id, name, description, image_url, price, member_price, is_available, is_online, sort_order, created_at, updated_at, prepare_time, deleted_at, monthly_sales, repurchase_rate FROM dishes
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetDish(ctx context.Context, id int64) (Dish, error) {
	row := q.db.QueryRow(ctx, getDish, id)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.MemberPrice,
		&i.IsAvailable,
		&i.IsOnline,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrepareTime,
		&i.DeletedAt,
		&i.MonthlySales,
		&i.RepurchaseRate,
	)
	return i, err
}

const getDishCategory = `-- name: GetDishCategory :one
SELECT id, name, created_at, deleted_at FROM dish_categories
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetDishCategory(ctx context.Context, id int64) (DishCategory, error) {
	row := q.db.QueryRow(ctx, getDishCategory, id)
	var i DishCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDishCategoryByName = `-- name: GetDishCategoryByName :one

SELECT id, name, created_at, deleted_at FROM dish_categories
WHERE name = $1 LIMIT 1
`

// ============================================
// 菜品分类查询 (Dish Category Queries)
// ============================================
func (q *Queries) GetDishCategoryByName(ctx context.Context, name string) (DishCategory, error) {
	row := q.db.QueryRow(ctx, getDishCategoryByName, name)
	var i DishCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDishComplete = `-- name: GetDishComplete :one
SELECT 
  d.id, d.merchant_id, d.category_id, d.name, d.description, d.image_url, d.price, d.member_price, d.is_available, d.is_online, d.sort_order, d.created_at, d.updated_at, d.prepare_time, d.deleted_at, d.monthly_sales, d.repurchase_rate,
  dc.name as category_name,
  COALESCE(
    json_agg(DISTINCT
      jsonb_build_object(
        'id', i.id,
        'name', i.name,
        'category', i.category,
        'is_allergen', i.is_allergen
      )
    ) FILTER (WHERE i.id IS NOT NULL),
    '[]'
  ) as ingredients,
  COALESCE(
    json_agg(DISTINCT
      jsonb_build_object(
        'id', t.id,
        'name', t.name
      )
    ) FILTER (WHERE t.id IS NOT NULL),
    '[]'
  ) as tags,
  COALESCE(
    (
      SELECT json_agg(
        json_build_object(
          'id', dcg.id,
          'name', dcg.name,
          'is_required', dcg.is_required,
          'sort_order', dcg.sort_order,
          'options', (
            SELECT json_agg(
              json_build_object(
                'id', dco.id,
                'tag_id', dco.tag_id,
                'tag_name', opt_tag.name,
                'extra_price', dco.extra_price,
                'sort_order', dco.sort_order
              ) ORDER BY dco.sort_order
            )
            FROM dish_customization_options dco
            JOIN tags opt_tag ON dco.tag_id = opt_tag.id
            WHERE dco.group_id = dcg.id
          )
        ) ORDER BY dcg.sort_order
      )
      FROM dish_customization_groups dcg
      WHERE dcg.dish_id = d.id
    ),
    '[]'
  ) as customization_groups
FROM dishes d
LEFT JOIN dish_categories dc ON d.category_id = dc.id
LEFT JOIN dish_ingredients di ON d.id = di.dish_id
LEFT JOIN ingredients i ON di.ingredient_id = i.id
LEFT JOIN dish_tags dt ON d.id = dt.dish_id
LEFT JOIN tags t ON dt.tag_id = t.id
WHERE d.id = $1 AND d.deleted_at IS NULL
GROUP BY d.id, dc.name
`

type GetDishCompleteRow struct {
	ID                  int64              `json:"id"`
	MerchantID          int64              `json:"merchant_id"`
	CategoryID          pgtype.Int8        `json:"category_id"`
	Name                string             `json:"name"`
	Description         pgtype.Text        `json:"description"`
	ImageUrl            pgtype.Text        `json:"image_url"`
	Price               int64              `json:"price"`
	MemberPrice         pgtype.Int8        `json:"member_price"`
	IsAvailable         bool               `json:"is_available"`
	IsOnline            bool               `json:"is_online"`
	SortOrder           int16              `json:"sort_order"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PrepareTime         int16              `json:"prepare_time"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	MonthlySales        int32              `json:"monthly_sales"`
	RepurchaseRate      pgtype.Numeric     `json:"repurchase_rate"`
	CategoryName        pgtype.Text        `json:"category_name"`
	Ingredients         interface{}        `json:"ingredients"`
	Tags                interface{}        `json:"tags"`
	CustomizationGroups interface{}        `json:"customization_groups"`
}

func (q *Queries) GetDishComplete(ctx context.Context, id int64) (GetDishCompleteRow, error) {
	row := q.db.QueryRow(ctx, getDishComplete, id)
	var i GetDishCompleteRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.MemberPrice,
		&i.IsAvailable,
		&i.IsOnline,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrepareTime,
		&i.DeletedAt,
		&i.MonthlySales,
		&i.RepurchaseRate,
		&i.CategoryName,
		&i.Ingredients,
		&i.Tags,
		&i.CustomizationGroups,
	)
	return i, err
}

const getDishIDsByCuisines = `-- name: GetDishIDsByCuisines :many
SELECT d.id FROM dishes d
WHERE d.is_online = true 
  AND d.is_available = true
  AND d.deleted_at IS NULL
  AND d.price >= $1
  AND d.price <= $2
ORDER BY d.created_at DESC
LIMIT $3
`

type GetDishIDsByCuisinesParams struct {
	Price   int64 `json:"price"`
	Price_2 int64 `json:"price_2"`
	Limit   int32 `json:"limit"`
}

// 根据菜系获取菜品ID（用于基于偏好推荐）
// 注：当前merchants表无cuisine_type字段，简化为按价格区间查询热门菜品
func (q *Queries) GetDishIDsByCuisines(ctx context.Context, arg GetDishIDsByCuisinesParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getDishIDsByCuisines, arg.Price, arg.Price_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDishIDsByTagID = `-- name: GetDishIDsByTagID :many
SELECT DISTINCT d.id
FROM dishes d
JOIN dish_tags dt ON d.id = dt.dish_id
WHERE dt.tag_id = $1
  AND d.is_online = true
  AND d.is_available = true
  AND d.deleted_at IS NULL
`

// 获取带有指定标签的菜品ID列表（用于推荐过滤）
func (q *Queries) GetDishIDsByTagID(ctx context.Context, tagID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getDishIDsByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDishWithCustomizations = `-- name: GetDishWithCustomizations :one
SELECT 
  d.id, d.merchant_id, d.category_id, d.name, d.description, d.image_url, d.price, d.member_price, d.is_available, d.is_online, d.sort_order, d.created_at, d.updated_at, d.prepare_time, d.deleted_at, d.monthly_sales, d.repurchase_rate,
  COALESCE(
    json_agg(
      json_build_object(
        'id', dcg.id,
        'name', dcg.name,
        'is_required', dcg.is_required,
        'sort_order', dcg.sort_order,
        'options', (
          SELECT json_agg(
            json_build_object(
              'id', dco.id,
              'tag_id', dco.tag_id,
              'tag_name', t.name,
              'extra_price', dco.extra_price,
              'sort_order', dco.sort_order
            ) ORDER BY dco.sort_order
          )
          FROM dish_customization_options dco
          JOIN tags t ON dco.tag_id = t.id
          WHERE dco.group_id = dcg.id
        )
      ) ORDER BY dcg.sort_order
    ) FILTER (WHERE dcg.id IS NOT NULL),
    '[]'
  ) as customization_groups
FROM dishes d
LEFT JOIN dish_customization_groups dcg ON d.id = dcg.dish_id
WHERE d.id = $1 AND d.deleted_at IS NULL
GROUP BY d.id
`

type GetDishWithCustomizationsRow struct {
	ID                  int64              `json:"id"`
	MerchantID          int64              `json:"merchant_id"`
	CategoryID          pgtype.Int8        `json:"category_id"`
	Name                string             `json:"name"`
	Description         pgtype.Text        `json:"description"`
	ImageUrl            pgtype.Text        `json:"image_url"`
	Price               int64              `json:"price"`
	MemberPrice         pgtype.Int8        `json:"member_price"`
	IsAvailable         bool               `json:"is_available"`
	IsOnline            bool               `json:"is_online"`
	SortOrder           int16              `json:"sort_order"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PrepareTime         int16              `json:"prepare_time"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	MonthlySales        int32              `json:"monthly_sales"`
	RepurchaseRate      pgtype.Numeric     `json:"repurchase_rate"`
	CustomizationGroups interface{}        `json:"customization_groups"`
}

func (q *Queries) GetDishWithCustomizations(ctx context.Context, id int64) (GetDishWithCustomizationsRow, error) {
	row := q.db.QueryRow(ctx, getDishWithCustomizations, id)
	var i GetDishWithCustomizationsRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.MemberPrice,
		&i.IsAvailable,
		&i.IsOnline,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrepareTime,
		&i.DeletedAt,
		&i.MonthlySales,
		&i.RepurchaseRate,
		&i.CustomizationGroups,
	)
	return i, err
}

const getDishWithDetails = `-- name: GetDishWithDetails :one
SELECT 
  d.id, d.merchant_id, d.category_id, d.name, d.description, d.image_url, d.price, d.member_price, d.is_available, d.is_online, d.sort_order, d.created_at, d.updated_at, d.prepare_time, d.deleted_at, d.monthly_sales, d.repurchase_rate,
  dc.name as category_name,
  COALESCE(
    json_agg(DISTINCT
      jsonb_build_object(
        'id', i.id,
        'name', i.name,
        'category', i.category,
        'is_allergen', i.is_allergen
      )
    ) FILTER (WHERE i.id IS NOT NULL),
    '[]'
  ) as ingredients,
  COALESCE(
    json_agg(DISTINCT
      jsonb_build_object(
        'id', t.id,
        'name', t.name
      )
    ) FILTER (WHERE t.id IS NOT NULL),
    '[]'
  ) as tags
FROM dishes d
LEFT JOIN dish_categories dc ON d.category_id = dc.id
LEFT JOIN dish_ingredients di ON d.id = di.dish_id
LEFT JOIN ingredients i ON di.ingredient_id = i.id
LEFT JOIN dish_tags dt ON d.id = dt.dish_id
LEFT JOIN tags t ON dt.tag_id = t.id
WHERE d.id = $1 AND d.deleted_at IS NULL
GROUP BY d.id, dc.name
`

type GetDishWithDetailsRow struct {
	ID             int64              `json:"id"`
	MerchantID     int64              `json:"merchant_id"`
	CategoryID     pgtype.Int8        `json:"category_id"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	Price          int64              `json:"price"`
	MemberPrice    pgtype.Int8        `json:"member_price"`
	IsAvailable    bool               `json:"is_available"`
	IsOnline       bool               `json:"is_online"`
	SortOrder      int16              `json:"sort_order"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	PrepareTime    int16              `json:"prepare_time"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	MonthlySales   int32              `json:"monthly_sales"`
	RepurchaseRate pgtype.Numeric     `json:"repurchase_rate"`
	CategoryName   pgtype.Text        `json:"category_name"`
	Ingredients    interface{}        `json:"ingredients"`
	Tags           interface{}        `json:"tags"`
}

func (q *Queries) GetDishWithDetails(ctx context.Context, id int64) (GetDishWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getDishWithDetails, id)
	var i GetDishWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.MemberPrice,
		&i.IsAvailable,
		&i.IsOnline,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrepareTime,
		&i.DeletedAt,
		&i.MonthlySales,
		&i.RepurchaseRate,
		&i.CategoryName,
		&i.Ingredients,
		&i.Tags,
	)
	return i, err
}

const getDishesByIDs = `-- name: GetDishesByIDs :many
SELECT 
    id,
    merchant_id,
    name,
    description,
    image_url,
    price,
    member_price,
    is_available,
    is_online
FROM dishes
WHERE id = ANY($1::bigint[])
  AND deleted_at IS NULL
  AND is_online = true
`

type GetDishesByIDsRow struct {
	ID          int64       `json:"id"`
	MerchantID  int64       `json:"merchant_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Price       int64       `json:"price"`
	MemberPrice pgtype.Int8 `json:"member_price"`
	IsAvailable bool        `json:"is_available"`
	IsOnline    bool        `json:"is_online"`
}

// 批量获取菜品详情（用于推荐结果）
func (q *Queries) GetDishesByIDs(ctx context.Context, dollar_1 []int64) ([]GetDishesByIDsRow, error) {
	rows, err := q.db.Query(ctx, getDishesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDishesByIDsRow{}
	for rows.Next() {
		var i GetDishesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDishesByIDsAll = `-- name: GetDishesByIDsAll :many
SELECT 
    id,
    merchant_id,
    name,
    description,
    image_url,
    price,
    member_price,
    is_available,
    is_online
FROM dishes
WHERE id = ANY($1::bigint[])
  AND deleted_at IS NULL
`

type GetDishesByIDsAllRow struct {
	ID          int64       `json:"id"`
	MerchantID  int64       `json:"merchant_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Price       int64       `json:"price"`
	MemberPrice pgtype.Int8 `json:"member_price"`
	IsAvailable bool        `json:"is_available"`
	IsOnline    bool        `json:"is_online"`
}

// 批量获取菜品（不过滤上下架状态，用于权限验证等）
func (q *Queries) GetDishesByIDsAll(ctx context.Context, dollar_1 []int64) ([]GetDishesByIDsAllRow, error) {
	rows, err := q.db.Query(ctx, getDishesByIDsAll, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDishesByIDsAllRow{}
	for rows.Next() {
		var i GetDishesByIDsAllRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDishesWithMerchantByIDs = `-- name: GetDishesWithMerchantByIDs :many
SELECT 
    d.id,
    d.merchant_id,
    d.name,
    d.description,
    d.image_url,
    d.price,
    d.member_price,
    d.is_available,
    d.is_online,
    m.name AS merchant_name,
    m.logo_url AS merchant_logo,
    m.latitude AS merchant_latitude,
    m.longitude AS merchant_longitude,
    m.region_id AS merchant_region_id,
    m.is_open AS merchant_is_open,
    COALESCE(
        (SELECT SUM(oi.quantity)
         FROM order_items oi 
         JOIN orders o ON o.id = oi.order_id 
         WHERE oi.dish_id = d.id 
           AND o.status IN ('delivered', 'completed')
           AND o.created_at >= NOW() - INTERVAL '30 days'
        ), 0
    )::int AS monthly_sales
FROM dishes d
JOIN merchants m ON m.id = d.merchant_id
WHERE d.id = ANY($1::bigint[])
  AND d.deleted_at IS NULL
  AND d.is_online = true
  AND m.status = 'active'
`

type GetDishesWithMerchantByIDsRow struct {
	ID                int64          `json:"id"`
	MerchantID        int64          `json:"merchant_id"`
	Name              string         `json:"name"`
	Description       pgtype.Text    `json:"description"`
	ImageUrl          pgtype.Text    `json:"image_url"`
	Price             int64          `json:"price"`
	MemberPrice       pgtype.Int8    `json:"member_price"`
	IsAvailable       bool           `json:"is_available"`
	IsOnline          bool           `json:"is_online"`
	MerchantName      string         `json:"merchant_name"`
	MerchantLogo      pgtype.Text    `json:"merchant_logo"`
	MerchantLatitude  pgtype.Numeric `json:"merchant_latitude"`
	MerchantLongitude pgtype.Numeric `json:"merchant_longitude"`
	MerchantRegionID  int64          `json:"merchant_region_id"`
	MerchantIsOpen    bool           `json:"merchant_is_open"`
	MonthlySales      int32          `json:"monthly_sales"`
}

// 批量获取菜品详情及商户信息（用于推荐流展示）
// 返回菜品信息、商户信息、近30天销量
func (q *Queries) GetDishesWithMerchantByIDs(ctx context.Context, dollar_1 []int64) ([]GetDishesWithMerchantByIDsRow, error) {
	rows, err := q.db.Query(ctx, getDishesWithMerchantByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDishesWithMerchantByIDsRow{}
	for rows.Next() {
		var i GetDishesWithMerchantByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantLatitude,
			&i.MerchantLongitude,
			&i.MerchantRegionID,
			&i.MerchantIsOpen,
			&i.MonthlySales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExploreDishes = `-- name: GetExploreDishes :many
SELECT 
    d.id,
    COALESCE(SUM(oi.quantity), 0)::int AS total_sold
FROM dishes d
LEFT JOIN order_items oi ON d.id = oi.dish_id
LEFT JOIN orders o ON o.id = oi.order_id AND o.status IN ('delivered', 'completed')
WHERE d.is_online = true 
  AND d.is_available = true
  AND d.deleted_at IS NULL
  AND d.id NOT IN (
    SELECT DISTINCT oi2.dish_id 
    FROM order_items oi2
    JOIN orders o2 ON o2.id = oi2.order_id
    WHERE o2.user_id = $1
      AND o2.status IN ('delivered', 'completed')
  )
GROUP BY d.id
ORDER BY total_sold DESC
LIMIT $2
`

type GetExploreDishesParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type GetExploreDishesRow struct {
	ID        int64 `json:"id"`
	TotalSold int32 `json:"total_sold"`
}

// 获取用户未购买过的热门菜品（探索推荐）
func (q *Queries) GetExploreDishes(ctx context.Context, arg GetExploreDishesParams) ([]GetExploreDishesRow, error) {
	rows, err := q.db.Query(ctx, getExploreDishes, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExploreDishesRow{}
	for rows.Next() {
		var i GetExploreDishesRow
		if err := rows.Scan(&i.ID, &i.TotalSold); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantDishCategory = `-- name: GetMerchantDishCategory :one
SELECT merchant_id, category_id, sort_order, created_at FROM merchant_dish_categories
WHERE merchant_id = $1 AND category_id = $2
`

type GetMerchantDishCategoryParams struct {
	MerchantID int64 `json:"merchant_id"`
	CategoryID int64 `json:"category_id"`
}

func (q *Queries) GetMerchantDishCategory(ctx context.Context, arg GetMerchantDishCategoryParams) (MerchantDishCategory, error) {
	row := q.db.QueryRow(ctx, getMerchantDishCategory, arg.MerchantID, arg.CategoryID)
	var i MerchantDishCategory
	err := row.Scan(
		&i.MerchantID,
		&i.CategoryID,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getPopularDishes = `-- name: GetPopularDishes :many

SELECT 
    d.id,
    d.merchant_id,
    d.name,
    d.description,
    d.image_url,
    d.price,
    d.member_price,
    COALESCE(SUM(oi.quantity), 0)::int AS total_sold
FROM dishes d
LEFT JOIN order_items oi ON d.id = oi.dish_id
LEFT JOIN orders o ON o.id = oi.order_id AND o.status IN ('delivered', 'completed')
WHERE d.is_online = true 
  AND d.is_available = true
  AND d.deleted_at IS NULL
GROUP BY d.id
ORDER BY total_sold DESC, d.created_at DESC
LIMIT $1
`

type GetPopularDishesRow struct {
	ID          int64       `json:"id"`
	MerchantID  int64       `json:"merchant_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Price       int64       `json:"price"`
	MemberPrice pgtype.Int8 `json:"member_price"`
	TotalSold   int32       `json:"total_sold"`
}

// ============================================
// 推荐系统查询 (Recommendation Queries)
// ============================================
// 获取全平台热门菜品（基于销量）
func (q *Queries) GetPopularDishes(ctx context.Context, limit int32) ([]GetPopularDishesRow, error) {
	rows, err := q.db.Query(ctx, getPopularDishes, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularDishesRow{}
	for rows.Next() {
		var i GetPopularDishesRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.TotalSold,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomDishes = `-- name: GetRandomDishes :many
SELECT id FROM dishes
WHERE is_online = true 
  AND is_available = true
  AND deleted_at IS NULL
ORDER BY RANDOM()
LIMIT $1
`

// 获取随机菜品（用于推荐探索）
func (q *Queries) GetRandomDishes(ctx context.Context, limit int32) ([]int64, error) {
	rows, err := q.db.Query(ctx, getRandomDishes, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPurchasedDishIDs = `-- name: GetUserPurchasedDishIDs :many
SELECT DISTINCT oi.dish_id 
FROM order_items oi
JOIN orders o ON o.id = oi.order_id
WHERE o.user_id = $1
  AND o.status IN ('delivered', 'completed')
  AND o.created_at >= $2
`

type GetUserPurchasedDishIDsParams struct {
	UserID    int64     `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
}

// 获取用户购买过的菜品ID（用于排除已购买）
func (q *Queries) GetUserPurchasedDishIDs(ctx context.Context, arg GetUserPurchasedDishIDsParams) ([]pgtype.Int8, error) {
	rows, err := q.db.Query(ctx, getUserPurchasedDishIDs, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Int8{}
	for rows.Next() {
		var dish_id pgtype.Int8
		if err := rows.Scan(&dish_id); err != nil {
			return nil, err
		}
		items = append(items, dish_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkMerchantDishCategory = `-- name: LinkMerchantDishCategory :one
INSERT INTO merchant_dish_categories (
  merchant_id,
  category_id,
  sort_order
) VALUES (
  $1, $2, $3
) ON CONFLICT (merchant_id, category_id) DO UPDATE SET 
  sort_order = EXCLUDED.sort_order
RETURNING merchant_id, category_id, sort_order, created_at
`

type LinkMerchantDishCategoryParams struct {
	MerchantID int64 `json:"merchant_id"`
	CategoryID int64 `json:"category_id"`
	SortOrder  int16 `json:"sort_order"`
}

func (q *Queries) LinkMerchantDishCategory(ctx context.Context, arg LinkMerchantDishCategoryParams) (MerchantDishCategory, error) {
	row := q.db.QueryRow(ctx, linkMerchantDishCategory, arg.MerchantID, arg.CategoryID, arg.SortOrder)
	var i MerchantDishCategory
	err := row.Scan(
		&i.MerchantID,
		&i.CategoryID,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const listAllDishIDs = `-- name: ListAllDishIDs :many
SELECT id FROM dishes WHERE deleted_at IS NULL
`

func (q *Queries) ListAllDishIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listAllDishIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishCategories = `-- name: ListDishCategories :many
SELECT c.id, c.name, c.created_at, c.deleted_at, mdc.sort_order FROM dish_categories c
JOIN merchant_dish_categories mdc ON c.id = mdc.category_id
WHERE mdc.merchant_id = $1
ORDER BY mdc.sort_order ASC, c.name ASC
`

type ListDishCategoriesRow struct {
	ID        int64              `json:"id"`
	Name      string             `json:"name"`
	CreatedAt time.Time          `json:"created_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	SortOrder int16              `json:"sort_order"`
}

func (q *Queries) ListDishCategories(ctx context.Context, merchantID int64) ([]ListDishCategoriesRow, error) {
	rows, err := q.db.Query(ctx, listDishCategories, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDishCategoriesRow{}
	for rows.Next() {
		var i ListDishCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishCustomizationGroups = `-- name: ListDishCustomizationGroups :many
SELECT id, dish_id, name, is_required, sort_order, created_at FROM dish_customization_groups
WHERE dish_id = $1
ORDER BY sort_order ASC
`

func (q *Queries) ListDishCustomizationGroups(ctx context.Context, dishID int64) ([]DishCustomizationGroup, error) {
	rows, err := q.db.Query(ctx, listDishCustomizationGroups, dishID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DishCustomizationGroup{}
	for rows.Next() {
		var i DishCustomizationGroup
		if err := rows.Scan(
			&i.ID,
			&i.DishID,
			&i.Name,
			&i.IsRequired,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishCustomizationOptions = `-- name: ListDishCustomizationOptions :many
SELECT 
  dco.id, dco.group_id, dco.tag_id, dco.extra_price, dco.sort_order,
  t.name as tag_name,
  t.type as tag_type
FROM dish_customization_options dco
JOIN tags t ON dco.tag_id = t.id
WHERE dco.group_id = $1
ORDER BY dco.sort_order ASC
`

type ListDishCustomizationOptionsRow struct {
	ID         int64  `json:"id"`
	GroupID    int64  `json:"group_id"`
	TagID      int64  `json:"tag_id"`
	ExtraPrice int64  `json:"extra_price"`
	SortOrder  int16  `json:"sort_order"`
	TagName    string `json:"tag_name"`
	TagType    string `json:"tag_type"`
}

func (q *Queries) ListDishCustomizationOptions(ctx context.Context, groupID int64) ([]ListDishCustomizationOptionsRow, error) {
	rows, err := q.db.Query(ctx, listDishCustomizationOptions, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDishCustomizationOptionsRow{}
	for rows.Next() {
		var i ListDishCustomizationOptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.TagID,
			&i.ExtraPrice,
			&i.SortOrder,
			&i.TagName,
			&i.TagType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishIngredients = `-- name: ListDishIngredients :many
SELECT 
  i.id, i.name, i.is_system, i.category, i.is_allergen, i.created_by, i.created_at
FROM ingredients i
JOIN dish_ingredients di ON i.id = di.ingredient_id
WHERE di.dish_id = $1
ORDER BY i.name ASC
`

func (q *Queries) ListDishIngredients(ctx context.Context, dishID int64) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, listDishIngredients, dishID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ingredient{}
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsSystem,
			&i.Category,
			&i.IsAllergen,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishTags = `-- name: ListDishTags :many
SELECT 
  t.id,
  t.name,
  t.type,
  t.sort_order,
  t.status,
  t.created_at
FROM tags t
JOIN dish_tags dt ON t.id = dt.tag_id
WHERE dt.dish_id = $1
ORDER BY t.sort_order ASC
`

func (q *Queries) ListDishTags(ctx context.Context, dishID int64) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listDishTags, dishID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.SortOrder,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishesByMerchant = `-- name: ListDishesByMerchant :many
SELECT id, merchant_id, category_id, name, description, image_url, price, member_price, is_available, is_online, sort_order, created_at, updated_at, prepare_time, deleted_at, monthly_sales, repurchase_rate FROM dishes
WHERE 
  merchant_id = $1
  AND deleted_at IS NULL
  AND ($4::bigint IS NULL OR category_id = $4)
  AND ($5::boolean IS NULL OR is_online = $5)
  AND ($6::boolean IS NULL OR is_available = $6)
ORDER BY sort_order ASC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListDishesByMerchantParams struct {
	MerchantID  int64       `json:"merchant_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	CategoryID  pgtype.Int8 `json:"category_id"`
	IsOnline    pgtype.Bool `json:"is_online"`
	IsAvailable pgtype.Bool `json:"is_available"`
}

func (q *Queries) ListDishesByMerchant(ctx context.Context, arg ListDishesByMerchantParams) ([]Dish, error) {
	rows, err := q.db.Query(ctx, listDishesByMerchant,
		arg.MerchantID,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.IsOnline,
		arg.IsAvailable,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Dish{}
	for rows.Next() {
		var i Dish
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PrepareTime,
			&i.DeletedAt,
			&i.MonthlySales,
			&i.RepurchaseRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDishesForMenu = `-- name: ListDishesForMenu :many
SELECT 
    d.id,
    d.category_id,
    d.name,
    d.description,
    d.image_url,
    d.price,
    d.member_price,
    d.is_available,
    d.sort_order
FROM dishes d
WHERE d.merchant_id = $1
  AND d.is_online = true
  AND d.deleted_at IS NULL
ORDER BY d.category_id, d.sort_order ASC, d.id ASC
`

type ListDishesForMenuRow struct {
	ID          int64       `json:"id"`
	CategoryID  pgtype.Int8 `json:"category_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Price       int64       `json:"price"`
	MemberPrice pgtype.Int8 `json:"member_price"`
	IsAvailable bool        `json:"is_available"`
	SortOrder   int16       `json:"sort_order"`
}

// 获取商户上架菜品（用于扫码点餐菜单展示）
func (q *Queries) ListDishesForMenu(ctx context.Context, merchantID int64) ([]ListDishesForMenuRow, error) {
	rows, err := q.db.Query(ctx, listDishesForMenu, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDishesForMenuRow{}
	for rows.Next() {
		var i ListDishesForMenuRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllDishIngredients = `-- name: RemoveAllDishIngredients :exec
DELETE FROM dish_ingredients
WHERE dish_id = $1
`

func (q *Queries) RemoveAllDishIngredients(ctx context.Context, dishID int64) error {
	_, err := q.db.Exec(ctx, removeAllDishIngredients, dishID)
	return err
}

const removeAllDishTags = `-- name: RemoveAllDishTags :exec
DELETE FROM dish_tags
WHERE dish_id = $1
`

func (q *Queries) RemoveAllDishTags(ctx context.Context, dishID int64) error {
	_, err := q.db.Exec(ctx, removeAllDishTags, dishID)
	return err
}

const removeDishIngredient = `-- name: RemoveDishIngredient :exec
DELETE FROM dish_ingredients
WHERE dish_id = $1 AND ingredient_id = $2
`

type RemoveDishIngredientParams struct {
	DishID       int64 `json:"dish_id"`
	IngredientID int64 `json:"ingredient_id"`
}

func (q *Queries) RemoveDishIngredient(ctx context.Context, arg RemoveDishIngredientParams) error {
	_, err := q.db.Exec(ctx, removeDishIngredient, arg.DishID, arg.IngredientID)
	return err
}

const removeDishTag = `-- name: RemoveDishTag :exec
DELETE FROM dish_tags
WHERE dish_id = $1 AND tag_id = $2
`

type RemoveDishTagParams struct {
	DishID int64 `json:"dish_id"`
	TagID  int64 `json:"tag_id"`
}

func (q *Queries) RemoveDishTag(ctx context.Context, arg RemoveDishTagParams) error {
	_, err := q.db.Exec(ctx, removeDishTag, arg.DishID, arg.TagID)
	return err
}

const searchDishIDsGlobal = `-- name: SearchDishIDsGlobal :many
SELECT d.id FROM dishes d
JOIN merchants m ON d.merchant_id = m.id
WHERE 
  m.status = 'active'
  AND m.deleted_at IS NULL
  AND d.deleted_at IS NULL
  AND d.is_online = true
  AND d.name ILIKE '%' || $1 || '%'
ORDER BY d.sort_order ASC, d.name ASC
`

// 全局菜品搜索，只返回菜品ID（用于推荐接口的关键词过滤）
func (q *Queries) SearchDishIDsGlobal(ctx context.Context, dollar_1 pgtype.Text) ([]int64, error) {
	rows, err := q.db.Query(ctx, searchDishIDsGlobal, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDishesByName = `-- name: SearchDishesByName :many
SELECT id, merchant_id, category_id, name, description, image_url, price, member_price, is_available, is_online, sort_order, created_at, updated_at, prepare_time, deleted_at, monthly_sales, repurchase_rate FROM dishes
WHERE 
  merchant_id = $1
  AND deleted_at IS NULL
  AND name ILIKE '%' || $2 || '%'
  AND is_online = true
ORDER BY sort_order ASC, name ASC
LIMIT $3 OFFSET $4
`

type SearchDishesByNameParams struct {
	MerchantID int64       `json:"merchant_id"`
	Column2    pgtype.Text `json:"column_2"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) SearchDishesByName(ctx context.Context, arg SearchDishesByNameParams) ([]Dish, error) {
	rows, err := q.db.Query(ctx, searchDishesByName,
		arg.MerchantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Dish{}
	for rows.Next() {
		var i Dish
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PrepareTime,
			&i.DeletedAt,
			&i.MonthlySales,
			&i.RepurchaseRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDishesGlobal = `-- name: SearchDishesGlobal :many
SELECT 
  d.id, d.merchant_id, d.category_id, d.name, d.description, d.image_url, d.price, d.member_price, d.is_available, d.is_online, d.sort_order, d.created_at, d.updated_at, d.prepare_time, d.deleted_at, d.monthly_sales, d.repurchase_rate,
  m.name AS merchant_name,
  m.logo_url AS merchant_logo,
  m.is_open AS merchant_is_open,
  m.region_id AS merchant_region_id,
  earth_distance(ll_to_earth(m.latitude::float8, m.longitude::float8), ll_to_earth($4::float8, $5::float8))::float8 AS distance
FROM dishes d
JOIN merchants m ON d.merchant_id = m.id
WHERE 
  m.status = 'active'
  AND m.deleted_at IS NULL
  AND d.deleted_at IS NULL
  AND d.is_online = true
  AND d.name ILIKE '%' || $1 || '%'
ORDER BY 
    m.is_open DESC,
    (d.monthly_sales * (1 + d.repurchase_rate)) DESC,
    distance ASC,
    d.sort_order ASC, 
    d.name ASC
LIMIT $2 OFFSET $3
`

type SearchDishesGlobalParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Column4 float64     `json:"column_4"`
	Column5 float64     `json:"column_5"`
}

type SearchDishesGlobalRow struct {
	ID               int64              `json:"id"`
	MerchantID       int64              `json:"merchant_id"`
	CategoryID       pgtype.Int8        `json:"category_id"`
	Name             string             `json:"name"`
	Description      pgtype.Text        `json:"description"`
	ImageUrl         pgtype.Text        `json:"image_url"`
	Price            int64              `json:"price"`
	MemberPrice      pgtype.Int8        `json:"member_price"`
	IsAvailable      bool               `json:"is_available"`
	IsOnline         bool               `json:"is_online"`
	SortOrder        int16              `json:"sort_order"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	PrepareTime      int16              `json:"prepare_time"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	MonthlySales     int32              `json:"monthly_sales"`
	RepurchaseRate   pgtype.Numeric     `json:"repurchase_rate"`
	MerchantName     string             `json:"merchant_name"`
	MerchantLogo     pgtype.Text        `json:"merchant_logo"`
	MerchantIsOpen   bool               `json:"merchant_is_open"`
	MerchantRegionID int64              `json:"merchant_region_id"`
	Distance         float64            `json:"distance"`
}

// 全局菜品搜索（跨商户），只搜索已激活商户的上架菜品
func (q *Queries) SearchDishesGlobal(ctx context.Context, arg SearchDishesGlobalParams) ([]SearchDishesGlobalRow, error) {
	rows, err := q.db.Query(ctx, searchDishesGlobal,
		arg.Column1,
		arg.Limit,
		arg.Offset,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDishesGlobalRow{}
	for rows.Next() {
		var i SearchDishesGlobalRow
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.MemberPrice,
			&i.IsAvailable,
			&i.IsOnline,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PrepareTime,
			&i.DeletedAt,
			&i.MonthlySales,
			&i.RepurchaseRate,
			&i.MerchantName,
			&i.MerchantLogo,
			&i.MerchantIsOpen,
			&i.MerchantRegionID,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkMerchantDishCategory = `-- name: UnlinkMerchantDishCategory :exec
DELETE FROM merchant_dish_categories
WHERE merchant_id = $1 AND category_id = $2
`

type UnlinkMerchantDishCategoryParams struct {
	MerchantID int64 `json:"merchant_id"`
	CategoryID int64 `json:"category_id"`
}

func (q *Queries) UnlinkMerchantDishCategory(ctx context.Context, arg UnlinkMerchantDishCategoryParams) error {
	_, err := q.db.Exec(ctx, unlinkMerchantDishCategory, arg.MerchantID, arg.CategoryID)
	return err
}

const updateDish = `-- name: UpdateDish :one
UPDATE dishes
SET
  category_id = COALESCE($1, category_id),
  name = COALESCE($2, name),
  description = COALESCE($3, description),
  image_url = COALESCE($4, image_url),
  price = COALESCE($5, price),
  member_price = COALESCE($6, member_price),
  is_available = COALESCE($7, is_available),
  is_online = COALESCE($8, is_online),
  sort_order = COALESCE($9, sort_order),
  prepare_time = COALESCE($10, prepare_time),
  updated_at = now()
WHERE id = $11 AND deleted_at IS NULL
RETURNING id, merchant_id, category_id, name, description, image_url, price, member_price, is_available, is_online, sort_order, created_at, updated_at, prepare_time, deleted_at, monthly_sales, repurchase_rate
`

type UpdateDishParams struct {
	CategoryID  pgtype.Int8 `json:"category_id"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Price       pgtype.Int8 `json:"price"`
	MemberPrice pgtype.Int8 `json:"member_price"`
	IsAvailable pgtype.Bool `json:"is_available"`
	IsOnline    pgtype.Bool `json:"is_online"`
	SortOrder   pgtype.Int2 `json:"sort_order"`
	PrepareTime pgtype.Int2 `json:"prepare_time"`
	ID          int64       `json:"id"`
}

func (q *Queries) UpdateDish(ctx context.Context, arg UpdateDishParams) (Dish, error) {
	row := q.db.QueryRow(ctx, updateDish,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Price,
		arg.MemberPrice,
		arg.IsAvailable,
		arg.IsOnline,
		arg.SortOrder,
		arg.PrepareTime,
		arg.ID,
	)
	var i Dish
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.MemberPrice,
		&i.IsAvailable,
		&i.IsOnline,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrepareTime,
		&i.DeletedAt,
		&i.MonthlySales,
		&i.RepurchaseRate,
	)
	return i, err
}

const updateDishAvailability = `-- name: UpdateDishAvailability :exec
UPDATE dishes
SET 
  is_available = $2,
  updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateDishAvailabilityParams struct {
	ID          int64 `json:"id"`
	IsAvailable bool  `json:"is_available"`
}

func (q *Queries) UpdateDishAvailability(ctx context.Context, arg UpdateDishAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateDishAvailability, arg.ID, arg.IsAvailable)
	return err
}

const updateDishCustomizationGroup = `-- name: UpdateDishCustomizationGroup :one
UPDATE dish_customization_groups
SET
  name = COALESCE($1, name),
  is_required = COALESCE($2, is_required),
  sort_order = COALESCE($3, sort_order)
WHERE id = $4
RETURNING id, dish_id, name, is_required, sort_order, created_at
`

type UpdateDishCustomizationGroupParams struct {
	Name       pgtype.Text `json:"name"`
	IsRequired pgtype.Bool `json:"is_required"`
	SortOrder  pgtype.Int2 `json:"sort_order"`
	ID         int64       `json:"id"`
}

func (q *Queries) UpdateDishCustomizationGroup(ctx context.Context, arg UpdateDishCustomizationGroupParams) (DishCustomizationGroup, error) {
	row := q.db.QueryRow(ctx, updateDishCustomizationGroup,
		arg.Name,
		arg.IsRequired,
		arg.SortOrder,
		arg.ID,
	)
	var i DishCustomizationGroup
	err := row.Scan(
		&i.ID,
		&i.DishID,
		&i.Name,
		&i.IsRequired,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const updateDishOnlineStatus = `-- name: UpdateDishOnlineStatus :exec
UPDATE dishes
SET 
  is_online = $2,
  updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateDishOnlineStatusParams struct {
	ID       int64 `json:"id"`
	IsOnline bool  `json:"is_online"`
}

func (q *Queries) UpdateDishOnlineStatus(ctx context.Context, arg UpdateDishOnlineStatusParams) error {
	_, err := q.db.Exec(ctx, updateDishOnlineStatus, arg.ID, arg.IsOnline)
	return err
}

const updateDishStats = `-- name: UpdateDishStats :exec
UPDATE dishes
SET 
  monthly_sales = $2,
  repurchase_rate = $3,
  updated_at = NOW()
WHERE id = $1
`

type UpdateDishStatsParams struct {
	ID             int64          `json:"id"`
	MonthlySales   int32          `json:"monthly_sales"`
	RepurchaseRate pgtype.Numeric `json:"repurchase_rate"`
}

func (q *Queries) UpdateDishStats(ctx context.Context, arg UpdateDishStatsParams) error {
	_, err := q.db.Exec(ctx, updateDishStats, arg.ID, arg.MonthlySales, arg.RepurchaseRate)
	return err
}

const updateDishesCategory = `-- name: UpdateDishesCategory :exec
UPDATE dishes
SET category_id = $1
WHERE merchant_id = $2 AND category_id = $3
`

type UpdateDishesCategoryParams struct {
	NewCategoryID pgtype.Int8 `json:"new_category_id"`
	MerchantID    int64       `json:"merchant_id"`
	OldCategoryID pgtype.Int8 `json:"old_category_id"`
}

func (q *Queries) UpdateDishesCategory(ctx context.Context, arg UpdateDishesCategoryParams) error {
	_, err := q.db.Exec(ctx, updateDishesCategory, arg.NewCategoryID, arg.MerchantID, arg.OldCategoryID)
	return err
}

const updateMerchantDishCategoryOrder = `-- name: UpdateMerchantDishCategoryOrder :one
UPDATE merchant_dish_categories
SET
  sort_order = $3
WHERE merchant_id = $1 AND category_id = $2
RETURNING merchant_id, category_id, sort_order, created_at
`

type UpdateMerchantDishCategoryOrderParams struct {
	MerchantID int64 `json:"merchant_id"`
	CategoryID int64 `json:"category_id"`
	SortOrder  int16 `json:"sort_order"`
}

func (q *Queries) UpdateMerchantDishCategoryOrder(ctx context.Context, arg UpdateMerchantDishCategoryOrderParams) (MerchantDishCategory, error) {
	row := q.db.QueryRow(ctx, updateMerchantDishCategoryOrder, arg.MerchantID, arg.CategoryID, arg.SortOrder)
	var i MerchantDishCategory
	err := row.Scan(
		&i.MerchantID,
		&i.CategoryID,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}
