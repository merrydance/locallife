// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: platform_stats.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCategoryStats = `-- name: GetCategoryStats :many
SELECT 
    t.name AS category_name,
    COUNT(DISTINCT m.id)::int AS merchant_count,
    COUNT(o.id)::int AS order_count,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_sales
FROM tags t
JOIN merchant_tags mt ON mt.tag_id = t.id
JOIN merchants m ON m.id = mt.merchant_id AND m.status = 'active'
LEFT JOIN orders o ON o.merchant_id = m.id 
    AND o.created_at >= $1 AND o.created_at <= $2
    AND o.status IN ('delivered', 'completed')
WHERE t.type = 'merchant'
GROUP BY t.id, t.name
ORDER BY total_sales DESC
`

type GetCategoryStatsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetCategoryStatsRow struct {
	CategoryName  string `json:"category_name"`
	MerchantCount int32  `json:"merchant_count"`
	OrderCount    int32  `json:"order_count"`
	TotalSales    int64  `json:"total_sales"`
}

// 分类销售统计
func (q *Queries) GetCategoryStats(ctx context.Context, arg GetCategoryStatsParams) ([]GetCategoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryStats, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryStatsRow{}
	for rows.Next() {
		var i GetCategoryStatsRow
		if err := rows.Scan(
			&i.CategoryName,
			&i.MerchantCount,
			&i.OrderCount,
			&i.TotalSales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHourlyDistribution = `-- name: GetHourlyDistribution :many
SELECT 
    EXTRACT(HOUR FROM created_at)::int AS hour,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(CASE WHEN status IN ('delivered', 'completed') THEN final_amount ELSE 0 END), 0)::bigint AS total_gmv
FROM orders
WHERE created_at >= $1 AND created_at <= $2
GROUP BY EXTRACT(HOUR FROM created_at)
ORDER BY hour
`

type GetHourlyDistributionParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetHourlyDistributionRow struct {
	Hour       int32 `json:"hour"`
	OrderCount int32 `json:"order_count"`
	TotalGmv   int64 `json:"total_gmv"`
}

// 订单时段分布
func (q *Queries) GetHourlyDistribution(ctx context.Context, arg GetHourlyDistributionParams) ([]GetHourlyDistributionRow, error) {
	rows, err := q.db.Query(ctx, getHourlyDistribution, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHourlyDistributionRow{}
	for rows.Next() {
		var i GetHourlyDistributionRow
		if err := rows.Scan(&i.Hour, &i.OrderCount, &i.TotalGmv); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantGrowthStats = `-- name: GetMerchantGrowthStats :many
SELECT 
    DATE(created_at) AS date,
    COUNT(*)::int AS new_merchants
FROM merchants
WHERE created_at >= $1 AND created_at <= $2
  AND status = 'approved'
GROUP BY DATE(created_at)
ORDER BY date
`

type GetMerchantGrowthStatsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetMerchantGrowthStatsRow struct {
	Date         pgtype.Date `json:"date"`
	NewMerchants int32       `json:"new_merchants"`
}

// 商户增长统计
func (q *Queries) GetMerchantGrowthStats(ctx context.Context, arg GetMerchantGrowthStatsParams) ([]GetMerchantGrowthStatsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantGrowthStats, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantGrowthStatsRow{}
	for rows.Next() {
		var i GetMerchantGrowthStatsRow
		if err := rows.Scan(&i.Date, &i.NewMerchants); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantRanking = `-- name: GetMerchantRanking :many
SELECT 
    m.id AS merchant_id,
    m.name AS merchant_name,
    m.region_id,
    r.name AS region_name,
    COUNT(o.id)::int AS order_count,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_sales,
    COALESCE(SUM(o.platform_commission), 0)::bigint AS total_commission,
    COALESCE(AVG(o.final_amount), 0)::bigint AS avg_order_amount
FROM merchants m
JOIN regions r ON r.id = m.region_id
LEFT JOIN orders o ON o.merchant_id = m.id 
    AND o.created_at >= $1 AND o.created_at <= $2
    AND o.status IN ('delivered', 'completed')
WHERE m.status = 'active'
GROUP BY m.id, m.name, m.region_id, r.name
ORDER BY total_sales DESC
LIMIT $3 OFFSET $4
`

type GetMerchantRankingParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetMerchantRankingRow struct {
	MerchantID      int64  `json:"merchant_id"`
	MerchantName    string `json:"merchant_name"`
	RegionID        int64  `json:"region_id"`
	RegionName      string `json:"region_name"`
	OrderCount      int32  `json:"order_count"`
	TotalSales      int64  `json:"total_sales"`
	TotalCommission int64  `json:"total_commission"`
	AvgOrderAmount  int64  `json:"avg_order_amount"`
}

// 商户销售排行
func (q *Queries) GetMerchantRanking(ctx context.Context, arg GetMerchantRankingParams) ([]GetMerchantRankingRow, error) {
	rows, err := q.db.Query(ctx, getMerchantRanking,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMerchantRankingRow{}
	for rows.Next() {
		var i GetMerchantRankingRow
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantName,
			&i.RegionID,
			&i.RegionName,
			&i.OrderCount,
			&i.TotalSales,
			&i.TotalCommission,
			&i.AvgOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformDailyStats = `-- name: GetPlatformDailyStats :many
SELECT 
    DATE(o.created_at) AS date,
    COUNT(*)::int AS order_count,
    COALESCE(SUM(CASE WHEN o.status IN ('delivered', 'completed') THEN o.final_amount ELSE 0 END), 0)::bigint AS total_gmv,
    COALESCE(SUM(CASE WHEN o.status IN ('delivered', 'completed') THEN o.platform_commission ELSE 0 END), 0)::bigint AS total_commission,
    COUNT(DISTINCT o.merchant_id)::int AS active_merchants,
    COUNT(DISTINCT o.user_id)::int AS active_users,
    COUNT(CASE WHEN o.order_type = 'takeout' THEN 1 END)::int AS takeout_orders,
    COUNT(CASE WHEN o.order_type = 'dine_in' THEN 1 END)::int AS dine_in_orders
FROM orders o
WHERE o.created_at >= $1 AND o.created_at <= $2
GROUP BY DATE(o.created_at)
ORDER BY date
`

type GetPlatformDailyStatsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetPlatformDailyStatsRow struct {
	Date            pgtype.Date `json:"date"`
	OrderCount      int32       `json:"order_count"`
	TotalGmv        int64       `json:"total_gmv"`
	TotalCommission int64       `json:"total_commission"`
	ActiveMerchants int32       `json:"active_merchants"`
	ActiveUsers     int32       `json:"active_users"`
	TakeoutOrders   int32       `json:"takeout_orders"`
	DineInOrders    int32       `json:"dine_in_orders"`
}

// 平台日统计
func (q *Queries) GetPlatformDailyStats(ctx context.Context, arg GetPlatformDailyStatsParams) ([]GetPlatformDailyStatsRow, error) {
	rows, err := q.db.Query(ctx, getPlatformDailyStats, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlatformDailyStatsRow{}
	for rows.Next() {
		var i GetPlatformDailyStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderCount,
			&i.TotalGmv,
			&i.TotalCommission,
			&i.ActiveMerchants,
			&i.ActiveUsers,
			&i.TakeoutOrders,
			&i.DineInOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformOverview = `-- name: GetPlatformOverview :one

SELECT 
    COUNT(DISTINCT CASE WHEN o.created_at >= $1 AND o.created_at <= $2 THEN o.id END)::int AS total_orders,
    COALESCE(SUM(CASE WHEN o.created_at >= $1 AND o.created_at <= $2 AND o.status IN ('delivered', 'completed') THEN o.final_amount ELSE 0 END), 0)::bigint AS total_gmv,
    COALESCE(SUM(CASE WHEN o.created_at >= $1 AND o.created_at <= $2 AND o.status IN ('delivered', 'completed') THEN o.platform_commission ELSE 0 END), 0)::bigint AS total_commission,
    COUNT(DISTINCT CASE WHEN o.created_at >= $1 AND o.created_at <= $2 THEN o.merchant_id END)::int AS active_merchants,
    COUNT(DISTINCT CASE WHEN o.created_at >= $1 AND o.created_at <= $2 THEN o.user_id END)::int AS active_users
FROM orders o
WHERE o.status NOT IN ('cancelled')
`

type GetPlatformOverviewParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetPlatformOverviewRow struct {
	TotalOrders     int32 `json:"total_orders"`
	TotalGmv        int64 `json:"total_gmv"`
	TotalCommission int64 `json:"total_commission"`
	ActiveMerchants int32 `json:"active_merchants"`
	ActiveUsers     int32 `json:"active_users"`
}

// M12: 平台端统计查询
// 平台全局概览
func (q *Queries) GetPlatformOverview(ctx context.Context, arg GetPlatformOverviewParams) (GetPlatformOverviewRow, error) {
	row := q.db.QueryRow(ctx, getPlatformOverview, arg.CreatedAt, arg.CreatedAt_2)
	var i GetPlatformOverviewRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalGmv,
		&i.TotalCommission,
		&i.ActiveMerchants,
		&i.ActiveUsers,
	)
	return i, err
}

const getRealtimeDashboard = `-- name: GetRealtimeDashboard :one
SELECT 
    COUNT(*)::int AS orders_24h,
    COALESCE(SUM(CASE WHEN status IN ('delivered', 'completed') THEN final_amount ELSE 0 END), 0)::bigint AS gmv_24h,
    COUNT(DISTINCT merchant_id)::int AS active_merchants_24h,
    COUNT(DISTINCT user_id)::int AS active_users_24h,
    COUNT(CASE WHEN status = 'pending' THEN 1 END)::int AS pending_orders,
    COUNT(CASE WHEN status = 'preparing' THEN 1 END)::int AS preparing_orders,
    COUNT(CASE WHEN status = 'ready' THEN 1 END)::int AS ready_orders,
    COUNT(CASE WHEN status = 'delivering' THEN 1 END)::int AS delivering_orders
FROM orders
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetRealtimeDashboardRow struct {
	Orders24h          int32 `json:"orders_24h"`
	Gmv24h             int64 `json:"gmv_24h"`
	ActiveMerchants24h int32 `json:"active_merchants_24h"`
	ActiveUsers24h     int32 `json:"active_users_24h"`
	PendingOrders      int32 `json:"pending_orders"`
	PreparingOrders    int32 `json:"preparing_orders"`
	ReadyOrders        int32 `json:"ready_orders"`
	DeliveringOrders   int32 `json:"delivering_orders"`
}

// 实时大盘数据(最近24小时)
func (q *Queries) GetRealtimeDashboard(ctx context.Context) (GetRealtimeDashboardRow, error) {
	row := q.db.QueryRow(ctx, getRealtimeDashboard)
	var i GetRealtimeDashboardRow
	err := row.Scan(
		&i.Orders24h,
		&i.Gmv24h,
		&i.ActiveMerchants24h,
		&i.ActiveUsers24h,
		&i.PendingOrders,
		&i.PreparingOrders,
		&i.ReadyOrders,
		&i.DeliveringOrders,
	)
	return i, err
}

const getRegionComparison = `-- name: GetRegionComparison :many
SELECT 
    r.id AS region_id,
    r.name AS region_name,
    COUNT(DISTINCT m.id)::int AS merchant_count,
    COUNT(DISTINCT o.id)::int AS order_count,
    COALESCE(SUM(o.final_amount), 0)::bigint AS total_gmv,
    COALESCE(SUM(o.platform_commission), 0)::bigint AS total_commission,
    COALESCE(AVG(o.final_amount), 0)::bigint AS avg_order_amount,
    COUNT(DISTINCT o.user_id)::int AS active_users
FROM regions r
LEFT JOIN merchants m ON m.region_id = r.id AND m.status = 'active'
LEFT JOIN orders o ON o.merchant_id = m.id 
    AND o.created_at >= $1 AND o.created_at <= $2
    AND o.status IN ('delivered', 'completed')
GROUP BY r.id, r.name
ORDER BY total_gmv DESC
`

type GetRegionComparisonParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetRegionComparisonRow struct {
	RegionID        int64  `json:"region_id"`
	RegionName      string `json:"region_name"`
	MerchantCount   int32  `json:"merchant_count"`
	OrderCount      int32  `json:"order_count"`
	TotalGmv        int64  `json:"total_gmv"`
	TotalCommission int64  `json:"total_commission"`
	AvgOrderAmount  int64  `json:"avg_order_amount"`
	ActiveUsers     int32  `json:"active_users"`
}

// 区域对比分析
func (q *Queries) GetRegionComparison(ctx context.Context, arg GetRegionComparisonParams) ([]GetRegionComparisonRow, error) {
	rows, err := q.db.Query(ctx, getRegionComparison, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionComparisonRow{}
	for rows.Next() {
		var i GetRegionComparisonRow
		if err := rows.Scan(
			&i.RegionID,
			&i.RegionName,
			&i.MerchantCount,
			&i.OrderCount,
			&i.TotalGmv,
			&i.TotalCommission,
			&i.AvgOrderAmount,
			&i.ActiveUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRiderPerformanceRanking = `-- name: GetRiderPerformanceRanking :many
SELECT 
    r.id AS rider_id,
    u.full_name AS rider_name,
    COUNT(d.id)::int AS delivery_count,
    COUNT(CASE WHEN d.status = 'completed' THEN 1 END)::int AS completed_count,
    COALESCE(AVG(EXTRACT(EPOCH FROM (d.delivered_at - d.picked_at))), 0)::int AS avg_delivery_time_seconds,
    r.total_earnings AS total_earnings
FROM riders r
JOIN users u ON u.id = r.user_id
LEFT JOIN deliveries d ON d.rider_id = r.id 
    AND d.created_at >= $1 AND d.created_at <= $2
WHERE r.status = 'active'
GROUP BY r.id, u.full_name, r.total_earnings
HAVING COUNT(d.id) > 0
ORDER BY completed_count DESC
LIMIT $3 OFFSET $4
`

type GetRiderPerformanceRankingParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetRiderPerformanceRankingRow struct {
	RiderID                int64  `json:"rider_id"`
	RiderName              string `json:"rider_name"`
	DeliveryCount          int32  `json:"delivery_count"`
	CompletedCount         int32  `json:"completed_count"`
	AvgDeliveryTimeSeconds int32  `json:"avg_delivery_time_seconds"`
	TotalEarnings          int64  `json:"total_earnings"`
}

// 骑手绩效排行(全平台)
func (q *Queries) GetRiderPerformanceRanking(ctx context.Context, arg GetRiderPerformanceRankingParams) ([]GetRiderPerformanceRankingRow, error) {
	rows, err := q.db.Query(ctx, getRiderPerformanceRanking,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRiderPerformanceRankingRow{}
	for rows.Next() {
		var i GetRiderPerformanceRankingRow
		if err := rows.Scan(
			&i.RiderID,
			&i.RiderName,
			&i.DeliveryCount,
			&i.CompletedCount,
			&i.AvgDeliveryTimeSeconds,
			&i.TotalEarnings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrowthStats = `-- name: GetUserGrowthStats :many
SELECT 
    DATE(created_at) AS date,
    COUNT(*)::int AS new_users
FROM users
WHERE created_at >= $1 AND created_at <= $2
GROUP BY DATE(created_at)
ORDER BY date
`

type GetUserGrowthStatsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetUserGrowthStatsRow struct {
	Date     pgtype.Date `json:"date"`
	NewUsers int32       `json:"new_users"`
}

// 用户增长统计
func (q *Queries) GetUserGrowthStats(ctx context.Context, arg GetUserGrowthStatsParams) ([]GetUserGrowthStatsRow, error) {
	rows, err := q.db.Query(ctx, getUserGrowthStats, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrowthStatsRow{}
	for rows.Next() {
		var i GetUserGrowthStatsRow
		if err := rows.Scan(&i.Date, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
